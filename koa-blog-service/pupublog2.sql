/*
 Navicat Premium Data Transfer

 Source Server         : 本地
 Source Server Type    : MySQL
 Source Server Version : 50719
 Source Host           : localhost:3306
 Source Schema         : pupublog

 Target Server Type    : MySQL
 Target Server Version : 50719
 File Encoding         : 65001

 Date: 23/12/2021 18:07:02
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for mt_blog_blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `mt_blog_blog_tag`;
CREATE TABLE `mt_blog_blog_tag`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '唯一主键id，自增，数据库自己维护',
  `blog_id` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客的id',
  `blog_tag_id` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客标签的id',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间',
  `blog_is_private` int(11) NULL DEFAULT 2 COMMENT '博客是否是私密的，1 私密；2 公开',
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `fk_blog_id`(`blog_id`) USING BTREE,
  CONSTRAINT `fk_blog_id` FOREIGN KEY (`blog_id`) REFERENCES `t_blog` (`uid`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 188 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '中间表：博客&博客标签\r\n    表示博客所属的标签，\r\n    一篇博客可以有多个标签，一对多关系' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of mt_blog_blog_tag
-- ----------------------------
INSERT INTO `mt_blog_blog_tag` VALUES (63, 'f0f3fbe0-2cbf-11ec-86ae-0da8227970f6', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-10-14 15:25:43', '2021-10-14 15:25:43', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (64, '98230e60-2cc0-11ec-86ae-0da8227970f6', '41a34ec0-2cbf-11ec-86ae-0da8227970f6', '2021-10-14 15:30:23', '2021-10-14 15:30:23', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (65, '0e884810-2d87-11ec-ba0f-810bb435395b', '41a34ec0-2cbf-11ec-86ae-0da8227970f6', '2021-10-15 15:13:21', '2021-10-15 15:13:21', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (66, '7a836150-2d8a-11ec-ba0f-810bb435395b', '41a34ec0-2cbf-11ec-86ae-0da8227970f6', '2021-10-15 15:35:32', '2021-10-15 15:35:32', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (68, 'b94be010-2d94-11ec-ba0f-810bb435395b', 'e0526a30-2d94-11ec-ba0f-810bb435395b', '2021-10-15 16:50:30', '2021-10-15 16:50:30', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (69, 'b51d3e10-3214-11ec-bd70-1746ca2eb62a', '47009940-2cbf-11ec-86ae-0da8227970f6', '2021-10-21 10:15:06', '2021-10-21 10:15:06', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (70, '7e76a540-3250-11ec-a1da-59f2d55bf031', '47009940-2cbf-11ec-86ae-0da8227970f6', '2021-10-21 17:23:04', '2021-10-21 17:23:04', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (71, '8bafda00-346d-11ec-a1da-59f2d55bf031', '47009940-2cbf-11ec-86ae-0da8227970f6', '2021-10-24 09:56:04', '2021-10-24 09:56:04', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (72, 'd6c6e1f0-347c-11ec-a1da-59f2d55bf031', '47009940-2cbf-11ec-86ae-0da8227970f6', '2021-10-24 11:45:32', '2021-10-24 11:45:32', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (73, '53c38cb0-34a7-11ec-a1da-59f2d55bf031', '47009940-2cbf-11ec-86ae-0da8227970f6', '2021-10-24 16:49:41', '2021-10-24 16:49:41', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (74, 'd5e060a0-34cb-11ec-a1da-59f2d55bf031', '47009940-2cbf-11ec-86ae-0da8227970f6', '2021-10-24 21:11:01', '2021-10-24 21:11:01', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (75, '28792100-359c-11ec-94ec-9def32579e94', '47009940-2cbf-11ec-86ae-0da8227970f6', '2021-10-25 22:02:15', '2021-10-25 22:02:15', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (76, '5cb12ae0-397e-11ec-8015-f554da021b2a', '37ef2d40-2cbf-11ec-86ae-0da8227970f6', '2021-10-30 20:39:02', '2021-10-30 20:39:02', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (78, '7fa91c70-3a40-11ec-8015-f554da021b2a', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-10-31 19:48:53', '2021-10-31 19:48:53', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (79, '56340d60-3b7f-11ec-8015-f554da021b2a', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-02 09:51:03', '2021-11-02 09:51:03', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (81, '09169a10-3d10-11ec-8015-f554da021b2a', '51f55110-2cbf-11ec-86ae-0da8227970f6', '2021-11-04 14:45:09', '2021-11-04 14:45:09', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (82, '09169a10-3d10-11ec-8015-f554da021b2a', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-04 14:45:09', '2021-11-04 14:45:09', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (83, '53cf64b0-3d88-11ec-8015-f554da021b2a', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-05 00:00:27', '2021-11-05 00:00:27', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (84, '3fbc4640-3d89-11ec-97a5-ef78eceb5d73', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-05 00:07:03', '2021-11-05 00:07:03', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (85, '3c9212f0-3d8a-11ec-97a5-ef78eceb5d73', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-05 00:14:07', '2021-11-05 00:14:07', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (86, '87a08d30-3d8a-11ec-97a5-ef78eceb5d73', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-05 00:16:13', '2021-11-05 00:16:13', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (87, 'd12707e0-3d8a-11ec-97a5-ef78eceb5d73', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-05 00:18:16', '2021-11-05 00:18:16', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (88, '1d47dc80-3d8b-11ec-97a5-ef78eceb5d73', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-05 00:20:24', '2021-11-05 00:20:24', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (89, '6f8f8d30-3d8b-11ec-97a5-ef78eceb5d73', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-05 00:22:42', '2021-11-05 00:22:42', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (90, 'b384b510-3d8b-11ec-97a5-ef78eceb5d73', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-05 00:24:36', '2021-11-05 00:24:36', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (91, '0a797310-3d8c-11ec-97a5-ef78eceb5d73', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-05 00:27:02', '2021-11-05 00:27:02', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (92, 'f8df21c0-408a-11ec-97a5-ef78eceb5d73', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-08 19:56:56', '2021-11-08 19:56:56', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (93, '13dd83a0-410c-11ec-94eb-3706a2e7018e', 'f2170bb0-3a3f-11ec-8015-f554da021b2a', '2021-11-09 11:21:07', '2021-11-09 11:21:07', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (94, '0bbfd760-420e-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-10 18:07:43', '2021-11-10 18:07:43', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (95, '9499b500-42c3-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-11 15:47:12', '2021-11-11 15:47:12', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (96, '48fb4e60-4606-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-15 19:22:14', '2021-11-15 19:22:14', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (97, 'd6eb4710-4689-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-16 11:03:57', '2021-11-16 11:03:57', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (98, '2985aea0-48da-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-19 09:43:57', '2021-11-19 09:43:57', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (99, 'd44e8580-48e1-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-19 10:38:50', '2021-11-19 10:38:50', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (100, '6d0bd440-49db-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-20 16:25:31', '2021-11-20 16:25:31', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (101, 'cb7285e0-4ae1-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-21 23:43:38', '2021-11-21 23:43:38', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (102, '7af13780-4b48-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-22 11:58:41', '2021-11-22 11:58:41', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (103, '544247d0-4b8b-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-22 19:57:12', '2021-11-22 19:57:12', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (104, '561993b0-4e5b-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-26 09:51:13', '2021-11-26 09:51:13', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (105, '87ecdb40-4e5b-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-26 09:52:37', '2021-11-26 09:52:37', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (106, 'aa9450f0-4f1f-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-27 09:16:36', '2021-11-27 09:16:36', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (107, 'c69fa070-5018-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-28 14:59:48', '2021-11-28 14:59:48', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (108, 'b86f6770-50ee-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-29 16:31:16', '2021-11-29 16:31:16', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (109, 'e6f5d9b0-5109-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-29 19:45:51', '2021-11-29 19:45:51', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (110, '556df770-51ea-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-11-30 22:32:23', '2021-11-30 22:32:23', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (111, 'f2b03be0-5250-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-12-01 10:46:56', '2021-12-01 10:46:56', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (112, 'aa11c6a0-5355-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-12-02 17:53:13', '2021-12-02 17:53:13', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (113, '46fdf7c0-54ac-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-12-04 10:45:44', '2021-12-04 10:45:44', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (114, '52704660-54e0-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-04 17:00:00', '2021-12-04 17:00:00', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (115, '46990ae0-54ed-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-04 18:31:01', '2021-12-04 18:31:01', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (116, '276f1d80-5579-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-05 11:12:18', '2021-12-05 11:12:18', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (117, 'a75b0ab0-557c-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-05 11:37:21', '2021-12-05 11:37:21', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (118, 'ae29d4d0-55a3-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-05 16:16:43', '2021-12-05 16:16:43', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (119, 'baf99490-55ab-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-05 17:14:20', '2021-12-05 17:14:20', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (120, '70387930-55ba-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-05 18:59:37', '2021-12-05 18:59:37', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (121, 'd94ae140-5648-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-06 11:59:02', '2021-12-06 11:59:02', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (122, '8f7d1a00-566c-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-06 16:14:40', '2021-12-06 16:14:40', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (123, 'd427ae30-5677-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-06 17:35:20', '2021-12-06 17:35:20', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (124, '6ee9a830-5711-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-07 11:54:52', '2021-12-07 11:54:52', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (125, 'd210f890-573a-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-07 16:51:08', '2021-12-07 16:51:08', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (126, '1f3a9b90-5744-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-07 17:57:43', '2021-12-07 17:57:43', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (127, '64a45de0-574b-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-07 18:49:46', '2021-12-07 18:49:46', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (128, '8b9cc6b0-57d9-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-08 11:47:20', '2021-12-08 11:47:20', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (129, 'ef3306b0-581c-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-08 19:49:43', '2021-12-08 19:49:43', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (130, '02832040-583d-11ec-96d5-7933aca11ca0', '5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '2021-12-08 23:39:20', '2021-12-08 23:39:20', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (131, 'a8f45760-58f5-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-12-09 21:41:06', '2021-12-09 21:41:06', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (132, '5a41a680-59b4-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-12-10 20:26:08', '2021-12-10 20:26:08', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (133, '8bb3bd10-5bea-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-12-13 15:59:06', '2021-12-13 15:59:06', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (134, 'c0bfbad0-5c81-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-12-14 10:01:29', '2021-12-14 10:01:29', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (135, '8399b160-5c8b-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-12-14 11:11:21', '2021-12-14 11:11:21', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (136, '2631d1a0-5cc3-11ec-96d5-7933aca11ca0', '641f1720-5cc3-11ec-96d5-7933aca11ca0', '2021-12-14 17:51:41', '2021-12-14 17:51:41', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (137, 'ac3475a0-5cc3-11ec-96d5-7933aca11ca0', '641f1720-5cc3-11ec-96d5-7933aca11ca0', '2021-12-14 17:53:21', '2021-12-14 17:53:21', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (138, '7484ff10-5d51-11ec-96d5-7933aca11ca0', '641f1720-5cc3-11ec-96d5-7933aca11ca0', '2021-12-15 10:48:17', '2021-12-15 10:48:17', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (139, 'd40c4520-5d55-11ec-96d5-7933aca11ca0', '641f1720-5cc3-11ec-96d5-7933aca11ca0', '2021-12-15 11:19:35', '2021-12-15 11:19:35', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (140, 'feea23c0-5d5a-11ec-96d5-7933aca11ca0', '3b767f40-2cbf-11ec-86ae-0da8227970f6', '2021-12-15 11:56:34', '2021-12-15 11:56:34', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (141, 'b1cd1a30-5d6d-11ec-96d5-7933aca11ca0', '641f1720-5cc3-11ec-96d5-7933aca11ca0', '2021-12-15 14:10:25', '2021-12-15 14:10:25', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (142, '97ad9e00-5d99-11ec-b395-6d1b1a7579ec', '641f1720-5cc3-11ec-96d5-7933aca11ca0', '2021-12-15 19:24:39', '2021-12-15 19:24:39', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (143, '32b34b70-5da9-11ec-b395-6d1b1a7579ec', '641f1720-5cc3-11ec-96d5-7933aca11ca0', '2021-12-15 21:16:22', '2021-12-15 21:16:22', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (144, '100002f0-5db6-11ec-b395-6d1b1a7579ec', '641f1720-5cc3-11ec-96d5-7933aca11ca0', '2021-12-15 22:48:27', '2021-12-15 22:48:27', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (145, '7e0e3a30-5db8-11ec-b395-6d1b1a7579ec', '641f1720-5cc3-11ec-96d5-7933aca11ca0', '2021-12-15 23:05:51', '2021-12-15 23:05:51', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (147, '6e23f3c0-5e4f-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-16 17:06:18', '2021-12-16 17:06:18', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (148, '87ae8880-5e5b-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-16 18:33:19', '2021-12-16 18:33:19', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (149, '110ef950-5e63-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-16 19:26:52', '2021-12-16 19:26:52', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (150, '375e4490-5e67-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-16 19:56:34', '2021-12-16 19:56:34', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (151, 'dc2dbb30-5e72-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-16 21:19:55', '2021-12-16 21:19:55', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (152, '0fd5ab30-5f01-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-17 14:17:50', '2021-12-17 14:17:50', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (153, '0fd5ab30-5f01-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-17 14:17:50', '2021-12-17 14:17:50', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (154, '32ee6610-5f11-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-17 16:13:21', '2021-12-17 16:13:21', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (155, '32ee6610-5f11-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-17 16:13:21', '2021-12-17 16:13:21', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (156, '1910a970-5f1f-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-17 17:52:51', '2021-12-17 17:52:51', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (157, 'ec46c330-5f22-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-17 18:20:13', '2021-12-17 18:20:13', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (158, 'ec46c330-5f22-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-17 18:20:13', '2021-12-17 18:20:13', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (159, '0c25cd50-5f27-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-17 18:49:45', '2021-12-17 18:49:45', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (160, '0c25cd50-5f27-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-17 18:49:45', '2021-12-17 18:49:45', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (161, '98816ad0-5f30-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-17 19:58:06', '2021-12-17 19:58:06', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (162, '98816ad0-5f30-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-17 19:58:06', '2021-12-17 19:58:06', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (163, '87ae3b80-5f39-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-17 21:02:03', '2021-12-17 21:02:03', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (164, '87ae3b80-5f39-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-17 21:02:03', '2021-12-17 21:02:03', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (165, '8652d6f0-5f49-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-17 22:56:33', '2021-12-17 22:56:33', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (166, '8652d6f0-5f49-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-17 22:56:33', '2021-12-17 22:56:33', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (167, '43673d90-5f4e-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-17 23:30:28', '2021-12-17 23:30:28', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (168, '43673d90-5f4e-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-17 23:30:28', '2021-12-17 23:30:28', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (169, 'd4435a20-5f57-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-18 00:38:56', '2021-12-18 00:38:56', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (170, 'd4435a20-5f57-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-18 00:38:56', '2021-12-18 00:38:56', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (171, '8370a350-5fb1-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-18 11:20:56', '2021-12-18 11:20:56', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (172, '8370a350-5fb1-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-18 11:20:56', '2021-12-18 11:20:56', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (173, '5d170b20-5fea-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-18 18:07:53', '2021-12-18 18:07:53', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (174, '5d170b20-5fea-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-18 18:07:53', '2021-12-18 18:07:53', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (175, '3cf298f0-5ff9-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-18 19:54:21', '2021-12-18 19:54:21', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (176, '3cf298f0-5ff9-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-18 19:54:21', '2021-12-18 19:54:21', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (177, 'd036a7a0-606c-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-19 09:41:40', '2021-12-19 09:41:40', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (178, 'd036a7a0-606c-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-19 09:41:40', '2021-12-19 09:41:40', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (179, '919af480-607e-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-19 11:48:46', '2021-12-19 11:48:46', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (180, '919af480-607e-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-19 11:48:46', '2021-12-19 11:48:46', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (181, 'b3c57fd0-6083-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-19 12:25:31', '2021-12-19 12:25:31', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (182, 'b3c57fd0-6083-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-19 12:25:31', '2021-12-19 12:25:31', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (183, 'a3d1b000-60b8-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-19 18:44:28', '2021-12-19 18:44:28', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (184, 'a3d1b000-60b8-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-19 18:44:28', '2021-12-19 18:44:28', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (185, '16796530-60be-11ec-b395-6d1b1a7579ec', '8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '2021-12-19 19:23:27', '2021-12-19 19:23:27', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (186, '16796530-60be-11ec-b395-6d1b1a7579ec', 'f7240800-5e49-11ec-b395-6d1b1a7579ec', '2021-12-19 19:23:27', '2021-12-19 19:23:27', 2);
INSERT INTO `mt_blog_blog_tag` VALUES (187, 'd3704000-63a7-11ec-ac62-9b20ec8e21d3', '37ef2d40-2cbf-11ec-86ae-0da8227970f6', '2021-12-23 12:21:39', '2021-12-23 12:21:39', 1);

-- ----------------------------
-- Table structure for mt_special_part_section_blogs
-- ----------------------------
DROP TABLE IF EXISTS `mt_special_part_section_blogs`;
CREATE TABLE `mt_special_part_section_blogs`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `part_section_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '属于哪个章节：存放的是章节的uid',
  `blog_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '博客：存放的是博客的uid',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '章节下的文章：存放文章的uid' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of mt_special_part_section_blogs
-- ----------------------------
INSERT INTO `mt_special_part_section_blogs` VALUES ('06e571b0-5d5b-11ec-96d5-7933aca11ca0', '9f14a130-5d57-11ec-96d5-7933aca11ca0', 'feea23c0-5d5a-11ec-96d5-7933aca11ca0', 1, '2021-12-15 11:56:48', '2021-12-15 11:56:48');
INSERT INTO `mt_special_part_section_blogs` VALUES ('07652320-5251-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'f2b03be0-5250-11ec-96d5-7933aca11ca0', 18, '2021-12-01 10:47:31', '2021-12-01 10:47:31');
INSERT INTO `mt_special_part_section_blogs` VALUES ('0bddc060-589b-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', 'd427ae30-5677-11ec-96d5-7933aca11ca0', 10, '2021-12-09 10:52:28', '2021-12-09 10:52:28');
INSERT INTO `mt_special_part_section_blogs` VALUES ('0e8d18a0-583d-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '02832040-583d-11ec-96d5-7933aca11ca0', 17, '2021-12-08 23:39:40', '2021-12-08 23:39:40');
INSERT INTO `mt_special_part_section_blogs` VALUES ('1119c740-589b-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '6ee9a830-5711-11ec-96d5-7933aca11ca0', 11, '2021-12-09 10:52:37', '2021-12-09 10:52:37');
INSERT INTO `mt_special_part_section_blogs` VALUES ('1809bfb0-589b-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', 'd210f890-573a-11ec-96d5-7933aca11ca0', 12, '2021-12-09 10:52:48', '2021-12-09 10:52:48');
INSERT INTO `mt_special_part_section_blogs` VALUES ('1aa88320-5f01-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '0fd5ab30-5f01-11ec-b395-6d1b1a7579ec', 4, '2021-12-17 14:18:08', '2021-12-17 14:18:08');
INSERT INTO `mt_special_part_section_blogs` VALUES ('1b519f30-5e63-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '110ef950-5e63-11ec-b395-6d1b1a7579ec', 2, '2021-12-16 19:27:09', '2021-12-16 19:27:09');
INSERT INTO `mt_special_part_section_blogs` VALUES ('1c4fd540-5f27-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '0c25cd50-5f27-11ec-b395-6d1b1a7579ec', 6, '2021-12-17 18:50:12', '2021-12-17 18:50:12');
INSERT INTO `mt_special_part_section_blogs` VALUES ('1d086f70-589b-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '1f3a9b90-5744-11ec-96d5-7933aca11ca0', 13, '2021-12-09 10:52:57', '2021-12-09 10:52:57');
INSERT INTO `mt_special_part_section_blogs` VALUES ('1e18de20-5db6-11ec-b395-6d1b1a7579ec', '04bf3a90-5c90-11ec-96d5-7933aca11ca0', '100002f0-5db6-11ec-b395-6d1b1a7579ec', 8, '2021-12-15 22:48:51', '2021-12-15 22:48:51');
INSERT INTO `mt_special_part_section_blogs` VALUES ('21ae50d0-589b-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '64a45de0-574b-11ec-96d5-7933aca11ca0', 14, '2021-12-09 10:53:04', '2021-12-09 10:53:04');
INSERT INTO `mt_special_part_section_blogs` VALUES ('23df7140-468a-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '0bbfd760-420e-11ec-96d5-7933aca11ca0', 2, '2021-11-16 11:06:06', '2021-11-16 11:06:06');
INSERT INTO `mt_special_part_section_blogs` VALUES ('245648d0-60be-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '16796530-60be-11ec-b395-6d1b1a7579ec', 19, '2021-12-19 19:23:51', '2021-12-19 19:23:51');
INSERT INTO `mt_special_part_section_blogs` VALUES ('26f925d0-5f1f-11ec-b395-6d1b1a7579ec', '8b5f9a50-569f-11ec-96d5-7933aca11ca0', '1910a970-5f1f-11ec-b395-6d1b1a7579ec', 3, '2021-12-17 17:53:14', '2021-12-17 17:53:14');
INSERT INTO `mt_special_part_section_blogs` VALUES ('275e7640-589b-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '8b9cc6b0-57d9-11ec-96d5-7933aca11ca0', 15, '2021-12-09 10:53:14', '2021-12-09 10:53:14');
INSERT INTO `mt_special_part_section_blogs` VALUES ('2a05f970-5744-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '1f3a9b90-5744-11ec-96d5-7933aca11ca0', 13, '2021-12-07 17:58:01', '2021-12-07 17:58:01');
INSERT INTO `mt_special_part_section_blogs` VALUES ('2d804940-589b-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', 'ef3306b0-581c-11ec-96d5-7933aca11ca0', 16, '2021-12-09 10:53:24', '2021-12-09 10:53:24');
INSERT INTO `mt_special_part_section_blogs` VALUES ('3252e560-5579-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '276f1d80-5579-11ec-96d5-7933aca11ca0', 3, '2021-12-05 11:12:36', '2021-12-05 11:12:36');
INSERT INTO `mt_special_part_section_blogs` VALUES ('32fa7a30-468a-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'd6eb4710-4689-11ec-96d5-7933aca11ca0', 3, '2021-11-16 11:06:31', '2021-11-16 11:06:31');
INSERT INTO `mt_special_part_section_blogs` VALUES ('33a5ecd0-589b-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '02832040-583d-11ec-96d5-7933aca11ca0', 17, '2021-12-09 10:53:35', '2021-12-09 10:53:35');
INSERT INTO `mt_special_part_section_blogs` VALUES ('34a239c0-48da-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '2985aea0-48da-11ec-96d5-7933aca11ca0', 5, '2021-11-19 09:44:16', '2021-11-19 09:44:23');
INSERT INTO `mt_special_part_section_blogs` VALUES ('3c1b0e40-468a-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '48fb4e60-4606-11ec-96d5-7933aca11ca0', 4, '2021-11-16 11:06:46', '2021-11-16 11:06:46');
INSERT INTO `mt_special_part_section_blogs` VALUES ('3c6caa80-5f11-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '32ee6610-5f11-11ec-b395-6d1b1a7579ec', 5, '2021-12-17 16:13:37', '2021-12-17 16:13:37');
INSERT INTO `mt_special_part_section_blogs` VALUES ('3d585ca0-5da9-11ec-b395-6d1b1a7579ec', '04bf3a90-5c90-11ec-96d5-7933aca11ca0', '32b34b70-5da9-11ec-b395-6d1b1a7579ec', 7, '2021-12-15 21:16:40', '2021-12-15 21:16:40');
INSERT INTO `mt_special_part_section_blogs` VALUES ('438254a0-5e67-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '375e4490-5e67-11ec-b395-6d1b1a7579ec', 3, '2021-12-16 19:56:54', '2021-12-16 19:56:54');
INSERT INTO `mt_special_part_section_blogs` VALUES ('442f3350-42c4-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '9499b500-42c3-11ec-96d5-7933aca11ca0', 1, '2021-11-11 15:52:06', '2021-11-11 15:52:06');
INSERT INTO `mt_special_part_section_blogs` VALUES ('45bafae0-5ff9-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '3cf298f0-5ff9-11ec-b395-6d1b1a7579ec', 14, '2021-12-18 19:54:36', '2021-12-18 19:54:36');
INSERT INTO `mt_special_part_section_blogs` VALUES ('5147f1c0-5f4e-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '43673d90-5f4e-11ec-b395-6d1b1a7579ec', 10, '2021-12-17 23:30:51', '2021-12-17 23:30:51');
INSERT INTO `mt_special_part_section_blogs` VALUES ('52b86000-54ed-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '46990ae0-54ed-11ec-96d5-7933aca11ca0', 2, '2021-12-04 18:31:21', '2021-12-04 18:31:21');
INSERT INTO `mt_special_part_section_blogs` VALUES ('52e43b80-54ac-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '46fdf7c0-54ac-11ec-96d5-7933aca11ca0', 20, '2021-12-04 10:46:04', '2021-12-04 10:46:04');
INSERT INTO `mt_special_part_section_blogs` VALUES ('5db74710-410f-11ec-96d5-7933aca11ca0', '4b2fb200-410d-11ec-94eb-3706a2e7018e', '09169a10-3d10-11ec-8015-f554da021b2a', 1, '2021-11-09 11:44:39', '2021-11-09 11:44:39');
INSERT INTO `mt_special_part_section_blogs` VALUES ('60a20150-4b8b-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '544247d0-4b8b-11ec-96d5-7933aca11ca0', 10, '2021-11-22 19:57:33', '2021-11-22 19:57:33');
INSERT INTO `mt_special_part_section_blogs` VALUES ('621a9db0-3d8c-11ec-97a5-ef78eceb5d73', 'fadccf90-30bd-11ec-bd70-1746ca2eb62a', '53cf64b0-3d88-11ec-8015-f554da021b2a', 1, '2021-11-05 00:29:29', '2021-11-05 00:29:29');
INSERT INTO `mt_special_part_section_blogs` VALUES ('62ceaef0-410f-11ec-96d5-7933aca11ca0', '4b2fb200-410d-11ec-94eb-3706a2e7018e', 'f8df21c0-408a-11ec-97a5-ef78eceb5d73', 2, '2021-11-09 11:44:47', '2021-11-09 11:44:47');
INSERT INTO `mt_special_part_section_blogs` VALUES ('65ad3c00-59b4-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '5a41a680-59b4-11ec-96d5-7933aca11ca0', 23, '2021-12-10 20:26:27', '2021-12-10 20:26:27');
INSERT INTO `mt_special_part_section_blogs` VALUES ('677130a0-5fea-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '5d170b20-5fea-11ec-b395-6d1b1a7579ec', 13, '2021-12-18 18:08:10', '2021-12-18 18:08:10');
INSERT INTO `mt_special_part_section_blogs` VALUES ('68ebc700-410f-11ec-96d5-7933aca11ca0', '4b2fb200-410d-11ec-94eb-3706a2e7018e', '13dd83a0-410c-11ec-94eb-3706a2e7018e', 3, '2021-11-09 11:44:58', '2021-11-09 11:44:58');
INSERT INTO `mt_special_part_section_blogs` VALUES ('69f36750-589a-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '02832040-583d-11ec-96d5-7933aca11ca0', 21, '2021-12-09 10:47:56', '2021-12-09 10:47:56');
INSERT INTO `mt_special_part_section_blogs` VALUES ('6fad12e0-574b-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '64a45de0-574b-11ec-96d5-7933aca11ca0', 14, '2021-12-07 18:50:04', '2021-12-07 18:50:04');
INSERT INTO `mt_special_part_section_blogs` VALUES ('71606020-3d8c-11ec-97a5-ef78eceb5d73', 'fadccf90-30bd-11ec-bd70-1746ca2eb62a', '3fbc4640-3d89-11ec-97a5-ef78eceb5d73', 2, '2021-11-05 00:29:54', '2021-11-05 00:29:54');
INSERT INTO `mt_special_part_section_blogs` VALUES ('78e5a820-5711-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '6ee9a830-5711-11ec-96d5-7933aca11ca0', 11, '2021-12-07 11:55:09', '2021-12-07 11:55:09');
INSERT INTO `mt_special_part_section_blogs` VALUES ('798aa740-5e4f-11ec-b395-6d1b1a7579ec', '8b5f9a50-569f-11ec-96d5-7933aca11ca0', '6e23f3c0-5e4f-11ec-b395-6d1b1a7579ec', 1, '2021-12-16 17:06:37', '2021-12-16 17:06:37');
INSERT INTO `mt_special_part_section_blogs` VALUES ('7a303d50-49db-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '6d0bd440-49db-11ec-96d5-7933aca11ca0', 7, '2021-11-20 16:25:53', '2021-11-20 16:25:53');
INSERT INTO `mt_special_part_section_blogs` VALUES ('7a369c00-55ba-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '70387930-55ba-11ec-96d5-7933aca11ca0', 7, '2021-12-05 18:59:54', '2021-12-05 18:59:54');
INSERT INTO `mt_special_part_section_blogs` VALUES ('7b20ddb0-3d8c-11ec-97a5-ef78eceb5d73', 'fadccf90-30bd-11ec-bd70-1746ca2eb62a', '3c9212f0-3d8a-11ec-97a5-ef78eceb5d73', 3, '2021-11-05 00:30:11', '2021-11-05 00:30:11');
INSERT INTO `mt_special_part_section_blogs` VALUES ('7b41a300-5cc3-11ec-96d5-7933aca11ca0', '04bf3a90-5c90-11ec-96d5-7933aca11ca0', '2631d1a0-5cc3-11ec-96d5-7933aca11ca0', 1, '2021-12-14 17:51:59', '2021-12-14 17:51:59');
INSERT INTO `mt_special_part_section_blogs` VALUES ('7fa3fb30-5d51-11ec-96d5-7933aca11ca0', '04bf3a90-5c90-11ec-96d5-7933aca11ca0', '7484ff10-5d51-11ec-96d5-7933aca11ca0', 3, '2021-12-15 10:48:35', '2021-12-15 10:48:35');
INSERT INTO `mt_special_part_section_blogs` VALUES ('831fd520-3d8c-11ec-97a5-ef78eceb5d73', 'fadccf90-30bd-11ec-bd70-1746ca2eb62a', '87a08d30-3d8a-11ec-97a5-ef78eceb5d73', 4, '2021-11-05 00:30:24', '2021-11-05 00:30:24');
INSERT INTO `mt_special_part_section_blogs` VALUES ('86d50a40-4b48-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '7af13780-4b48-11ec-96d5-7933aca11ca0', 9, '2021-11-22 11:59:01', '2021-11-22 11:59:01');
INSERT INTO `mt_special_part_section_blogs` VALUES ('88c39f10-5db8-11ec-b395-6d1b1a7579ec', '04bf3a90-5c90-11ec-96d5-7933aca11ca0', '7e0e3a30-5db8-11ec-b395-6d1b1a7579ec', 9, '2021-12-15 23:06:09', '2021-12-15 23:06:09');
INSERT INTO `mt_special_part_section_blogs` VALUES ('8b7bb9a0-3d8c-11ec-97a5-ef78eceb5d73', 'fadccf90-30bd-11ec-bd70-1746ca2eb62a', 'd12707e0-3d8a-11ec-97a5-ef78eceb5d73', 5, '2021-11-05 00:30:38', '2021-11-05 00:30:43');
INSERT INTO `mt_special_part_section_blogs` VALUES ('8e2089f0-5fb1-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '8370a350-5fb1-11ec-b395-6d1b1a7579ec', 12, '2021-12-18 11:21:13', '2021-12-18 11:21:13');
INSERT INTO `mt_special_part_section_blogs` VALUES ('915662d0-5c8b-11ec-96d5-7933aca11ca0', '1dc93d90-30be-11ec-bd70-1746ca2eb62a', '8399b160-5c8b-11ec-96d5-7933aca11ca0', 1, '2021-12-14 11:11:45', '2021-12-14 11:11:45');
INSERT INTO `mt_special_part_section_blogs` VALUES ('93fa79c0-5f49-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '8652d6f0-5f49-11ec-b395-6d1b1a7579ec', 9, '2021-12-17 22:56:56', '2021-12-17 22:56:56');
INSERT INTO `mt_special_part_section_blogs` VALUES ('942da820-51ea-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '556df770-51ea-11ec-96d5-7933aca11ca0', 17, '2021-11-30 22:34:09', '2021-11-30 22:34:09');
INSERT INTO `mt_special_part_section_blogs` VALUES ('95120a70-57d9-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '8b9cc6b0-57d9-11ec-96d5-7933aca11ca0', 15, '2021-12-08 11:47:36', '2021-12-08 11:47:36');
INSERT INTO `mt_special_part_section_blogs` VALUES ('9739e090-5f39-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '87ae3b80-5f39-11ec-b395-6d1b1a7579ec', 8, '2021-12-17 21:02:29', '2021-12-17 21:02:29');
INSERT INTO `mt_special_part_section_blogs` VALUES ('9830df70-54e0-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '52704660-54e0-11ec-96d5-7933aca11ca0', 1, '2021-12-04 17:00:14', '2021-12-04 17:00:14');
INSERT INTO `mt_special_part_section_blogs` VALUES ('9871c330-5bea-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '8bb3bd10-5bea-11ec-96d5-7933aca11ca0', 24, '2021-12-13 15:59:27', '2021-12-13 15:59:27');
INSERT INTO `mt_special_part_section_blogs` VALUES ('98956200-4e5b-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '561993b0-4e5b-11ec-96d5-7933aca11ca0', 11, '2021-11-26 09:53:05', '2021-11-26 09:53:05');
INSERT INTO `mt_special_part_section_blogs` VALUES ('9a37fd20-566c-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', '8f7d1a00-566c-11ec-96d5-7933aca11ca0', 9, '2021-12-06 16:14:58', '2021-12-06 16:14:58');
INSERT INTO `mt_special_part_section_blogs` VALUES ('9b418170-607e-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '919af480-607e-11ec-b395-6d1b1a7579ec', 16, '2021-12-19 11:49:02', '2021-12-19 11:49:02');
INSERT INTO `mt_special_part_section_blogs` VALUES ('9ff0ed80-4e5b-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', '87ecdb40-4e5b-11ec-96d5-7933aca11ca0', 12, '2021-11-26 09:53:17', '2021-11-26 09:53:17');
INSERT INTO `mt_special_part_section_blogs` VALUES ('a1e4f940-5d99-11ec-b395-6d1b1a7579ec', '04bf3a90-5c90-11ec-96d5-7933aca11ca0', '97ad9e00-5d99-11ec-b395-6d1b1a7579ec', 6, '2021-12-15 19:24:56', '2021-12-15 19:24:56');
INSERT INTO `mt_special_part_section_blogs` VALUES ('a64c4d10-5f30-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '98816ad0-5f30-11ec-b395-6d1b1a7579ec', 7, '2021-12-17 19:58:29', '2021-12-17 19:58:29');
INSERT INTO `mt_special_part_section_blogs` VALUES ('ad9cb4e0-60b8-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', 'a3d1b000-60b8-11ec-b395-6d1b1a7579ec', 18, '2021-12-19 18:44:44', '2021-12-19 18:44:44');
INSERT INTO `mt_special_part_section_blogs` VALUES ('b454f060-58f5-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'a8f45760-58f5-11ec-96d5-7933aca11ca0', 22, '2021-12-09 21:41:25', '2021-12-09 21:41:25');
INSERT INTO `mt_special_part_section_blogs` VALUES ('b497ddc0-557c-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', 'a75b0ab0-557c-11ec-96d5-7933aca11ca0', 4, '2021-12-05 11:37:43', '2021-12-05 11:37:43');
INSERT INTO `mt_special_part_section_blogs` VALUES ('b4cad500-5355-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'aa11c6a0-5355-11ec-96d5-7933aca11ca0', 19, '2021-12-02 17:53:31', '2021-12-02 17:53:31');
INSERT INTO `mt_special_part_section_blogs` VALUES ('b85bc320-3d8c-11ec-97a5-ef78eceb5d73', 'fadccf90-30bd-11ec-bd70-1746ca2eb62a', '1d47dc80-3d8b-11ec-97a5-ef78eceb5d73', 6, '2021-11-05 00:31:53', '2021-11-05 00:31:53');
INSERT INTO `mt_special_part_section_blogs` VALUES ('bae04200-5cc3-11ec-96d5-7933aca11ca0', '04bf3a90-5c90-11ec-96d5-7933aca11ca0', 'ac3475a0-5cc3-11ec-96d5-7933aca11ca0', 2, '2021-12-14 17:53:46', '2021-12-14 17:53:46');
INSERT INTO `mt_special_part_section_blogs` VALUES ('bb31b530-55a3-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', 'ae29d4d0-55a3-11ec-96d5-7933aca11ca0', 5, '2021-12-05 16:17:05', '2021-12-05 16:17:05');
INSERT INTO `mt_special_part_section_blogs` VALUES ('bb855260-4f1f-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'aa9450f0-4f1f-11ec-96d5-7933aca11ca0', 13, '2021-11-27 09:17:05', '2021-11-27 09:17:05');
INSERT INTO `mt_special_part_section_blogs` VALUES ('bba05c70-5d6d-11ec-96d5-7933aca11ca0', '04bf3a90-5c90-11ec-96d5-7933aca11ca0', 'b1cd1a30-5d6d-11ec-96d5-7933aca11ca0', 5, '2021-12-15 14:10:42', '2021-12-15 14:10:42');
INSERT INTO `mt_special_part_section_blogs` VALUES ('bd4dfd70-6083-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', 'b3c57fd0-6083-11ec-b395-6d1b1a7579ec', 17, '2021-12-19 12:25:47', '2021-12-19 12:25:47');
INSERT INTO `mt_special_part_section_blogs` VALUES ('be8e56d0-589a-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '52704660-54e0-11ec-96d5-7933aca11ca0', 1, '2021-12-09 10:50:18', '2021-12-09 10:50:18');
INSERT INTO `mt_special_part_section_blogs` VALUES ('c29dccc0-3d8c-11ec-97a5-ef78eceb5d73', 'fadccf90-30bd-11ec-bd70-1746ca2eb62a', '6f8f8d30-3d8b-11ec-97a5-ef78eceb5d73', 7, '2021-11-05 00:32:11', '2021-11-05 00:32:11');
INSERT INTO `mt_special_part_section_blogs` VALUES ('c2f34340-5e5b-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '87ae8880-5e5b-11ec-b395-6d1b1a7579ec', 1, '2021-12-16 18:34:34', '2021-12-16 18:34:34');
INSERT INTO `mt_special_part_section_blogs` VALUES ('c466c4c0-589a-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '46990ae0-54ed-11ec-96d5-7933aca11ca0', 2, '2021-12-09 10:50:28', '2021-12-09 10:50:28');
INSERT INTO `mt_special_part_section_blogs` VALUES ('c6cc96f0-5254-11ec-96d5-7933aca11ca0', '4b2fb200-410d-11ec-94eb-3706a2e7018e', '56340d60-3b7f-11ec-8015-f554da021b2a', 5, '2021-12-01 11:14:20', '2021-12-01 11:14:57');
INSERT INTO `mt_special_part_section_blogs` VALUES ('c8658df0-55ab-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', 'baf99490-55ab-11ec-96d5-7933aca11ca0', 6, '2021-12-05 17:14:43', '2021-12-05 17:14:43');
INSERT INTO `mt_special_part_section_blogs` VALUES ('c943f450-3891-11ec-8015-f554da021b2a', 'eedd1060-30bd-11ec-bd70-1746ca2eb62a', '7e76a540-3250-11ec-a1da-59f2d55bf031', 0, '2021-10-29 16:25:33', '2021-10-29 16:25:33');
INSERT INTO `mt_special_part_section_blogs` VALUES ('cb6eb710-5c81-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'c0bfbad0-5c81-11ec-96d5-7933aca11ca0', 25, '2021-12-14 10:01:47', '2021-12-14 10:01:47');
INSERT INTO `mt_special_part_section_blogs` VALUES ('d0a30240-3891-11ec-8015-f554da021b2a', 'f58ccb80-30bd-11ec-bd70-1746ca2eb62a', '28792100-359c-11ec-94ec-9def32579e94', 0, '2021-10-29 16:25:46', '2021-10-29 16:25:46');
INSERT INTO `mt_special_part_section_blogs` VALUES ('d11590d0-3d8c-11ec-97a5-ef78eceb5d73', 'fadccf90-30bd-11ec-bd70-1746ca2eb62a', 'b384b510-3d8b-11ec-97a5-ef78eceb5d73', 8, '2021-11-05 00:32:35', '2021-11-05 00:32:35');
INSERT INTO `mt_special_part_section_blogs` VALUES ('d21aeab0-589a-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '276f1d80-5579-11ec-96d5-7933aca11ca0', 3, '2021-12-09 10:50:51', '2021-12-09 10:50:51');
INSERT INTO `mt_special_part_section_blogs` VALUES ('d3cb1d40-3891-11ec-8015-f554da021b2a', 'f58ccb80-30bd-11ec-bd70-1746ca2eb62a', '53c38cb0-34a7-11ec-a1da-59f2d55bf031', 0, '2021-10-29 16:25:51', '2021-10-29 16:25:51');
INSERT INTO `mt_special_part_section_blogs` VALUES ('d6e862d0-3891-11ec-8015-f554da021b2a', 'f58ccb80-30bd-11ec-bd70-1746ca2eb62a', '8bafda00-346d-11ec-a1da-59f2d55bf031', 0, '2021-10-29 16:25:56', '2021-10-29 16:25:56');
INSERT INTO `mt_special_part_section_blogs` VALUES ('d7fcfdc0-3d8c-11ec-97a5-ef78eceb5d73', 'fadccf90-30bd-11ec-bd70-1746ca2eb62a', '0a797310-3d8c-11ec-97a5-ef78eceb5d73', 9, '2021-11-05 00:32:47', '2021-11-05 00:32:47');
INSERT INTO `mt_special_part_section_blogs` VALUES ('da779fd0-606c-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', 'd036a7a0-606c-11ec-b395-6d1b1a7579ec', 15, '2021-12-19 09:41:57', '2021-12-19 09:41:57');
INSERT INTO `mt_special_part_section_blogs` VALUES ('da9b63f0-5254-11ec-96d5-7933aca11ca0', '4b2fb200-410d-11ec-94eb-3706a2e7018e', '7fa91c70-3a40-11ec-8015-f554da021b2a', 4, '2021-12-01 11:14:53', '2021-12-01 11:14:53');
INSERT INTO `mt_special_part_section_blogs` VALUES ('dabdc340-589a-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', 'a75b0ab0-557c-11ec-96d5-7933aca11ca0', 4, '2021-12-09 10:51:05', '2021-12-09 10:51:05');
INSERT INTO `mt_special_part_section_blogs` VALUES ('dac01ec0-3891-11ec-8015-f554da021b2a', 'f58ccb80-30bd-11ec-bd70-1746ca2eb62a', 'b51d3e10-3214-11ec-bd70-1746ca2eb62a', 0, '2021-10-29 16:26:03', '2021-10-29 16:26:03');
INSERT INTO `mt_special_part_section_blogs` VALUES ('db475e90-573a-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', 'd210f890-573a-11ec-96d5-7933aca11ca0', 12, '2021-12-07 16:51:24', '2021-12-07 16:52:04');
INSERT INTO `mt_special_part_section_blogs` VALUES ('dc45c580-5018-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'c69fa070-5018-11ec-96d5-7933aca11ca0', 14, '2021-11-28 15:00:24', '2021-11-28 15:00:24');
INSERT INTO `mt_special_part_section_blogs` VALUES ('de4c92a0-4ae1-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'cb7285e0-4ae1-11ec-96d5-7933aca11ca0', 8, '2021-11-21 23:44:09', '2021-11-21 23:44:09');
INSERT INTO `mt_special_part_section_blogs` VALUES ('dee90790-5f57-11ec-b395-6d1b1a7579ec', 'b38efc50-5e5b-11ec-b395-6d1b1a7579ec', 'd4435a20-5f57-11ec-b395-6d1b1a7579ec', 11, '2021-12-18 00:39:14', '2021-12-18 00:39:14');
INSERT INTO `mt_special_part_section_blogs` VALUES ('dffe3a80-5677-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', 'd427ae30-5677-11ec-96d5-7933aca11ca0', 10, '2021-12-06 17:35:40', '2021-12-06 17:35:40');
INSERT INTO `mt_special_part_section_blogs` VALUES ('e0fa7140-589a-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', 'ae29d4d0-55a3-11ec-96d5-7933aca11ca0', 5, '2021-12-09 10:51:16', '2021-12-09 10:51:16');
INSERT INTO `mt_special_part_section_blogs` VALUES ('e1f8e030-5d55-11ec-96d5-7933aca11ca0', '04bf3a90-5c90-11ec-96d5-7933aca11ca0', 'd40c4520-5d55-11ec-96d5-7933aca11ca0', 4, '2021-12-15 11:19:58', '2021-12-15 11:19:58');
INSERT INTO `mt_special_part_section_blogs` VALUES ('e56d4640-3891-11ec-8015-f554da021b2a', '3029ad80-30be-11ec-bd70-1746ca2eb62a', 'b94be010-2d94-11ec-ba0f-810bb435395b', 0, '2021-10-29 16:26:21', '2021-10-29 16:26:21');
INSERT INTO `mt_special_part_section_blogs` VALUES ('e56d48f0-5e72-11ec-b395-6d1b1a7579ec', '8b5f9a50-569f-11ec-96d5-7933aca11ca0', 'dc2dbb30-5e72-11ec-b395-6d1b1a7579ec', 2, '2021-12-16 21:20:11', '2021-12-16 21:20:11');
INSERT INTO `mt_special_part_section_blogs` VALUES ('e5d5ac70-48e1-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'd44e8580-48e1-11ec-96d5-7933aca11ca0', 6, '2021-11-19 10:39:20', '2021-11-19 10:39:24');
INSERT INTO `mt_special_part_section_blogs` VALUES ('e5d8a0b0-589a-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', 'baf99490-55ab-11ec-96d5-7933aca11ca0', 6, '2021-12-09 10:51:24', '2021-12-09 10:51:24');
INSERT INTO `mt_special_part_section_blogs` VALUES ('e98738b0-5648-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', 'd94ae140-5648-11ec-96d5-7933aca11ca0', 8, '2021-12-06 11:59:29', '2021-12-06 11:59:29');
INSERT INTO `mt_special_part_section_blogs` VALUES ('ead813c0-589a-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '70387930-55ba-11ec-96d5-7933aca11ca0', 7, '2021-12-09 10:51:32', '2021-12-09 10:51:32');
INSERT INTO `mt_special_part_section_blogs` VALUES ('ec7100b0-50ee-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'b86f6770-50ee-11ec-96d5-7933aca11ca0', 15, '2021-11-29 16:32:44', '2021-11-29 16:32:44');
INSERT INTO `mt_special_part_section_blogs` VALUES ('efd256b0-589a-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', 'd94ae140-5648-11ec-96d5-7933aca11ca0', 8, '2021-12-09 10:51:41', '2021-12-09 10:51:41');
INSERT INTO `mt_special_part_section_blogs` VALUES ('f5410650-589a-11ec-96d5-7933aca11ca0', 'a3747910-589a-11ec-96d5-7933aca11ca0', '8f7d1a00-566c-11ec-96d5-7933aca11ca0', 9, '2021-12-09 10:51:50', '2021-12-09 10:51:50');
INSERT INTO `mt_special_part_section_blogs` VALUES ('f626fdc0-5f22-11ec-b395-6d1b1a7579ec', '8b5f9a50-569f-11ec-96d5-7933aca11ca0', 'ec46c330-5f22-11ec-b395-6d1b1a7579ec', 4, '2021-12-17 18:20:30', '2021-12-17 18:20:30');
INSERT INTO `mt_special_part_section_blogs` VALUES ('f9aa0ef0-5109-11ec-96d5-7933aca11ca0', '19578b90-30be-11ec-bd70-1746ca2eb62a', 'e6f5d9b0-5109-11ec-96d5-7933aca11ca0', 16, '2021-11-29 19:46:22', '2021-11-29 19:46:22');
INSERT INTO `mt_special_part_section_blogs` VALUES ('ff601be0-581c-11ec-96d5-7933aca11ca0', '8d4ad500-54dd-11ec-96d5-7933aca11ca0', 'ef3306b0-581c-11ec-96d5-7933aca11ca0', 16, '2021-12-08 19:50:10', '2021-12-08 19:50:10');

-- ----------------------------
-- Table structure for t_admin_role
-- ----------------------------
DROP TABLE IF EXISTS `t_admin_role`;
CREATE TABLE `t_admin_role`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `role_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '角色名：管理员等等',
  `role_intro` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '角色简介：该角色的职责简介',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '管理员角色：存放角色信息' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_admin_role
-- ----------------------------

-- ----------------------------
-- Table structure for t_admin_user
-- ----------------------------
DROP TABLE IF EXISTS `t_admin_user`;
CREATE TABLE `t_admin_user`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `user_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '管理员登录账号：一串字符串',
  `user_password` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '管理员登录密码：后台加密后保存',
  `user_profile` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '头像：存放用户头像地址',
  `nick_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '昵称：用户昵称',
  `user_intro` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '管理员简介：',
  `user_profession` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '职业：',
  `user_email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '管理员邮箱：',
  `role_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '属于哪类角色：存放的是角色的uid',
  `gender` int(11) NULL DEFAULT 1 COMMENT '性别：1，男；2，女',
  `login_ip_address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '登录IP：用户最近一次登录的ip地址',
  `last_login_time` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '最后登录时间：用户最后一次登录的时间',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '后台管理员用户：存放可以登录后台的管理员账号信息' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_admin_user
-- ----------------------------
INSERT INTO `t_admin_user` VALUES ('-1', 'admin', '$2a$10$jBGoLIzTVOYaCde2esCXxeTL418dSEE/pPBIlIyilJug1dSNg4gvm', 'http://82.156.76.49:20517/upload/jpg/2021-10-14/dba243f0-2cb5-11ec-8de6-87c3175356c3.jpg', '小陈', '一只小前端', '前端开发', 'bnbiye@163.com', '', 1, '', '', -1, '2021-08-27 08:43:40', '2021-10-14 14:14:27');
INSERT INTO `t_admin_user` VALUES ('31c17ed0-30ae-11ec-bd70-1746ca2eb62a', 'cheny', '$2a$10$OV3EWiBsBBvztvpN5L8MA.8cttE1c7Mse6m8m2ZuGaF6KJpV/rJfe', 'http://82.156.76.49:20517/upload/jpg/2021-10-25/90c26490-3599-11ec-a1da-59f2d55bf031.jpg', '11', '11', '111', '11', '', 1, '', '', 0, '2021-10-19 15:28:45', '2021-10-25 21:43:43');

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog`  (
  `uid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客的唯一id',
  `blog_title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '博客的标题',
  `blog_summary` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '博客的概述',
  `blog_author_id` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '博客作者的id',
  `is_original` int(11) NOT NULL DEFAULT 1 COMMENT '是否是原创：1 原创；2转载；3 翻译；',
  `origin_address` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT '' COMMENT '文章来源地址：当为转载或者翻译的文章时，填写的文章来源，如果为原创，该字段为空字符串',
  `blog_sort_id` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '博客分类的id',
  `recommend_level` int(11) NOT NULL DEFAULT -1 COMMENT '推荐等级：1 一级推荐；2 二级推荐；3 三级推荐；4 四级推荐；-1 不推荐',
  `clicks` int(11) NULL DEFAULT 0 COMMENT '博客点击量',
  `order_num` int(11) NOT NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `is_open_comment` int(11) NOT NULL DEFAULT 1 COMMENT '是否开启评论：1 开启；2 关闭',
  `is_private` int(11) NOT NULL DEFAULT 2 COMMENT '是否为私密文章：1 是；2 否',
  `blog_status` int(11) NOT NULL DEFAULT 2 COMMENT '博客的状态：1 发布；2 下架；3 草稿；',
  `cover_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客封面的url',
  `blog_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '博客内容，存的是html',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客创建时间',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客修改时间',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin COMMENT = '博客详情表：\r\n    存储博客的相关信息，如标题、作者、推荐等级、内容、摘要等' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES ('02832040-583d-11ec-96d5-7933aca11ca0', '正则表达式（RegExp）和字符串（String）的方法', '在本文中，我们将深入探讨与正则表达式配合使用的各种方法。', '-1', 2, 'https://zh.javascript.info/regexp-methods', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 10, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>在本文中，我们将深入探讨与正则表达式配合使用的各种方法。</p>\n<h2>str.match(regexp)</h2>\n<p><code>str.match(regexp)</code> 方法在字符串 <code>str</code> 中找到匹配 <code>regexp</code> 的字符。</p>\n<p>它有 3 种模式：</p>\n<ol>\n<li>\n<p>如果 <code>regexp</code> 不带有 <code>g</code> 标记，则它以数组的形式返回第一个匹配项，其中包含分组和属性 <code>index</code>（匹配项的位置）、<code>input</code>（输入字符串，等于 <code>str</code>）：</p>\n<pre><code class=\"language-js\">let str = &quot;I love JavaScript&quot;;\n\nlet result = str.match(/Java(Script)/);\n\nconsole.log(result);\n/* \n[\n  \'JavaScript\',\n  \'Script\',\n  index: 7,\n  input: \'I love JavaScript\',\n  groups: undefined\n]\n*/\n\nconsole.log(result[0]);     // JavaScript（完全匹配）\nconsole.log(result[1]);     // Script（第一个分组）\nconsole.log(result.length); // 2\n\n// 其他信息：\nconsole.log(result.index);  // 7（匹配位置）\nconsole.log(result.input);  // I love JavaScript（源字符串）\n</code></pre>\n</li>\n<li>\n<p>如果 <code>regexp</code> 带有 <code>g</code> 标记，则它将所有匹配项的数组作为字符串返回，而不包含分组和其他详细信息。</p>\n<pre><code class=\"language-js\">let str = &quot;I love JavaScript&quot;;\n\nlet result = str.match(/Java(Script)/g);\n\nconsole.log(result); // [ \'JavaScript\' ]\n\nconsole.log(result[0]); // JavaScript\nconsole.log(result.length); // 1\n</code></pre>\n</li>\n<li>\n<p>如果没有匹配项，则无论是否带有标记 <code>g</code> ，都将返回 <code>null</code>。</p>\n<p>这是一个重要的细微差别。如果没有匹配项，我们得到的不是一个空数组，而是 <code>null</code>。忘记这一点很容易出错，例如：</p>\n<pre><code class=\"language-js\">let str = &quot;I love JavaScript&quot;;\n\nlet result = str.match(/HTML/);\nconsole.log(result); // null\n// console.log(result.length); // TypeError: Cannot read property \'length\' of null\n</code></pre>\n<p>如果我们希望结果是一个数组，我们可以这样写：</p>\n<pre><code class=\"language-js\">let result = str.match(regexp) || [];\n</code></pre>\n</li>\n</ol>\n<h2>str.matchAll()</h2>\n<blockquote>\n<p><strong>A recent addition</strong></p>\n<p>This is a recent addition to the language. Old browsers may need polyfills.</p>\n</blockquote>\n<p>方法 <code>str.matchAll(regexp)</code> 是 <code>str.match</code> “新改进的”变体。</p>\n<p>它主要用来搜索所有组的所有匹配项。</p>\n<p>与 <code>match</code> 相比有 3 个区别：</p>\n<ol>\n<li>它返回包含匹配项的可迭代对象，而不是数组。我们可以用 <code>Array.from</code> 从中得到一个常规数组。</li>\n<li>每个匹配项均以包含分组的数组形式返回（返回格式与不带 <code>g</code> 标记的 <code>str.match</code> 相同）。</li>\n<li>如果没有结果，则返回的不是 <code>null</code>，而是一个空的可迭代对象。</li>\n</ol>\n<pre><code class=\"language-js\">let str = \'&lt;h1&gt;Hello, world!&lt;/h1&gt;\';\nlet regexp = /&lt;(.*?)&gt;/g; // *? 开启懒惰模式\n\nlet matchAll = str.matchAll(regexp);\n\nconsole.log(matchAll); // [object RegExp String Iterator]，不是数组，而是一个可迭代对象\n\nlet matchAll2 = Array.from(matchAll); // 现在返回的是数组\n\nconsole.log(matchAll2);\n/* \n[\n  [\n    \'&lt;h1&gt;\',\n    \'h1\',\n    index: 0,\n    input: \'&lt;h1&gt;Hello, world!&lt;/h1&gt;\',\n    groups: undefined\n  ],\n  [\n    \'&lt;/h1&gt;\',\n    \'/h1\',\n    index: 17,\n    input: \'&lt;h1&gt;Hello, world!&lt;/h1&gt;\',\n    groups: undefined\n  ]\n]\n*/\n</code></pre>\n<p>如果我们用 <code>for..of</code> 来循环 <code>matchAll</code> 的匹配项，那么我们就不需要 <code>Array.from</code> 了。</p>\n<h2>str.split(regexp|substr, limit)</h2>\n<p>使用正则表达式（或子字符串）作为分隔符来分割字符串。</p>\n<p>我们可以用 <code>split</code> 来分割字符串，如下所示：</p>\n<pre><code class=\"language-js\">console.log(\'12-34-56\'.split(\'-\')) // 数组 [\'12\', \'34\', \'56\']\nconsole.log(\'12-34-56\'.split(\'-\', 0)) // 数组 []\nconsole.log(\'12-34-56\'.split(\'-\', 1)) // 数组 [ \'12\' ]\nconsole.log(\'12-34-56\'.split(\'-\', 2)) // 数组 [ \'12\', \'34\' ]\nconsole.log(\'12-34-56\'.split(\'-\', 3)) // 数组 [ \'12\', \'34\', \'56\' ]\n</code></pre>\n<p>但同样，我们也可以用正则表达式来做：</p>\n<pre><code class=\"language-js\">console.log(\'12, 34, 56,78\'.split(/,\\s*/)) // 数组 [ \'12\', \'34\', \'56\', \'78\' ]\n</code></pre>\n<h2>str.search(regexp)</h2>\n<p>方法 <code>str.search(regexp)</code> 返回第一个匹配项的位置，如果未找到，则返回 <code>-1</code>：</p>\n<pre><code class=\"language-js\">let str = &quot;A drop of ink may make a million think&quot;;\n\nconsole.log(str.search(/ink/i)); // 10（第一个匹配位置）\nconsole.log(str.search(/aaa/i)); // -1（没有返回-1）\n</code></pre>\n<p><strong>重要限制：<code>search</code> 仅查找第一个匹配项。</strong></p>\n<p>如果需要其他匹配项的位置，则应使用其他方法，例如用 <code>str.matchAll(regexp)</code> 查找所有位置。</p>\n<h2>str.replace(str|regexp, str|func)</h2>\n<p>这是用于搜索和替换的通用方法，是最有用的方法之一。它是搜索和替换字符串的瑞士军刀。</p>\n<p>我们可以不用正则表达式来搜索和替换子字符串：</p>\n<pre><code class=\"language-js\">// 用冒号替换连字符\nconsole.log(\'12-34-56\'.replace(&quot;-&quot;, &quot;:&quot;)) // 12:34-56\n</code></pre>\n<p>不过有一个陷阱。</p>\n<p><strong>当 <code>replace</code> 的第一个参数是字符串时，它仅替换第一个匹配项。</strong></p>\n<p>您可以在上面的示例中看到：只有第一个 <code>&quot;-&quot;</code> 被 <code>&quot;:&quot;</code> 替换了。</p>\n<p>如要找到所有的连字符，我们不应该用字符串 <code>&quot;-&quot;</code>，而应使用带 <code>g</code> 标记的正则表达式 <code>/-/g</code>：</p>\n<pre><code class=\"language-js\">// 将连字符替换为冒号\nconsole.log(\'12-34-56\'.replace(/-/g, &quot;:&quot;))  // 12:34:56\n</code></pre>\n<p>第二个参数是一个替代字符串。我们可以在其中使用特殊字符：</p>\n<table>\n<thead>\n<tr>\n<th>符号</th>\n<th>替换字符串中的操作</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>$$</code></td>\n<td>插入一个 &quot;$&quot;。</td>\n</tr>\n<tr>\n<td><code>$&amp;</code></td>\n<td>插入匹配的子串。</td>\n</tr>\n<tr>\n<td>$`</td>\n<td>插入当前匹配的子串左边的内容。</td>\n</tr>\n<tr>\n<td>$\'</td>\n<td>插入当前匹配的子串右边的内容。</td>\n</tr>\n<tr>\n<td>$n</td>\n<td>如果 <code>n</code> 是一个 1 到 2 位的数字，则插入第 n 个分组的内容，详见 <a href=\"http://www.bnbiye.cn/#/articleDetail/6ee9a830-5711-11ec-96d5-7933aca11ca0\">捕获组</a></td>\n</tr>\n<tr>\n<td><code>$</code></td>\n<td>插入带有给定 <code>name</code> 的括号内的内容，详见 <a href=\"http://www.bnbiye.cn/#/articleDetail/6ee9a830-5711-11ec-96d5-7933aca11ca0\">捕获组</a></td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li>\n<p>替换字符串</p>\n<pre><code class=\"language-js\">let str = \'aa bb cc aa\'\nlet reg = /aa/g\nlet newStr = str.replace(reg, \'hh\')\nconsole.log(newStr) // hh bb cc hh\n</code></pre>\n</li>\n<li>\n<p><code>$$</code></p>\n<pre><code class=\"language-js\">let str = \'aa bb cc aa\'\nlet reg = /aa/g\nlet newStr = str.replace(reg, \'$$\')\nconsole.log(newStr) // $ bb cc $\n</code></pre>\n</li>\n<li>\n<p><code>$&amp;</code></p>\n<pre><code class=\"language-js\">let str = \'aa bb cc aa\'\nlet reg = /aa/g\nlet newStr = str.replace(reg, \'&lt;&lt;$&amp;&gt;&gt;\')\nconsole.log(newStr) // &lt;&lt;aa&gt;&gt; bb cc &lt;&lt;aa&gt;&gt;\n</code></pre>\n</li>\n<li>\n<p>$`</p>\n<pre><code class=\"language-js\">let str = \'123aa bb cc 456aa\'\nlet reg = /aa/g\nlet newStr = str.replace(reg, \'$`\')\nconsole.log(newStr) // 123123 bb cc 456123aa bb cc 456\n</code></pre>\n</li>\n<li>\n<p>$\'</p>\n<pre><code class=\"language-js\">let str = \'aabbcc aa123\'\nlet reg = /aa/g\nlet newStr = str.replace(reg, &quot;$\'&quot;)\nconsole.log(newStr) // bbcc aa123bbcc 123123\n</code></pre>\n</li>\n<li>\n<p>$n</p>\n<pre><code class=\"language-js\">let str = \'aa bb\'\nlet reg = /(aa)\\s(bb)/g\nlet newStr = str.replace(reg, \'$2_$1\')\nconsole.log(newStr) // bb_aa\n</code></pre>\n</li>\n<li>\n<p><code>$&lt;name&gt;</code></p>\n<pre><code class=\"language-js\">let str = \'aa bb\'\nlet reg = /(?&lt;first&gt;aa)\\s(?&lt;second&gt;bb)/g\nlet newStr = str.replace(reg, \'$&lt;second&gt;_$&lt;first&gt;\')\nconsole.log(newStr) // bb_aa\n</code></pre>\n</li>\n</ol>\n<p><strong>对于需要“智能”替换的场景，第二个参数可以是一个函数。</strong></p>\n<p>每次匹配都会调用这个函数，并且返回的值将作为替换字符串插入。</p>\n<p>该函数 <code>func(match, p1, p2, ..., pn, offset, input, groups)</code> 带参数调用：</p>\n<ol>\n<li><code>match</code> － 匹配项，</li>\n<li><code>p1, p2, ..., pn</code> － 分组的内容（如有），</li>\n<li><code>offset</code> － 匹配项的位置，</li>\n<li><code>input</code> － 源字符串，</li>\n<li><code>groups</code> － 所指定分组的对象。</li>\n</ol>\n<p>如果正则表达式中没有捕获组，则只有 3 个参数：<code>func(str, offset, input)</code>。</p>\n<p>例如，将所有匹配项都大写：</p>\n<pre><code class=\"language-js\">let str = &quot;html and css&quot;;\n\nlet result = str.replace(/html|css/gi, str =&gt; str.toUpperCase());\n\nconsole.log(result); // HTML and CSS\n</code></pre>\n<p>按其在字符串中的位置来替换每个匹配项：</p>\n<pre><code class=\"language-js\">console.log(&quot;Ho-Ho-ho&quot;.replace(/ho/gi, (match, offset) =&gt; offset)); // 0-3-6\n</code></pre>\n<p>在下面的示例中，有两对括号，因此将使用 5 个参数调用替换函数：第一个是完全匹配项，然后是 2 对括号，然后是匹配位置（在示例中未使用）和源字符串：</p>\n<pre><code class=\"language-js\">let str = &quot;John Smith&quot;;\n\nlet result = str.replace(/(\\w+) (\\w+)/, (match, name, surname) =&gt; `${surname}, ${name}`);\n\nconsole.log(result); // Smith, John\n</code></pre>\n<p>如果有许多组，用 rest 参数（…）可以很方便的访问：</p>\n<pre><code class=\"language-js\">let str = &quot;John Smith&quot;;\n\nlet result = str.replace(/(\\w+) (\\w+)/, (...match) =&gt; `${match[2]}, ${match[1]}`);\n\nconsole.log(result); // Smith, John\n</code></pre>\n<pre><code class=\"language-js\">let str = &quot;John Smith&quot;;\n\nlet result = str.replace(/(?&lt;firstname&gt;\\w+) (?&lt;lastname&gt;\\w+)/, (match, $1, $2, index, input, groups) =&gt; {\n    console.log(match); // John Smith\n    console.log($1); // John\n    console.log($2); // Smith\n    console.log(index); // 0\n    console.log(input); // John Smith\n    console.log(groups); // [Object: null prototype] { firstname: \'John\', lastname: \'Smith\' }\n    return `aaa`\n});\n\nconsole.log(result); // aaa\n</code></pre>\n<p>或者，如果我们使用的是命名组，则带有它们的 <code>groups</code> 对象始终是最后一个对象，因此我们可以这样获得它：</p>\n<pre><code class=\"language-js\">let str = &quot;John Smith&quot;;\n\nlet result = str.replace(/(?&lt;name&gt;\\w+) (?&lt;surname&gt;\\w+)/, (...match) =&gt; {\n    let groups = match.pop();\n\n    return `${groups.surname}, ${groups.name}`;\n});\n\nconsole.log(result); // Smith, John\n</code></pre>\n<p>使用函数可以为我们提供终极替代功能，因为它可以获取匹配项的所有信息，可以访问外部变量，可以做任何事。</p>\n<h2>regexp.exec()</h2>\n<p><code>regexp.exec(str)</code> 方法返回字符串 <code>str</code> 中的 <code>regexp</code> 匹配项。与以前的方法不同，它是在正则表达式而不是字符串上调用的。</p>\n<p>根据正则表达式是否带有标志 <code>g</code>，它的行为有所不同。</p>\n<p>如果没有 <code>g</code>，那么 <code>regexp.exec(str)</code> 返回的第一个匹配与 <code>str.match(regexp)</code> 完全相同。这没什么新的变化。</p>\n<p>但是，如果有标记 <code>g</code>，那么：</p>\n<ul>\n<li>调用 <code>regexp.exec(str)</code> 会返回第一个匹配项，并将紧随其后的位置保存在属性 <code>regexp.lastIndex</code> 中。</li>\n<li>下一次同样的调用会从位置 <code>regexp.lastIndex</code> 开始搜索，返回下一个匹配项，并将其后的位置保存在 <code>regexp.lastIndex</code> 中。</li>\n<li>…以此类推。</li>\n<li>如果没有匹配项，则 <code>regexp.exec</code> 返回 <code>null</code>，并将 <code>regexp.lastIndex</code> 重置为 <code>0</code>。</li>\n</ul>\n<p>因此，重复调用会挨个返回所有的匹配项，属性 <code>regexp.lastIndex</code> 用来跟踪当前的搜索位置。</p>\n<p>过去，在将 <code>str.matchAll</code> 方法添加到 <code>JavaScript</code> 之前，在循环中是通过调用 <code>regexp.exec</code> 来获取分组的所有匹配项：</p>\n<pre><code class=\"language-js\">let str = \'More about JavaScript at https://javascript.info\';\nlet regexp = /javascript/ig;\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n    console.log(`Found ${result[0]} at position ${result.index}`);\n    // Found JavaScript at position 11，然后\n    // Found javascript at position 33\n}\n</code></pre>\n<p>这个现在也可以使用，尽管对于较新的浏览器来说，<code>str.matchAll</code> 通常更方便。</p>\n<p><strong>我们可以通过手动设置 <code>lastIndex</code>，用 <code>regexp.exec</code> 从给定位置进行搜索。</strong></p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let str = \'Hello, world!\';\n\nlet regexp = /\\w+/g; // 带有标记 &quot;g&quot;，lastIndex 属性被忽略\nregexp.lastIndex = 5; // 从第 5 个位置搜索（从逗号开始）\n\nconsole.log(regexp.exec(str)); // world\n</code></pre>\n<p>如果正则表达式带有标记 <code>y</code>，则搜索将精确地在 <code>regexp.lastIndex</code> 位置执行，不会再继续了。</p>\n<p>让我们将上例中的 <code>g</code> 标记替换为 <code>y</code>。现在没有找到匹配项了，因为在位置 <code>5</code> 处没有单词：</p>\n<pre><code class=\"language-js\">let str = \'Hello, world!\';\n\nlet regexp = /\\w+/y;\nregexp.lastIndex = 5; // 在位置 5 精确查找，是一个逗号, 并不能匹配到\\w+ 所以返回null\n\nconsole.log(regexp.exec(str)); // null\n</code></pre>\n<p>这个方法在某些场景下很方便，例如需要用正则表达式从字符串的精确位置来“读取”字符串（而不是其后的某处）。</p>\n<h2>regexp.test()</h2>\n<p>方法 <code>regexp.test(str)</code> 查找匹配项，然后返回 <code>true/false</code> 表示是否存在。</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let str = &quot;I love JavaScript&quot;;\n\n// 这两个测试相同\nconsole.log(/love/i.test(str)); // true\nconsole.log(str.search(/love/i) !== -1); // true\n</code></pre>\n<p>一个反例：</p>\n<pre><code class=\"language-js\">let str = &quot;Bla-bla-bla&quot;;\n\nconsole.log(/love/i.test(str)); // false\nconsole.log(str.search(/love/i) !== -1); // false\n</code></pre>\n<p>如果正则表达式带有标记 <code>g</code>，则 <code>regexp.test</code> 从 <code>regexp.lastIndex</code> 属性中查找，并更新此属性，就像 <code>regexp.exec</code> 一样。</p>\n<p>因此，我们可以用它从给定位置进行搜索：</p>\n<pre><code class=\"language-js\">let regexp = /love/gi;\n\nlet str = &quot;I love JavaScript&quot;;\n\n// 从位置 10 开始：\nregexp.lastIndex = 10;\nconsole.log(regexp.test(str)); // false（无匹配）\n</code></pre>\n<blockquote>\n<p><strong>相同的全局正则表达式在不同的源字符串上测试可能会失败</strong></p>\n<p>如果我们在不同的源字符串上应用相同的全局表达式，可能会出现错误的结果，因为 <code>regexp.test</code> 的调用会增加 <code>regexp.lastIndex</code> 属性值，因此在另一个字符串中的搜索可能是从非 0 位置开始的。</p>\n<p>例如，这里我们在同一文本上调用 <code>regexp.test</code> 两次，而第二次调用失败了：</p>\n<pre><code class=\"language-js\">let regexp = /javascript/g;  // （新建 regexp：regexp.lastIndex=0)\n\nconsole.log(regexp.test(&quot;javascript&quot;)); // true（现在 regexp.lastIndex=10）\nconsole.log(regexp.lastIndex); // 10\nconsole.log(regexp.test(&quot;javascript&quot;)); // false\n</code></pre>\n<p>这正是因为在第二个测试中 <code>regexp.lastIndex</code> 不为零。</p>\n<p>如要解决这个问题，我们可以在每次搜索之前设置 <code>regexp.lastIndex = 0</code>。或者，不调用正则表达式的方法，而是使用字符串方法 <code>str.match/search/...</code>，这些方法不用 <code>lastIndex</code>。</p>\n</blockquote>\n<h2>总结</h2>\n<ol>\n<li>\n<p>str.match(regexp)：</p>\n<ol>\n<li>正则带标志<code>g</code>时\n<ol>\n<li>返回一个数组，里面包含所有匹配到的结果</li>\n<li>没有匹配到结果时，返回<code>null</code></li>\n</ol>\n</li>\n<li>不带标志<code>g</code>时\n<ol>\n<li>当没有匹配到结果时，返回<code>null</code></li>\n<li>当匹配到结果时\n<ol>\n<li>返回一个类数组</li>\n<li>第一项是匹配的结果</li>\n<li>第二项是捕获组1匹配的结果</li>\n<li>第三项是捕获组2匹配的结果</li>\n<li>...</li>\n<li>然后是匹配到结果的位置索引<code>index</code></li>\n<li>然后是输入的字符串<code>input</code></li>\n<li>最后是一个可迭代对象<code>groups</code>，里面包含了所有命名捕获组匹配到的结果，如果没有命名捕获组，那么这一项就是<code>undefined</code></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>str.matchAll(regexp)：</p>\n<ol>\n<li>对<code>str.match</code>的改进方法，当带有标志<code>g</code>时，返回的是一个可迭代对象（不再是一个数组了），每一项是匹配到的结果，其格式与<code>match</code>方法不带<code>g</code>时匹配的结果格式一致。</li>\n<li>如果没有匹配到结果，返回的不再是<code>null</code>了，而是返回一个空的可迭代对象。</li>\n</ol>\n</li>\n<li>\n<p>str.split(regexp|subStr)：</p>\n<ol>\n<li>把字符串按照传入的参数，分割为数组</li>\n</ol>\n</li>\n<li>\n<p>str.search(regexp)：</p>\n<ol>\n<li>查找子字符串，如果有返回对应的索引</li>\n<li>如果没有，返回<code>-1</code></li>\n<li>只会匹配到第一个查找到的结果，如果想知道每个匹配字符串的位置，可以使用<code>str.matchAll()</code></li>\n</ol>\n</li>\n<li>\n<p>str.replace(str|regexp, str|fn)：字符串方法里的瑞士军刀，太强大了。</p>\n<ol>\n<li>\n<p>第二个参数为字符串时：</p>\n<ol>\n<li>\n<p>普通字符串：表示将匹配到的字符，替换成传入的字符串，如果正则不带标志<code>g</code>时，只会替换第一项，如果带了，就会全部替换</p>\n</li>\n<li>\n<p><code>$$</code>：表示将匹配到的字符串，替换为<code>$</code>。</p>\n</li>\n<li>\n<p><code>$&amp;</code>：表示将匹配到的字符串，替换为自己本身：</p>\n<pre><code class=\"language-js\">let str = \'aa\'\nlet reg = /\\w+/\n// \\w+ 匹配到了字符串 aa \n// $&amp; 代表匹配到的字符串本身\n// 所以 &lt;&lt;$&amp;&gt;&gt; 就是 &lt;&lt;aa&gt;&gt;\n// 最终输出 &lt;&lt;aa&gt;&gt;\nconsole.log(str.replace(reg, \'&lt;&lt;$&amp;&gt;&gt;\')) // &lt;&lt;aa&gt;&gt;\n</code></pre>\n</li>\n<li>\n<p>$`：表示将匹配到的字符串，替换为自己左边的内容：</p>\n<pre><code class=\"language-js\">let str = \'aa123bb\'\nlet reg = /\\d+/\n// \\d+ 匹配到了字符串 123 \n// $`代表匹配字符串左边的内容 aa\n// 所以 &lt;&lt;$`&gt;&gt; 就是 &lt;&lt;aa&gt;&gt;\n// 最终输出 aa&lt;&lt;aa&gt;&gt;bb\nconsole.log(str.replace(reg, \'&lt;&lt;$`&gt;&gt;\')) // aa&lt;&lt;aa&gt;&gt;bb\n</code></pre>\n</li>\n<li>\n<p><code>$\'</code>：表示将匹配到的字符串，替换为自己右边的内容：</p>\n<pre><code class=\"language-js\">let str = \'aa123bb\'\nlet reg = /\\d+/\n// \\d+ 匹配到了字符串 123 \n// $\' 代表匹配字符串右边的内容 bb\n// 所以 &lt;&lt;$`&gt;&gt; 就是 &lt;&lt;bb&gt;&gt;\n// 最终输出 aa&lt;&lt;bb&gt;&gt;bb\nconsole.log(str.replace(reg, &quot;&lt;&lt;$\'&gt;&gt;&quot;)) // aa&lt;&lt;bb&gt;&gt;bb\n</code></pre>\n</li>\n<li>\n<p><code>$1、$2、... $n</code>：表示对应的捕获组匹配到的内容，<code>$1</code>就代表着捕获组1，以此类推。</p>\n<pre><code class=\"language-js\">let str = \'aa bb\'\nlet reg = /(\\w+)\\s(\\w+)/\nconsole.log(str.replace(reg, \'$2_$1\')) // bb_aa\n</code></pre>\n</li>\n<li>\n<p><code>$&lt;name&gt;</code>：表示对应的命名捕获组匹配到的内容</p>\n<pre><code class=\"language-js\">let str = \'aa bb\'\nlet reg = /(?&lt;name1&gt;\\w+)\\s(?&lt;name2&gt;\\w+)/\nconsole.log(str.replace(reg, \'$&lt;name2&gt;_$&lt;name1&gt;\')) // bb_aa\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>当第二个参数是方法时（非常强大）：参数可以传递一个方法，方法接收如下几个参数</p>\n<ol>\n<li>\n<p>当有捕获组时</p>\n<pre><code class=\"language-js\">str.replace(reg, (match, $1, $2, ..., index, input, groups) =&gt; {\n    // math 表示匹配到的内容\n    // $1, $2, ..., 表示对应捕获组匹配到的内容\n    // index 匹配内容对应的索引\n    // input 输入的字符串\n    // groups 命名捕获组对应匹配到的内容\n    return \'xxx\' // 匹配到的内容最终替换成的字符串\n})\n</code></pre>\n</li>\n<li>\n<p>当没有捕获组时</p>\n<pre><code class=\"language-js\">str.replace(reg, (match, index, input)=&gt;{\n    // math 表示匹配的内容\n    // index 匹配内容对应的索引\n    // input 输入的字符串\n    return \'xxx\' // 匹配到的内容最终替换成的字符串\n})\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>regexp.exec()：在指定位置处开始查找</p>\n<ol>\n<li>\n<p>当不带标志<code>g</code>或<code>y</code>时，<code>reg.lastIndex</code>会被忽略，返回的结果与<code>str.match</code>不带<code>g</code>表示返回的结果格式一致。</p>\n<pre><code class=\"language-js\">let str = \'aa bb cc\'\nlet reg = /\\w+/\nreg.lastIndex = 2 // 并不会生效，会被忽略\nconsole.log(reg.lastIndex); // 2\n\n// 设置的lastIndex被忽略了，仍然从索引0开始查找\nconsole.log(reg.exec(str)) // [ \'aa\', index: 0, input: \'aa bb cc\', groups: undefined ]\nconsole.log(reg.lastIndex); // 2\n</code></pre>\n</li>\n<li>\n<p>当带标志<code>g</code>时，每次执行完<code>exec()</code>方法后，都会更新对应的<code>lastIndex</code>索引值。当执行结果为<code>null</code>时，<code>lastIndex</code>重新赋值为<code>0</code></p>\n<pre><code class=\"language-js\">let str = \'aa bb cc\'\nlet reg = /\\w+/g\nreg.lastIndex = 2 // 生效了\nconsole.log(reg.lastIndex); // 2\n\n// 设置的lastIndex生效了，从索引2开始查找，全文检索\nconsole.log(reg.exec(str)) // [ \'bb\', index: 3, input: \'aa bb cc\', groups: undefined ]\n\n// 执行完一次后，lastIndex的值被更新了\nconsole.log(reg.lastIndex); // 5 \n\n// 再次执行\nconsole.log(reg.exec(str)) // [ \'cc\', index: 6, input: \'aa bb cc\', groups: undefined ]\nconsole.log(reg.lastIndex); // 8 \n\nconsole.log(reg.exec(str)) // null\n// 当结果返回null 时，lastIndex重新赋值为了 0\nconsole.log(reg.lastIndex) // 0\n</code></pre>\n</li>\n<li>\n<p>当带标志<code>y</code>时，会在指定的<code>lastIndex</code>索引处开始检索，并不会全文检索。当执行结果为<code>null</code>时，<code>lastIndex</code>重新赋值为<code>0</code></p>\n<pre><code class=\"language-js\">let str = \'aa bb cc\'\nlet reg = /\\w+/y\nreg.lastIndex = 2 // 生效了\nconsole.log(reg.lastIndex); // 2\n\n// 设置的lastIndex生效了，从索引2开始查找，并不会全文检索，只会在当前位置查找\n// 索引2字符是一个空格 不满足 \\w+ 所以直接返回null\nconsole.log(reg.exec(str)) // null\n// 当结果返回null 时，lastIndex重新赋值为了 0\nconsole.log(reg.lastIndex); // 5\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>regexp.test()：查找匹配项，返回<code>true</code>或<code>false</code></p>\n<ol>\n<li>当设置过<code>lastIndex</code>后，会在指定位置处开始检索</li>\n<li>在同一个正则对不同的字符串执行<code>test()</code>操作后，每次执行后<code>lastIndex</code>会被更新，很有可能会导致结果不准确。如果非要这么用，每次执行完一次<code>test</code>操作后，将<code>lastIndex</code>重新赋值为<code>0</code>。（不建议这么用，可以执行使用<code>str.search()/str.match()</code>代替）</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-methods\">https://zh.javascript.info/regexp-methods</a></p>\n<p><a href=\"https://www.jianshu.com/p/31bebd90fd1d\">https://www.jianshu.com/p/31bebd90fd1d</a></p>\n', '2021-12-08 23:39:20', '2021-12-08 23:39:20');
INSERT INTO `t_blog` VALUES ('09169a10-3d10-11ec-8015-f554da021b2a', '微任务、宏任务、Event-Loop（nodejs篇）', 'JavaScript是一个单线程的脚本语言，为了解决同步的问题，引入了异步的概念，除了主线程上的同步操作外，还有个任务队列（task queue），所有大开销的任务都可以先通过异步函数包裹一下，通过回调函数的方式去触发它。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 3, 91, 3, 1, 2, 1, 'http://api.bnbiye.cn/upload/png/2021-11-04/cbba7100-3d0f-11ec-8015-f554da021b2a.png', '<h2>前言</h2>\n<p>JavaScript是一个单线程的脚本语言。</p>\n<blockquote>\n<p>思考一个问题，为什么不设计成多线程呢？</p>\n</blockquote>\n<p>这与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>\n<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>\n<blockquote>\n<p>再思考一个问题，因为是单线程，所有的代码都会同步执行，那假如代码中有一个同步操作很花费时间，后续的代码在这个操作未执行完成前都会卡住不动，这该怎么办，程序在这傻等着显然不合乎常理。</p>\n</blockquote>\n<p>所以，为了解决同步的问题，JavaScript引入了异步的概念。除了主线程上的同步操作外，Javascript还有个任务队列（task queue），所有大开销的任务都可以先通过异步函数包裹一下，通过回调函数的方式去触发它。我们只需要先把这个大开销的操作仍到任务队列中不管它，等主线程上同步任务都执行完毕后，再去轮询任务队列中的事件，看看哪个满足执行条件（比如setTimeout(fn, 100)，已经等待了100ms，就判定为满足条件），满足的就放到主线程上执行。这样就解决了上面的问题，设计的非常巧妙。</p>\n<blockquote>\n<p>在上面的分析中，我们知道，异步的任务都在任务队列中，而队列遵循先进先出原则，那么问题来了，假如队列里有很多个满足条件的异步操作，都可以挨个去主线程上去执行（遵循它们入队的顺序，先进先出），那假如有一个异步任务很重要，但它排在队尾，暂时还轮不到它，我们要让它插队怎么办？？？</p>\n</blockquote>\n<p>这就引出了本篇文章的主题，微任务和宏任务。JavaScript会将异步任务划分为微任务和宏任务，微任务会在宏任务之前执行（因为每次从主线程切换到任务队列时，都会优先遍历微任务队列，后遍历宏任务队列）。</p>\n<h2>微任务和宏任务</h2>\n<p>我们先来通过一个小例子，初时一下微任务、宏任务。</p>\n<h3>一个小例子</h3>\n<pre><code class=\"language-js\">// 1\nsetTimeout(() =&gt; { // 宏任务\n    console.log(4)\n}, 0)\n\n// 2\nnew Promise(resolve =&gt; {\n    resolve()\n    console.log(1)\n    // 3\n}).then(data =&gt; {  // 微任务\n    console.log(3)\n})\n\n// 4\nconsole.log(2) // 同步任务\n\n// 执行结果： 1 2 3 4\n</code></pre>\n<p>来看一下JavaScript引擎是如何执行这段代码的：</p>\n<ol>\n<li>程序首先遇到了<code>setTimeout</code>，<code>setTimeout</code>属于异步函数，并且属于宏任务，将其塞到宏任务队列中，先不执行。</li>\n<li>再往下走，<code>new Promise(resolve)</code>，根据<code>Promise</code>的特性，当使用<code>new</code>关键字声明一个<code>promise</code>对象时，会立即执行传入的<code>resolve</code>方法，也就是说，<code>resolve</code>函数里执行的代码属于同步代码，所以主线程直接执行，输出<code>1</code>。</li>\n<li>而之后的<code>.then()</code>方法属于异步方法，且属于微任务，所以将其塞到微任务队列中，先不执行。</li>\n<li>再往下走，是同步代码<code>console.log</code>，所以主线程直接执行，输出<code>2</code>。</li>\n<li>这时，所有同步的代码已经执行完毕，主线程的执行队列为空，然后就切换到任务队列里，任务队列优先遍历微任务队列。</li>\n<li>发现微任务队列中有步骤 3 中的<code>then</code>方法等待执行，且已满足执行条件，所以将<code>then</code>方法移至主线程队列中执行，输入<code>3</code>。执行完毕后，主线程队列再次为空，再次切换到任务队列。任务队列优先遍历微任务队列，此时发现微任务队列为空，开始遍历宏任务队列。（只有微任务队列为空时，才会开始遍历宏任务队列，并且每次只要从主线程切入任务队列，都会优先遍历一遍微任务队列）</li>\n<li>发现宏任务队列中有<code>1</code>步骤中的<code>setTimeout</code>函数等待执行，且已满足执行条件，所以将<code>setTimeout</code>中的回调函数移至主线程中执行，输出<code>4</code>。执行完毕后，主线程队列为空，再次切换到任务队列，遍历微任务队列，为空。再遍历宏任务队列，也为空。发现所有代码都已执行完毕，程序终止。所以最终的执行结果为：<code>1 2 3 4</code></li>\n</ol>\n<p>再简单画个图理解一下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3fe75661273c4500af8aaa1765838818~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"微任务宏任务代码解析 \" /></p>\n<p>通过这个小例子，我们推断：</p>\n<ol>\n<li>JavaScript执行代码时，同步任务顺序执行，遇到异步任务会先仍到任务队列中等待执行。</li>\n<li>任务队列分为宏任务队列和微任务队列。</li>\n<li>只有当主线程中的任务执行完毕后，才会去轮询执行任务队列中的异步任务，且每次优先执行微任务队列。</li>\n<li>所有任务队列中的任务，最终都会放置在主线程完成。</li>\n<li>从主线程切换到任务队列时，每次都会优先再轮询一遍微任务队列，只有微任务队列为空时，才会去轮询宏任务队列。</li>\n<li><code>setTimeout</code>和<code>promise.then</code>，都属于异步任务，且<code>setTimeout</code>属于宏任务，<code>promise.then</code>属于微任务。</li>\n<li>当主线程和任务队列都为空时，程序执行完毕。</li>\n</ol>\n<p>接下来，让我们看看平时都遇到过哪些宏任务和微任务。</p>\n<blockquote>\n<p>tip：上面的结论只是通过例子和平时的经验推断得到的，实际上中间还有很多细节需要注意，js有着自己独特的事件轮询机制，继续往下看吧。</p>\n</blockquote>\n<h3>宏任务MacroTask</h3>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eab2a9953804252a49ee71fe95569ea~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image-20211103102111067\" /></p>\n<p>图片来源：<a href=\"https://juejin.cn/post/6844903657264136200#comment\">https://juejin.cn/post/6844903657264136200#comment</a></p>\n<h4>I/O (input/output)</h4>\n<p>一直听过文件的独写操作，I/O操作，那么什么是I/O操作呢？<a href=\"https://en.m.wikipedia.org/wiki/Input/output\">维基百科</a>给出过定义，大意是说，在计算机科学中，计算机之间或人与计算机之间的信息交换，都是I/O操作。比如两台计算机通过网卡进行信息交互，比如向硬盘写入数据或读取硬盘数据，比如人敲击鼠标键盘等，比如鼠标滑动，等等等都属于I/O。在浏览器端和node端，所有的I/O操作都属于<strong>宏任务</strong> 。</p>\n<h4>setTimeout</h4>\n<p>设置一个定时器，在定时器到期后执行一个函数或指定的一段代码。在浏览器端和node端都属于<strong>宏任务</strong> 。</p>\n<h4>setInterval</h4>\n<p>方法重复调用一个函数或执行一个代码段，在每次调用之间具有固定的时间延迟。在浏览器端和node端都属于<strong>宏任务</strong> 。</p>\n<h4>setImmediate</h4>\n<p>node中特有的异步操作，只支持node端，属于<strong>宏任务</strong> 。</p>\n<h4>requestAnimationFrame</h4>\n<p>是浏览器端特有方法，告诉浏览器，希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>\n<blockquote>\n<p><strong>注意：若你想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用<code>window.requestAnimationFrame()</code></strong></p>\n<p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame\">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></p>\n</blockquote>\n<p>该方法只支持浏览器端，异步操作，且属于<strong>宏任务</strong> 。</p>\n<h3>微任务MicroTask</h3>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0471f70deca4e9c98c5badcbf5b55ab~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image-20211103102126271\" /></p>\n<p>图片来源：<a href=\"https://juejin.cn/post/6844903657264136200#comment\">https://juejin.cn/post/6844903657264136200#comment</a></p>\n<h4>Promise.then catch finally</h4>\n<p>浏览器和node都支持，异步任务，<strong>微任务</strong> 队列。</p>\n<h4>process.nextTick</h4>\n<p>node中特有的异步方法，属于<strong>微任务</strong> ，但是在微任务中，它的执行时机是最早的，比Promise.then还早。</p>\n<h4>MutationObserver</h4>\n<p>监听DOM树的更改，浏览器端特有功能。异步任务，属于<strong>微任务</strong> 。</p>\n<h3>再来一个例子</h3>\n<pre><code class=\"language-js\">// 1\nsetTimeout(() =&gt; {\n    console.log(5);\n}, 0)\n\n// 2\nsetImmediate(() =&gt; {\n    console.log(6)\n})\n\n// 3\nnew Promise((resolve, reject) =&gt; {\n    resolve()\n    console.log(1)\n}).then(data =&gt; { // 4\n    console.log(4)\n})\n\n// 5\nprocess.nextTick(() =&gt; {\n    console.log(3);\n})\n\n// 6\nlet a = 2\nconsole.log(a);\n\n// 输出结果：1 2 3 4 5 6\n</code></pre>\n<p>这个例子最终输入的结果是 1 2 3 4 5 6 ，我们来分析一下：</p>\n<ol>\n<li>程序首先遇到<code>setTimeout</code>，异步任务，宏任务，仍到宏任务队列先不管</li>\n<li>往下走，遇到<code>setImmediate</code>，异步任务，宏任务，扔到宏任务队列先不管</li>\n<li>遇到<code>new Promise</code>，new关键字声明的<code>promise</code>会自动执行<code>resolve</code>的回调方法，输出 1</li>\n<li>继续往下看，遇到<code>.then</code>方法，异步任务，微任务，扔到微任务队列先不管</li>\n<li>继续往下，遇到<code>process.nextTick</code>，异步任务，微任务，扔到微任务队列先不管（此处就和上个例子有区别了，<code>process.nextTick</code>的执行时机优先于其它微任务，换个角度看，我们可以将微任务队列分为两类，<code>process.nextTick微任务</code>和<code>除了process.nextTick的微任务</code>）。</li>\n<li>遇到同步代码<code>console.log</code>，输出 2。此时主线程任务执行完毕，开始轮询任务队列，优先执行微任务队列，微任务队列中，优先执行<code>process.nextTick</code>队列，发现有第5步中的<code>process.nextTick</code>任务未执行，将任务置于主线程执行，输出 3。</li>\n<li>主线程执行完毕，继续轮询任务队列，优先轮询微任务队列里的<code>nextTick队列</code>，发现为空，开始轮询<code>除了nextTick的微任务队列</code>，发现步骤 4 中的<code>then</code>方法等待执行，将其置于主线程中执行，输出 4.</li>\n<li>主线程执行完毕，继续轮询，发现微任务队列已空，开始轮询宏任务队列，发现步骤1中的<code>setTimeout</code>已经可以执行，移至主线程中执行，输出 5</li>\n<li>主线程执行完毕，继续轮询，发现微任务队列已空，开始轮询宏任务队列，发现步骤2中的<code>setImmediate</code>已经可以执行，移至主线程中执行，输出 6</li>\n<li>主线程执行完毕，任务队列为空，程序结束。</li>\n</ol>\n<p>再画个图理解一下：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1352efaae8345cdabc47fa3f2e132c7~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"微任务宏任务代码解析2\" /></p>\n<p>在这个例子里，我们只能够确定，在一次轮询中，<code>process.nextTick</code>微任务总会优先执行，但是宏任务中的<code>setTimeout</code>和<code>setImmediate</code>的执行顺序仍不能确定（往下看就会明白了）。要想知道实际的执行时机，得知道任务队列到底是怎么轮询的，也就是我们常说的，事件轮询<code>Event-Loop</code>机制。</p>\n<h2>事件轮询 Event-Loop</h2>\n<p>事件循环实际上有六个阶段：<strong>timer</strong> -&gt;<strong>Pending I/O callbacks</strong> -&gt;<strong>Idle, prepare</strong> -&gt;<strong>Poll</strong> -&gt;<strong>Check</strong> -&gt;<strong>Close callbacks</strong> 。</p>\n<p>事件轮询是一直循环往复的，只有当任务队列为空时，才会停止循环，且在每一趟循环中，每一个环节都会有对应的操作。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b04e82718ead4bd09ee9b8aaaaa4b414~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"事件循环\" /></p>\n<p>接下来我们看看轮询的每个阶段都在干什么。</p>\n<h3>事件循环的六个阶段</h3>\n<h4>timer 阶段</h4>\n<p>定时器阶段，处理<code>setTimeout()</code>和<code>setInterval()</code>的回调函数。进入这个阶段后，主线程会检查一下当前时间，是否满足定时器的条件。如果满足就执行回调函数，否则就离开这个阶段。</p>\n<h4>Pending I/O callbacks 阶段</h4>\n<p>除了以下操作的回调函数，其他的回调函数都在这个阶段执行。</p>\n<ul>\n<li><code>setTimeout()</code>和<code>setInterval()</code>的回调函数，（因为它在timer阶段执行）</li>\n<li><code>setImmediate()</code>的回调函数，（因为它在Check阶段执行）</li>\n<li>用于关闭请求的回调函数，比如<code>socket.on(\'close\', ...)</code>，（因为它在Close callbacks阶段执行）</li>\n</ul>\n<h4>Idle, prepare 阶段</h4>\n<p>该阶段只供 libuv 内部调用，可以忽略。</p>\n<h4>Poll 阶段</h4>\n<p>这个阶段是轮询时间，用于等待还未返回的 I/O 事件，比如服务器的回应、用户移动鼠标等等。这个阶段的时间会比较长。如果没有其他异步任务要处理（比如到期的定时器），会一直停留在这个阶段，等待 I/O 请求返回结果。</p>\n<h4>Check 阶段</h4>\n<p>该阶段执行<code>setImmediate()</code>的回调函数。</p>\n<h4>Close callbacks 阶段</h4>\n<p>该阶段执行关闭请求的回调函数，比如<code>socket.on(\'close\', ...)</code>。</p>\n<h3>例子</h3>\n<p>我们再来个例子理解一下：</p>\n<pre><code class=\"language-js\">const fs = require(\'fs\');\nconst startTime = Date.now();\n// 宏任务1：setTimeout，100ms 后执行的定时器\nsetTimeout(() =&gt; {\n    const delay = Date.now() - startTime;\n    console.log(`${delay}ms`);\n}, 100);\n\n// 宏任务2：I/O操作，文件读取后，有一个 500ms 的回调函数\nfs.readFile(\'1.js\', () =&gt; {\n    const startCallback = Date.now();\n    console.log(`${startCallback - startTime} ms`, \'read file callback\');\n    while (Date.now() - startCallback &lt; 500) {\n        // 什么也不做\n    }\n});\n\nnew Promise((resolve, reject) =&gt; {\n    resolve()\n    console.log(1);\n}).then(data =&gt; { // 微任务1：.then\n    console.log(2);\n})\n\n// 宏任务3：setImmediate\nsetImmediate(() =&gt; {\n    console.log(3);\n})\n\n// 微任务2：process.nextTick\nprocess.nextTick(() =&gt; {\n    console.log(4);\n})\n\n// 宏任务4：setTimeout\nsetTimeout(() =&gt; {\n    console.log(6);\n}, 0)\n\nconsole.log(5);\n// 输出 1 5 4 2 6 3 【9 ms read file callback】509ms\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20eb2289f0ec4419b5e1be15eb22c3c4~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"事件循环代码解析\" /></p>\n<p>上面的例子有几点需要注意：</p>\n<ul>\n<li>所有的函数执行都是在主线程中，从主线程中切会任务队列时，总会优先遍历一遍微任务队列。</li>\n<li>微任务队列优先执行process.nextTick</li>\n<li>从主线程中切回宏任务队列继续事件轮询时，会承接上阶段继续轮询，比如上一阶段是timer，那么继续I/O阶段轮询，依此类推。</li>\n<li>轮询总共六个阶段，timer、I/O callbacks、Idle prepare、Poll、check、close callbacks，只要任务队列没有被清空，事件循环就一直循环往复。</li>\n</ul>\n<h2>setTimeout和setImmediate</h2>\n<p>由于<code>setTimeout</code>在 timers 阶段执行，而<code>setImmediate</code>在 check 阶段执行。所以，<code>setTimeout</code>会早于<code>setImmediate</code>完成。</p>\n<pre><code class=\"language-js\">setTimeout(() =&gt; console.log(1));\nsetImmediate(() =&gt; console.log(2));\n</code></pre>\n<p>上面代码应该先输出<code>1</code>，再输出<code>2</code>，但是实际执行的时候，结果却是不确定的，有时还会先输出<code>2</code>，再输出<code>1</code>。这是因为<code>setTimeout</code>的第二个参数默认为<code>0</code>。但是实际上，Node 做不到0毫秒，最少也需要1毫秒。也就是说，<code>setTimeout(f, 0)</code>等同于<code>setTimeout(f, 1)</code>。实际执行的时候，进入事件循环以后，有可能到了1毫秒，也可能还没到1毫秒，取决于系统当时的状况。如果没到1毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行<code>setImmediate</code>的回调函数。</p>\n<p>但是，下面的代码一定是先输出2，再输出1。</p>\n<pre><code class=\"language-js\">const fs = require(\'fs\');\n\nfs.readFile(\'1.js\', () =&gt; {\n  setTimeout(() =&gt; console.log(1));\n  setImmediate(() =&gt; console.log(2));\n});\n</code></pre>\n<p>上面代码会先进入 I/O callbacks 阶段，然后是 check 阶段，最后才是 timers 阶段。因此，<code>setImmediate</code>才会早于<code>setTimeout</code>执行。</p>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903657264136200#comment\">微任务、宏任务与Event-Loop</a></p>\n<p><a href=\"https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/#level-1-bossfight\">Tasks, microtasks, queues and schedules</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2014/10/event-loop.html\">JavaScript 运行机制详解：再谈Event Loop</a></p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html\">node-event-loop</a></p>\n<p><a href=\"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#event-loop-explained\">Event Loop Explained</a></p>\n<p><a href=\"https://promisesaplus.com/#notes\">Promises/A+规范</a></p>\n<p><a href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model\">event-loop-processing-model</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent\">EventTarget.dispatchEvent</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver\">MutationObserver</a></p>\n', '2021-11-04 09:39:22', '2021-12-09 21:54:56');
INSERT INTO `t_blog` VALUES ('0a797310-3d8c-11ec-97a5-ef78eceb5d73', '优化首屏加载的规则和建议', '优化浏览器首屏加载的几点建议', '-1', 2, 'https://developers.google.com/web/fundamentals/performance/critical-rendering-path/page-speed-rules-and-recommendations', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 10, 0, 1, 2, 1, '', '<h2>消除阻塞渲染的 JavaScript 和 CSS</h2>\n<p>要以最快速度完成首次渲染，需要最大限度减少网页上关键资源的数量并（尽可能）消除这些资源，最大限度减少下载的关键字节数，以及优化关键路径长度。</p>\n<h2>优化 JavaScript 的使用</h2>\n<p>默认情况下，JavaScript 资源会阻塞解析器，除非将其标记为 <code>async</code> 或通过专门的 JavaScript 代码段进行添加。阻塞解析器的 JavaScript 会强制浏览器等待 CSSOM 并暂停 DOM 的构建，继而大大延迟首次渲染的时间。</p>\n<h3>首选使用异步 JavaScript 资源</h3>\n<p>异步资源不会阻塞文档解析器，让浏览器能够避免在执行脚本之前受阻于 CSSOM。通常，如果脚本可以使用 <code>async</code> 属性，也就意味着它并非首次渲染所必需。可以考虑在首次渲染后异步加载脚本。</p>\n<h3>延迟解析 JavaScript</h3>\n<p>为了最大限度减少浏览器渲染网页的工作量，应延迟任何非必需的脚本（即对构建首次渲染的可见内容无关紧要的脚本）。</p>\n<h3>避免运行时间长的 JavaScript</h3>\n<p>运行时间长的 JavaScript 会阻止浏览器构建 DOM、CSSOM 以及渲染网页，所以任何对首次渲染无关紧要的初始化逻辑和功能都应延后执行。如果需要运行较长的初始化序列，请考虑将其拆分为若干阶段，以便浏览器可以间隔处理其他事件。</p>\n<h2>优化 CSS 的使用</h2>\n<p>CSS 是构建渲染树的必备元素，首次构建网页时，JavaScript 常常受阻于 CSS。确保将任何非必需的 CSS 都标记为非关键资源（例如打印和其他媒体查询），并应确保尽可能减少关键 CSS 的数量，以及尽可能缩短传送时间。</p>\n<h3>将 CSS 置于文档 head 标签内</h3>\n<p>尽早在 HTML 文档内指定所有 CSS 资源，以便浏览器尽早发现 <code>&lt;link&gt;</code> 标记并尽早发出 CSS 请求。</p>\n<h3>避免使用 CSS import</h3>\n<p>一个样式表可以使用 CSS import (<code>@import</code>) 指令从另一样式表文件导入规则。不过，应避免使用这些指令，因为它们会在关键路径中增加往返次数: 只有在收到并解析完带有 <code>@import</code> 规则的 CSS 样式表之后，才会发现导入的 CSS 资源。</p>\n<h3>内联阻塞渲染的 CSS</h3>\n<p>为获得最佳性能，您可能会考虑将关键 CSS 直接内联到 HTML 文档内。这样做不会增加关键路径中的往返次数，并且如果实现得当，在只有 HTML 是阻塞渲染的资源时，可实现“一次往返”关键路径长度。</p>\n', '2021-11-05 00:27:02', '2021-11-05 10:38:19');
INSERT INTO `t_blog` VALUES ('0bbfd760-420e-11ec-96d5-7933aca11ca0', '原型链', '我们都知道js语言有原型链的概念，每个对象都会有个__proto__属性，它要么是null，要么就是对另一个对象的引用，称之为原型，通过本篇文章，让我们来了解原型链的真是面目。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 2, 24, 2, 1, 2, 1, 'http://api.bnbiye.cn/upload/png/2021-11-10/394c4d80-420e-11ec-96d5-7933aca11ca0.png', '<h2>前言</h2>\n<p>我们都知道js语言有原型链的概念，每个对象都会有个<code>__proto__</code>属性，它要么是<code>null</code>，要么就是对另一个对象的引用，称之为原型。先看几个小例子简单了解一下什么是原型。</p>\n<blockquote>\n<p>tip：刚接触原型链的概念时，会分不清<code>__proto__</code>和<code>[[Prototype]]</code>的区别。其实规范里不使用<code>__proto__</code>属性来保存原型，而是使用隐藏的属性<code>[[Prototype]]</code>。不过我们使用<code>__proto__</code>也没有问题。因为在规范没出来前，所有的浏览器包括服务端都已经支持了<code>__proto__</code>的写法，所以该属性就一直被保留了下来。</p>\n<p>它俩还是有区别的，<code>__proto__</code> 实际是 <code>[[Prototype]]</code> 的 <code>getter/setter</code>。<code>__proto__</code> 属性目前来看有点过时了，现代编程语言建议使用函数 <code>Object.getPrototypeOf/Object.setPrototypeOf</code> 来取代 <code>__proto__</code> 去 get/set 原型，但是由于 <code>__proto__</code> 标记在观感上更加明显，所以我们在后面的示例中将使用它。</p>\n</blockquote>\n<h3>原型其实就是个对象</h3>\n<p>先来看一个小例子理解下原型的概念。</p>\n<pre><code class=\"language-js\">let animal = {\n    eats: true\n};\nlet rabbit = {\n    jumps: true,\n    __proto__: animal // 设置 rabbit.[[Prototype]] = animal\n};\nconsole.log(rabbit.jumps) // true\nconsole.log(rabbit.eats) // true\n</code></pre>\n<p>如上面的例子，<code>animal</code>对象就是<code>rabbit</code>对象的原型。在调用<code>rabbit.eats</code>时，因为<code>rabbit</code>对象自身并没有这个属性，所以就会顺着原型向上找，在<code>animal</code>对象中找到了<code>eats</code>属性，所以输出了<code>true</code>。</p>\n<blockquote>\n<p><strong>从上面的例子看出，原型其实就是一个对象。</strong></p>\n</blockquote>\n<h3>原型链可以很长</h3>\n<p>原型链可以很长，比如下面这个例子</p>\n<pre><code class=\"language-js\">let animal = {\n    eats: true,\n    walk() {\n        alert(&quot;Animal walk&quot;);\n    }\n};\n\nlet rabbit = {\n    jumps: true,\n    __proto__: animal\n};\n\nlet longEar = {\n    earLength: 10,\n    __proto__: rabbit\n};\n\n// walk 是通过原型链获得的\nlongEar.walk(); // Animal walk\nconsole.log(longEar.jumps); // true（从 rabbit）\n</code></pre>\n<p>现在，如果从 <code>longEar</code> 中读取一些它不存在的内容，JavaScript 会顺着原型链一层一层往上查找（先找 <code>rabbit</code> ，然后 <code>animal</code> ）。</p>\n<h3>原型链的两点注意事项</h3>\n<p>这里会有两个限制：</p>\n<ol>\n<li>\n<p>引用不能形成闭环。如果我们试图在一个闭环中分配 <code>__proto__</code>，JavaScript 会抛出错误。</p>\n<pre><code class=\"language-js\">let animal = {\n    eats: true,\n    walk() {\n        alert(&quot;Animal walk&quot;);\n    },\n    __proto__: animal\n};\n/* \n	ReferenceError: Cannot access \'animal\' before initialization\n*/\n</code></pre>\n</li>\n<li>\n<p><code>__proto__</code> 的值可以是对象，也可以是 <code>null</code>。而其他的类型都会被忽略。</p>\n<p>忽略的意思是还按之前的引用。比如，</p>\n<p><code>let arr1 = new Array()</code>，此时<code>arr1</code>的<code>__proto__</code>默认指向<code>Array.prototype</code></p>\n<p><code>let o1 = {}</code>，此时<code>o1</code>的<code>__proto__</code>默认指向<code>Object.prototype</code></p>\n<pre><code class=\"language-js\">let animal = {\n    eats: true,\n    walk() {\n        alert(&quot;Animal walk&quot;);\n    }\n};\n\nlet arr1 = new Array()\nconsole.log(arr1.__proto__ === Array.prototype); // true\narr1.__proto__ = \'xxxx\' // 赋值的不是对象，也不是null，会被忽略\nconsole.log(arr1.__proto__ === Array.prototype); // true\narr1.__proto__ = null // 赋值为null\nconsole.log(arr1.__proto__); // undefined，这里很有意思，赋值为null，但是输出的是 undefined\narr1.__proto__ = animal // 赋值为对象\nconsole.log(arr1.__proto__); // { eats: true, walk: [Function: walk] }\n</code></pre>\n</li>\n</ol>\n<h2><code>__proto__</code>的最顶部是<code>null</code></h2>\n<p>原型链可以有很长很长，那它的最顶部是个啥呢？我们来看这样一个图，看懂这个图，相信会对原型链有个很清晰的认知。（图片来自：<a href=\"https://github.com/KieSun/Dream/issues/2\">https://github.com/KieSun/Dream/issues/2</a>）</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111091631229.png\" alt=\"image-20211109163134065\" /></p>\n<p>先来弄懂下面几个问题</p>\n<h3>图中有多少个对象？</h3>\n<p>相信很多人会直接回答，有四个！<code>f2、f1、o1、o2</code>，只有它们四个使用<code>typeof</code>时得到的值是<code>object</code>，所以就只有它们四个是对象。</p>\n<p>其实是不正确的，即便<code>typeof</code>得到的值是<code>function</code>，它也是一个对象，称之为函数对象（也可以叫函数、也可以叫方法，或者叫构造方法）。图中的<code>Object</code>和<code>Function</code>就是函数对象，它们是JS的内置对象。</p>\n<blockquote>\n<p>tip：JS中对象分为两种，<strong>函数对象</strong>和<strong>一般对象</strong>。我们使用<code>function xx(){}</code>声明出来的都是函数对象。</p>\n<p>声明一般对象时我们可以使用<code>new</code>关键字（<code>new</code>声明出来的对象，我们也叫实例对象，只有构造方法才能使用<code>new</code>关键字来声明实例对象），比如<code>let o1 = new Object()</code>或者<code>let a1 = new Array()</code>。</p>\n<p>或者直接用<code>let a = {}</code>，其实这种方式等效于<code>let a = new Object()</code>。</p>\n</blockquote>\n<p>JS有很多内置对象，除了图中的<code>Object</code>和<code>Function</code>，还有很多，比如<code>Boolean、Symbol、Error、Math、JSON、Date</code>等等。这些内置对象大部分是函数对象，还有小部分是一般对象。函数对象使用<code>typeof</code>得到的值为<code>function</code>，一般对象得到的值为<code>object</code>。（<code>null</code>是个例外，<code>typeof</code>得到的值也是<code>object</code>，这是个历史遗留问题，特殊记一下）</p>\n<pre><code class=\"language-js\">function Foo() { }\nlet f1 = new Foo()\nlet f2 = new Foo()\nlet o1 = new Object()\nlet o2 = new Object()\n\nconsole.log(typeof f1); // object\nconsole.log(typeof f2); // object\nconsole.log(typeof o1); // object\nconsole.log(typeof o2); // object\n\nconsole.log(typeof Foo); // function\n/* 基本对象 */\nconsole.log(typeof Object); // function\nconsole.log(typeof Function); // function\n\n/* 错误对象 */\nconsole.log(typeof Error); // function\n\n/* 数字和日期对象 */\nconsole.log(typeof Number); // function\nconsole.log(typeof Date); // function\nconsole.log(typeof Math, \'Math 不是一个函数对象，因此它是不可构造的\'); // object \n\n/* 字符串对象 */\nconsole.log(typeof String); // function\nconsole.log(typeof RegExp); // function\n\n/* 可索引的集合对象 */\nconsole.log(typeof Array); // function\n\n/* 使用键的集合对象 */\nconsole.log(typeof Map); // function\nconsole.log(typeof Set); // function\n\n/* 结构化数据 */\nconsole.log(typeof ArrayBuffer); // function\nconsole.log(typeof JSON, \'JSON 不是一个函数对象，因此它是不可构造的\'); // object\n\n/* 控制抽象对象 */\nconsole.log(typeof Promise); // function\n\n/* 反射 */\nconsole.log(typeof Reflect, \'Reflect不是一个函数对象，因此它是不可构造的。\'); // object\nconsole.log(typeof Proxy); // function\n\nconsole.log(typeof null, \'typeof null的值是object，是个历史遗留问题，特殊记一下\');\n</code></pre>\n<h3><code>xxx.prototype</code>是个啥？</h3>\n<p>知道了什么是<code>函数对象</code>和<code>一般对象</code>后，我们继续看图，又有了个疑问。图中所有对象的<code>__proto__</code>（原型）都指向了<code>xxx.prorotype</code>上面，那么这个<code>xxx.prorotype</code>又是个啥？</p>\n<p>实际上每个函数对象，默认都会有个<code>prototype属性</code>（<code>prototype</code>实际就是一个<strong>对象</strong>，上面可以挂载很多方法和属性），我们一直说的原型其实就是它。所有对象的<code>__proto__</code>都会指向原型上，一层一层的往上指，一直指到<code>null</code>。每当我们在对象上找一个属性或方法时，如果自己没有，就会去原型链上找，一层一层的找，直到找到为止。</p>\n<blockquote>\n<p>tip：函数对象的<code>prototype</code>是我们声明对象时，js默认添加上的。比如</p>\n<p><code>let o1 = {}</code>，对象<code>o1</code>的<code>__proto__</code>默认会指向<code>Object.prototype</code>，即：<code>o1.__proto__ === Object.prototype </code></p>\n<p><code>let o2 = new Array()</code>，对象<code>o2</code>的<code>__proto__</code>默认会指向<code>Array.prototype</code>，即：<code>o2.__proto__ === Array.prototype </code></p>\n</blockquote>\n<h4>分析<code>f1</code>、<code>f2</code></h4>\n<p>我们先来分析一下图中的<code>f1</code>和<code>f2</code>两个对象：</p>\n<pre><code class=\"language-js\">function Foo() { }\nlet f1 = new Foo()\nlet f2 = new Foo()\n\nconsole.log(f1.__proto__ === Foo.prototype); // true\nconsole.log(f2.__proto__ === Foo.prototype); // true\n\nconsole.log(f1.__proto__.__proto__ === Object.prototype); // true\nconsole.log(f1.__proto__.__proto__.__proto__ === null); // true\n</code></pre>\n<p>通过打印输出，验证了我们之前的分析是正确的。<code>f1</code>和<code>f2</code>两个对象的<code>__proto__</code>都指向<code>Foo.prototype</code>，即<code>f1.__proto__ === Foo.prototype</code>。（<code>f2</code>同理）</p>\n<p>而又因为<code>Foo.prototype</code>属性本身就是一个对象，对象都会有属于它的原型（有<code>__proto__</code>），所有对象的原型默认都指向<code>Object.prototype</code>，所以<code>Foo.prototype.__proto__ === Object.prototype</code>，即<code>f1.__proto__.__proto__ === Object.prototype</code>。</p>\n<p>那么问题来了，如果说所有的原型都是一个对象，对象的原型默认都指向<code>Object.prototype</code>，那<code>Object.prototype</code>按理说也应该是个对象，那它不就自己指自己了，这种情况不就报错了？那 <code>Object.prototype</code>的原型指向哪里呢？</p>\n<p>其实我们标题已经给出了答案，没错，是<code>null</code>，我们已经找到头了，<code>Object.prototype.__proto__ === null</code>，即<code>f1.__proto__.__proto__.__proto__ === null</code>。</p>\n<h4>分析<code>o1</code>、<code>o2</code></h4>\n<p>我们再来分析一下图中的<code>o1</code>和<code>o2</code>两个对象：<code>o1</code>、<code>o2</code>的分析和<code>f1</code>、<code>f2</code>一样，都是类似的，直接看运行结果。</p>\n<pre><code class=\"language-js\">let o1 = new Object()\nlet o2 = new Object()\nlet o3 = {} // 可以看成 let o3 = new Object()\n\nconsole.log(o1.__proto__ === Object.prototype); // true\nconsole.log(o2.__proto__ === Object.prototype); // true\nconsole.log(o3.__proto__ === Object.prototype); // true\n\nconsole.log(o1.__proto__.__proto__ === null); // true\n</code></pre>\n<h4>分析<code>Foo</code></h4>\n<p>根据上文，我们已经知道，对象分为一般对象和函数对象，一般对象原型<code>__proto__</code>默认都指向<code>Object.prototype</code>，那么函数对象的原型默认指向哪呢？答案是，指向<code>Function.prototype</code>。</p>\n<p>函数对象（也成为构造函数或函数）是使用<code>function</code>关键字声明出来的，图中的<code>Foo</code>就是一个函数对象。</p>\n<pre><code class=\"language-js\">function Foo() { }\n\nconsole.log(Foo.__proto__ === Function.prototype); // true\nconsole.log(Foo.__proto__.__proto__ === Object.prototype); // true\nconsole.log(Foo.__proto__.__proto__.__proto__ === null); // true\n</code></pre>\n<p>通过打印输出，验证了我们的分析是正确的。<code>Foo</code>的原型指向了<code>Function.prototype</code>，即：<code>Foo.__proto__ === Function.prototype</code>。</p>\n<p><code>Function.prototype</code>本身就是一个对象，所以它的原型默认指向<code>Object.prototype</code>，即：<code>Foo.__proto__.__proto__ === Object.prototype</code>。</p>\n<p><code>Object.prototype</code>的原型指向<code>null</code>，即：<code>Foo.__proto__.__proto__.__proto__ === null</code>。</p>\n<h4>分析<code>Function</code></h4>\n<p>我们已经知道函数对象的原型默认都指向<code>Function.prototype</code>，那么问题来了<code>Function</code>本身就是一个函数对象，那它的原型指向哪呢？没有错，指向它自己的<code>prototype</code>，即<code>Function.__proto__ === Function.prototype</code>，图上也是这么画的，我们举例来验证一下。</p>\n<pre><code class=\"language-js\">console.log(Function.__proto__ === Function.prototype); // true\nconsole.log(Function.__proto__.__proto__ === Object.prototype); // true\nconsole.log(Function.__proto__.__proto__.__proto__ === null); // true\n</code></pre>\n<p>通过打印输出，验证了我们的分析是正确的。<code>Function</code>的原型指向了<code>Function.prototype</code>，即：<code>Function.__proto__ === Function.prototype</code>。</p>\n<p><code>Function.prototype</code>本身就是一个对象，所以它的原型默认指向<code>Object.prototype</code>，即：<code>Function.__proto__.__proto__ === Object.prototype</code>。</p>\n<p><code>Object.prototype</code>的原型指向<code>null</code>，即：<code>Function.__proto__.__proto__.__proto__ === null</code>。</p>\n<h4>分析<code>Object</code></h4>\n<p>根据上面的一大堆分析，到现在我们已经能猜测出结果了。因为<code>Object</code>也是一个内置的函数对象，所以它的原型应该指向<code>Function.prototype</code>，然后剩下的就都一样了。图上也是这么画的，我们拿例子验证一下。</p>\n<pre><code class=\"language-js\">console.log(Object.__proto__ === Function.prototype); // true\nconsole.log(Object.__proto__.__proto__ === Object.prototype); // true\nconsole.log(Object.__proto__.__proto__.__proto__ === null); // true\n</code></pre>\n<p>根据打印输出，验证我们的猜想是正确的。<code>Object</code>的原型指向了<code>Function.prototype</code>，即：<code>Object.__proto__ === Function.prototype</code>。</p>\n<p><code>Function.prototype</code>本身就是一个对象，所以它的原型默认指向<code>Object.prototype</code>，即：<code>Object.__proto__.__proto__ === Object.prototype</code>。</p>\n<p><code>Object.prototype</code>的原型指向<code>null</code>，即：<code>Object.__proto__.__proto__.__proto__ === null</code>。</p>\n<blockquote>\n<p>以上，已经分析完了所有情况，其实就是这么简单。</p>\n<p>原型实际就是一个对象，<code>function</code>声明出来的函数对象（也称构造函数或函数），它的原型默认指向<code>Function.prototype</code>。JS内置的函数对象的原型默认也指向<code>Function.prototype</code>。顺着原型链往上找，最终肯定能指到<code>Object.prototype</code>，再往上就是<code>null</code>了。</p>\n</blockquote>\n<h3><code>constructor</code>是个啥？</h3>\n<p>整张图我们已经分析的差不多了，但是图中还遗漏了一处，<code>constructor</code>是个啥？</p>\n<p>看图我们发现，<code>Foo.prototype.constructor</code>又指回了<code>Foo</code>、<code>Object.prototype.constructor</code>又指回了<code>Object</code>、<code>Function.prototype.constructor</code>又指回了<code>Function</code>。我们自己来验证一下：</p>\n<pre><code class=\"language-js\">function Foo() { }\nlet f1 = new Foo()\n\nconsole.log(Foo.prototype.constructor === Foo); // true\nconsole.log(Object.prototype.constructor === Object); // true\nconsole.log(Function.prototype.constructor === Function); // true\n\nconsole.log(f1.constructor === Foo); // true\n</code></pre>\n<p>通过验证我们发现，确实是这么回事，原型的<code>constructor</code>属性又指向了函数对象（构造函数）本身。不仅是原型保存了这个函数对象（构造函数），实例对象也保存了一份，如示例中的<code>f1.constructor === Foo</code>。那<code>constructor</code>的作用是干什么的呢？</p>\n<h4>作用一：类型判断</h4>\n<p>其实，<code>constructor</code>就是保存了一份对象的构造方法，好让我们知道这个对象是从哪里来的。要说它真正的作用，JS底层可能会用到，以下是我的猜测：</p>\n<blockquote>\n<p>底层用于类型判断 比如<code>typeof</code>：</p>\n<p>我们在使用<code>function</code>关键字声明一个函数时，其实这个函数就是一个构造函数，本文中我们也称之为函数对象，工作中我们习惯的叫法说它是个函数。其实不管怎么称呼，只要是<code>function</code>声明出来的，我们都可以使用<code>new</code>关键字来构建一个实例对象，然后实例对象就可以通过原型链，访问原型上面的方法。</p>\n<p>所以，当使用<code>function</code>声明一个构造方法时，JS为它自动绑定了一个<code>prototype</code>对象，然后又自动的往<code>prototype</code>塞了一个自身的引用<code>constructor</code>，即<code>xxx.prototype.constructor === xxx</code>。只要是这种格式的对象，JS都认定它是函数对象（构造方法），可以使用<code>new</code>关键字来声明实例对象。使用<code>typeof</code>进行类型校验时，会返回<code>function</code>。</p>\n<p>假如我们随便定义一个<code>非function类型</code>（假如是个<code>number</code>），我们强行对齐使用<code>new</code>，就会报错。比如：</p>\n<p><code>let a = 1</code>，对<code>a</code>强行使用<code>new</code>，<code>let o1 = new a</code>，JS会抛出一个错误，<code>TypeError: a is not a constructor</code>，所以我猜想<strong>保存<code>constructor</code>除了告诉我们该对象是从哪里来的，还一个作用就是为了用作类型判断，所有的构造函数<code>typeof</code>之后的值都为<code>function</code>。</strong></p>\n</blockquote>\n<p>补充个<code>MDN</code>给构造函数的定义：</p>\n<blockquote>\n<p><strong>构造函数</strong>属于被实例化的特定类<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Object\">对象</a> 。构造函数初始化这个对象，并提供可以访问其私有信息的方法。构造函数的概念可以应用于大多数<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/OOP\">面向对象</a>的编程语言。本质上，<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/JavaScript\">JavaScript</a> 中的构造函数通常在<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Class\">类</a>的实例中声明。（跟自己理解的差不多，构造函数本身也是一个对象。）</p>\n<p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Glossary/Constructor\">https://developer.mozilla.org/zh-CN/docs/Glossary/Constructor</a></p>\n</blockquote>\n<h4>作用二：创建新的实例对象</h4>\n<p>除了上述作用，我们可以使用 <code>constructor</code> 属性来创建一个新对象，该对象使用与现有对象相同的构造器。比如：</p>\n<pre><code class=\"language-js\">function Rabbit(name) {\n  this.name = name;\n  console.log(name);\n}\n\nlet rabbit = new Rabbit(&quot;White Rabbit&quot;);\n\nlet rabbit2 = new rabbit.constructor(&quot;Black Rabbit&quot;);\n</code></pre>\n<p>当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。</p>\n<h4>使用<code>constructor</code>的注意事项</h4>\n<p><strong>……JavaScript 自身并不能确保正确的 <code>&quot;constructor&quot;</code> 函数值。</strong></p>\n<p>它存在于函数的默认 <code>prototype</code> 中，但仅此而已。之后会发生什么 —— 完全取决于我们。</p>\n<p>如果我们将整个默认 <code>prototype</code> 替换掉，那么其中就不会有 <code>constructor</code> 了，比如：</p>\n<pre><code class=\"language-js\">function Rabbit() {}\nRabbit.prototype = {\n  jumps: true\n};\n\nlet rabbit = new Rabbit();\nconsole.log(rabbit.constructor === Rabbit); // false\n</code></pre>\n<p>因此，为了确保正确的 <code>constructor</code>，我们可以选择添加/删除属性到默认的 <code>prototype</code>中，而不是将其整个覆盖掉：</p>\n<pre><code class=\"language-js\">function Rabbit() {}\n\n// 不要将 Rabbit.prototype 整个覆盖\n// 可以向其中添加内容\nRabbit.prototype.jumps = true\n// 默认的 Rabbit.prototype.constructor 被保留了下来\n</code></pre>\n<p>或者，也可以手动重新创建 <code>constructor</code> 属性：</p>\n<pre><code class=\"language-js\">Rabbit.prototype = {\n  jumps: true,\n  constructor: Rabbit\n};\n\n// 这样的 constructor 也是正确的，因为我们手动添加了它\n</code></pre>\n<h2>总结</h2>\n<ul>\n<li>在 JavaScript 中，所有的对象都有一个隐藏的 <code>[[Prototype]]</code> 属性，它要么是另一个对象，要么就是 <code>null</code>。</li>\n<li>通过 <code>[[Prototype]]</code> 引用的对象被称为“原型”。</li>\n<li><code>__proto__</code>属于<code>[[prototype]]</code>的<code>getter/setter</code>。<code>__proto__</code> 并不是语言本身的特性，是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 <code>Object.getPrototypeOf</code> 方法来获取实例对象的原型，然后再来为原型添加方法或属性。</li>\n<li>如果我们想要读取 <code>obj</code> 的一个属性或者调用一个方法，并且它不存在，那么 JavaScript 就会尝试在原型中查找它。</li>\n<li>原型的最顶部是<code>null</code>。</li>\n<li>通过构造方法（假设为<code>Foo</code>）<code>new</code>出来的对象（假设为<code>o</code>），会默认有个<code>constructor</code>属性，该属性指向它的构造方法，即<code>o.constructor ===Foo</code>。</li>\n<li>通过构造方法（假设为<code>Foo</code>）<code>new</code>出来的对象（假设为<code>o</code>），它的<code>__proto__</code>会默认指向它的构造方法的原型上，即<code>o.__proto__ ===Foo.prototype</code>。</li>\n<li>构造方法（假设为<code>Foo</code>）的原型上默认有个<code>constructor</code>属性，该属性执行它自己，即<code>Foo.prototype.constructor === Foo</code>。</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://github.com/KieSun/Dream/issues/2\">https://github.com/KieSun/Dream/issues/2</a></p>\n<p><a href=\"https://zh.javascript.info/prototype-inheritance\">https://zh.javascript.info/prototype-inheritance</a></p>\n<p><a href=\"https://zh.javascript.info/function-prototype\">https://zh.javascript.info/function-prototype</a></p>\n<p><a href=\"https://es6.ruanyifeng.com/#docs/class\">https://es6.ruanyifeng.com/#docs/class</a></p>\n', '2021-11-10 18:07:43', '2021-11-11 15:49:59');
INSERT INTO `t_blog` VALUES ('0c25cd50-5f27-11ec-b395-6d1b1a7579ec', '二叉树的镜像', 'JZ27 二叉树的镜像', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 3, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171829754.png\" alt=\"image-20211217182956630\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171830845.png\" alt=\"image-20211217183011806\" /></p>\n<h2>代码</h2>\n<h3>代码1 层次遍历翻转</h3>\n<pre><code class=\"language-js\">/*\n层次遍历 左右翻转\n*/\nfunction Mirror( pRoot ) {\n    if(pRoot === null) return null\n    \n    let q = [] // 使用数组模拟队列\n    q.push(pRoot) // 入队\n    \n    // 开始层次遍历\n    while(q.length&gt;0){\n        let current = q.shift() // 出队\n        \n        // 把这一层节点的left和right替换\n        \n        let tempNode = current.left\n        current.left = current.right\n        current.right = tempNode\n        \n        // 开始遍历下一层，把下一层的节点入队\n        if(current.left){\n            q.push(current.left)\n        }\n        if(current.right){\n            q.push(current.right)\n        }\n        \n    }\n    return pRoot\n}\n</code></pre>\n<h3>代码2 深度优先搜索翻转翻转</h3>\n<pre><code class=\"language-js\">/*\n深度优先搜索 翻转\nlog(root.val)\ndfs(root.left)\ndfs(root.right)\n*/\nfunction Mirror( pRoot ) {\n    if(!pRoot) return null\n    \n    let temp = pRoot.left\n    pRoot.left = pRoot.right\n    pRoot.right = temp\n    \n    // 因为翻转了 所以换个头。先right再left\n    Mirror(pRoot.right)\n    Mirror(pRoot.left)\n    return pRoot\n}\n</code></pre>\n<h3>代码3 中序遍历翻转</h3>\n<pre><code class=\"language-js\">/*\n中序遍历 左根右 翻转\ninOrder(root.left)\nlog(root.val)\ninOrder(root.right)\n*/\nfunction Mirror( pRoot ) {\n    if(!pRoot) return null\n    \n    Mirror(pRoot.left)\n    \n    let temp = pRoot.left\n    pRoot.left = pRoot.right\n    pRoot.right = temp\n    \n    // 因为已经翻转了，所以把right改为left\n    Mirror(pRoot.left)\n    return pRoot\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/a9d0ecbacef9410ca97463e4a5c83be7?tpId=13&amp;tqId=1374963&amp;ru=/practice/6e196c44c7004d15b1610b9afca8bd88&amp;qru=/ta/coding-interviews/question-ranking\">JZ27 二叉树的镜像</a></p>\n', '2021-12-17 18:49:45', '2021-12-17 18:49:45');
INSERT INTO `t_blog` VALUES ('0e884810-2d87-11ec-ba0f-810bb435395b', 'git技巧总结', 'git工作中会使用到的一些指令以及一些场景，撤销git add，版本回退、查看分支、从远端克隆分支等等', '-1', 1, '', 'ed61f0f0-2cbe-11ec-86ae-0da8227970f6', 4, 4, 3, 1, 2, 1, 'http://82.156.76.49:20517/upload/png/2021-10-15/2eaae7b0-2d87-11ec-ba0f-810bb435395b.png', '<h2>1. 仓库的初始化</h2>\n<p>1、在github上新建一个代码仓库<code>aaabbb</code></p>\n<blockquote>\n<p>https:#github.com/aaabbb</p>\n</blockquote>\n<p>2、将本地测试项目上传至远端github仓库</p>\n<pre><code class=\"language-git\">echo &quot;# aaabbb&quot; &gt;&gt; README.md\ngit init\ngit add README.md\ngit commit -m &quot;first commit&quot;\ngit remote add origin https:#github.com/13836005450/aaabbb.git\ngit push -u origin master\n</code></pre>\n<p>3、忽略某个文件夹，添加<code>.gitignore</code>文件</p>\n<pre><code class=\"language-git\"># /modules\n/modules\n</code></pre>\n<h2>2. 团队合作</h2>\n<p>1、在github上添加项目的别的成员，成员2</p>\n<p>2、成员2 克隆项目到本地</p>\n<pre><code class=\"language-git\">git clone https:#github.com/13836005450/aaabbb.git\n</code></pre>\n<p>3、成员2 提交新功能</p>\n<pre><code class=\"language-git\">git add .\ngit commit -m &quot;新增test2.txt&quot;\ngit push\n</code></pre>\n<p>4、成员1 更新最新代码</p>\n<pre><code class=\"language-git\">git pull\n</code></pre>\n<h2>3. 解决冲突</h2>\n<ul>\n<li>当两个成员同时修改了一个文件时，有可能产生冲突。</li>\n<li>成员2修改代码后push，成员1再次编码时，忘记pull最新代码，也修改了同一个文件后push，就可能会产生冲突。</li>\n<li>冲突解决办法：手动解决，重新commit</li>\n</ul>\n<pre><code class=\"language-git\">git pull\n然后 手动解决冲突\ngit add .\ngit commit -m &quot;解决冲突&quot;\ngit push\n</code></pre>\n<h2>4. 版本回退</h2>\n<p>当出现严重bug时，可以回退到上一版本。</p>\n<pre><code class=\"language-git\"># 查看之前所有的版本-详细版\ngit log\n# 查看之前所有的版本-缩略版\ngit log --pretty=oneline\n# 回退到上一版本\ngit reset --hard HEAD^\n# 根据id回退，id不用写全\ngit reset --hard 93c63b\n# 查看所有提交过的版本\ngit reflog\n</code></pre>\n<h2>5. 分支管理</h2>\n<ul>\n<li>master分支为主分支，为稳定线上版，由项目负责人负责维护</li>\n<li>dev分支为开发分支，开发版，团队提交代码的分支</li>\n<li>本地开发时，从dev分支检出一个自己的分支，在自己的分支上开发具体功能</li>\n<li>功能开发完毕后，再切回dev分支，合并自己的分支代码</li>\n<li>最后push到远端的dev分支上</li>\n<li>删除本地分支</li>\n</ul>\n<pre><code class=\"language-git\"># 查看本地分支\ngit branch\n# 查看远端分支\ngit branch -a\n# 查看各种分支上最新提交的版本\ngit branch -va\n</code></pre>\n<pre><code class=\"language-git\"># 创建新分支，并切换\ngit checkout -b dev\n# 创建分支，不切换\ngit branch dev\n# 切换分支\ngit checkout dev\n</code></pre>\n<pre><code class=\"language-git\"># 删除分支\ngit branch -d dev\n# 强行删除分支\ngit branch -D dev\n</code></pre>\n<pre><code class=\"language-git\"># 合并分支\ngit merge dev\n</code></pre>\n<h2><strong>小知识点</strong></h2>\n<p>1、如果vscode的控制台总让输入github的账户密码时，可以使用下面语句，运行一下，重启vscode</p>\n<pre><code class=\"language-git\">git config --global credential.helper store\n</code></pre>\n<p>2、多查看当前工作区的状态、更新代码</p>\n<pre><code class=\"language-git\"># 查看状态\ngit status\n# 更新代码\ngit pull\n</code></pre>\n<p>3、如果远端没有本地新建的分支，push的时候，可以使用这个语句</p>\n<pre><code class=\"language-git\">git push --set-upstream origin dev\n</code></pre>\n<p>4、撤回刚刚的commit，保留代码</p>\n<pre><code class=\"language-git\"># 直接变成了未add的状态\ngit reset HEAD~\n</code></pre>\n<p>5、撤回刚刚的add</p>\n<pre><code class=\"language-git\"># 全部撤回\ngit reset HEAD\n# 撤回某个单独的文件\ngit reset .\\test1.txt\n# 撤回整个文件夹的内容\ngit reset .\\aaaaa\\\n</code></pre>\n<p>6、突然需要切换分支，但是当前分支的代码还没写完，可以暂存一下</p>\n<pre><code class=\"language-git\"># 保存当前变化的代码\ngit stash\n# 查看隐藏的stash\ngit stash list\n# 恢复之前的代码，并删除stash list栈中暂存的地址\ngit stash pop\n</code></pre>\n<p>7、删除远端的分支</p>\n<pre><code class=\"language-git\">git push origin -d cheny\n</code></pre>\n<p>8、更新远程所有分支</p>\n<pre><code class=\"language-git\">git remote update origin --prune\n</code></pre>\n<p>9、以远程分支为准，新建本地分支</p>\n<pre><code class=\"language-git\">git checkout -b dev origin/dev\n</code></pre>\n<p>10、非常霸道的push（慎用）</p>\n<pre><code class=\"language-git\"># 会以本地的为准，强行覆盖远端的代码，可能会造成团队别的成员版本高于远程版本，pull不下来代码，如果他们push，会以他们的版本为准。容易被枪决！！！\n\ngit push -f\n</code></pre>\n<p>11、撤销当前的commit</p>\n<pre><code class=\"language-git\"># --soft只是将commit回滚到没有commit前的状态\ngit reset --soft HEAD^\n</code></pre>\n<p>12、撤销add</p>\n<pre><code class=\"language-git\">git reset\n</code></pre>\n', '2021-10-15 15:11:02', '2021-12-09 21:43:50');
INSERT INTO `t_blog` VALUES ('0fd5ab30-5f01-11ec-b395-6d1b1a7579ec', '重建二叉树', 'JZ7 重建二叉树', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 3, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171119516.png\" alt=\"image-20211217111931417\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171119036.png\" alt=\"image-20211217111955982\" /></p>\n<h2>代码</h2>\n<h3>代码1 使用递归，根据前序的根，从中序中确定左右子树，然后继续分解</h3>\n<pre><code class=\"language-js\">/*\n已知前序（根左右）序列和中序（左根右）序列，可以唯一确定一棵二叉树\n1. 根据前序序列第一个节点确定根节点\n2. 根据根节点在中序序列中的位置分割出左右两个子序列\n3. 对左子树和右子树分别递归使用同样的方法继续分解\n\n例如：\n前序序列{1,2,4,7,3,5,6,8} = pre\n中序序列{4,7,2,1,5,3,8,6} = vin\n1. 根据前序序列的第一个节点可知根节点为 1\n2. 找到1在中序序列中的位置，为vin[3]\n3. 切割左右子树，则 vin[3]的前边为左子树， in[3]的后边为右子树\n4. 切割后的左子树的前序序列为{2,4,7} 切割后的左子树的中序序列为{4,7,2}\n    切割后的右子树的前序序列为{3,5,6,8} 切割后的右子树的中序序列为{5,3,8,6}\n5. 对子树分别使用同样的方法分解\n*/\nfunction reConstructBinaryTree(pre, vin)\n{\n    if(pre.length === 0 || vin.lengh ==0) return null\n    \n    // 前序序列的第一个节点为根节点，构造根节点\n    let root = new TreeNode(pre[0])\n    \n    // 在中序中找到前序的根\n    for(let i = 0; i &lt; vin.length;i++){\n        if(vin[i] === pre[0]){\n            // 获得左子树，注意这里的区间。\n            // 如果在中序序列中的 i=3 比如 (4 7 2) 1 (5 3 8 6)，说明左子树有3个节点\n            // 所以在找到左子树当前对应的前序序列时 从前序序列截取出来 就是 pre.slice(1,4)也即(i+1)\n            root.left = reConstructBinaryTree(pre.slice(1,i+1), vin.slice(0,i))\n            // 获得右子树\n            root.right = reConstructBinaryTree(pre.slice(i+1), vin.slice(i+1))\n            break\n        }\n    }\n    return root\n}\n</code></pre>\n<p>时间复杂度O(n)</p>\n<p>空间复杂度O(n)</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=23282&amp;ru=/practice/57aa0bab91884a10b5136ca2c087f8ff&amp;qru=/ta/coding-interviews/question-ranking\">JZ7 重建二叉树</a></p>\n', '2021-12-17 14:17:50', '2021-12-17 14:17:50');
INSERT INTO `t_blog` VALUES ('100002f0-5db6-11ec-b395-6d1b1a7579ec', '删除链表中重复的结点', 'JZ76 删除链表中重复的结点', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 2, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112152231829.png\" alt=\"image-20211215223128742\" /></p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：\n{1,2,3,3,4,4,5}\n返回值：\n{1,2,5}\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：\n{1,1,1,8}\n返回值：\n{8}\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 使用set暴力解法</h3>\n<pre><code class=\"language-js\">/*\n因为是删除重复的项，所以使用个set\n1. 先遍历单链表相邻的元素，如果相等，就加入到set中\n2. 遍历完一遍后，再重新遍历一遍开始删除\n3. pre指向前一个节点，current指向当前节点\n3. 若果current在set中，就pre.next = current.next\n4. 否则就不是重复值，pre = pre.next, current= current.next\n*/\nfunction deleteDuplication(pHead)\n{\n    if(!pHead) return null\n    \n    let set = new Set() // 用来存储重复的值\n   \n    let dummy = new ListNode(-1) // 虚拟节点\n    dummy.next = pHead\n    let p1 = dummy\n    let p2 = dummy.next\n    \n    // 第一遍遍历，找相邻重复的值\n    while(p2){\n        p2 = p2.next\n        p1 = p1.next\n        // 如果p2不是null，没有到头\n        // 且 p1 和 p2 相等\n        if(p2!==null &amp;&amp; p2.val === p1.val){\n            set.add(p2.val) // 把重复的值保存到set中\n        }\n    }\n    \n    // 第二遍遍历，删除重复的值\n    let pre = dummy\n    let current = dummy.next\n    \n    while(current){\n        if(set.has(current.val)){ // 若果在set中发现这个是重复的值，直接删除\n            // 直接删除\n            current = current.next\n            pre.next = current\n        }else { // 若果发现不是重复的值，就继续往下走\n            current = current.next\n            pre = pre.next\n        }\n    }\n    \n    return dummy.next\n}\n</code></pre>\n<h3>代码2  直接删除</h3>\n<pre><code class=\"language-js\">/*\n1. 查看当前节点是否与下一节点相等\n2. 如果相等，就继续往下查找，查找同样值的最大长度，然后改变指针指向，删除节点\n*/\nfunction deleteDuplication(pHead)\n{\n    // write code here\n    let dummy = new ListNode(-1) // 虚拟头结点\n    dummy.next = pHead\n    \n    let pre = dummy\n    let current = pHead\n    \n    while(current){\n        // 找相邻的两个值是否相等\n        if(current.next &amp;&amp; current.val === current.next.val){// 当相等时\n            current = current.next\n            // 当相等时 继续往下找，找到最大长度的相等值，然后改变指针指向\n            while(current.next &amp;&amp; current.val === current.next.val){\n                current = current.next\n            }\n            // 开始删除\n            current = current.next\n            pre.next = current\n        }else { // 当不相等时\n            current = current.next\n            pre = pre.next\n        }\n    }\n    \n    return dummy.next\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&amp;tqId=23450&amp;ru=/practice/f836b2c43afc4b35ad6adc41ec941dba&amp;qru=/ta/coding-interviews/question-ranking\">JZ76 删除链表中重复的结点</a></p>\n', '2021-12-15 22:48:27', '2021-12-15 22:48:27');
INSERT INTO `t_blog` VALUES ('110ef950-5e63-11ec-b395-6d1b1a7579ec', '按之字形顺序打印二叉树', 'JZ77 按之字形顺序打印二叉树', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 3, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112161919997.png\" alt=\"image-20211216191958919\" /></p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：\n{1,2,3,#,#,4,5}\n返回值：\n[[1],[3,2],[4,5]]\n说明：\n如题面解释，第一层是根节点，从左到右打印结果，第二层从右到左，第三层从左到右。\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：\n{8,6,10,5,7,9,11}\n返回值：\n[[8],[10,6],[5,7,9,11]]\n</code></pre>\n<p>示例3</p>\n<pre><code class=\"language-js\">输入：\n{1,2,3,4,5}\n返回值：\n[[1],[3,2],[4,5]]\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 层次遍历（使用队列辅助）</h3>\n<pre><code class=\"language-js\">/*\n使用层次遍历，\n奇数层从左到右\n偶数层从右到左\n*/\nfunction Print(pRoot)\n{\n    if(!pRoot) return []\n    \n    // 层次遍历，需要一个队列辅助，使用js的数组模拟\n    let queue = []\n    \n    // 根节点入队\n    queue.push(pRoot)\n    \n    let layer = 0 // 当前层数，默认为0\n    \n    let resultArr = [] // 最终输出的结果\n    \n    /*\n    开始层次遍历\n    1. 挨个遍历队列中当前层的节点，出队（先入先出原则）\n    2. 依次把下一层的节点入队\n    3. 循环1，2\n    */ \n    while(queue.length &gt; 0) {\n        // 获取当前队列的长度（当前层的总结点数）\n        let size = queue.length\n        \n        let thisLayerArr = [] // 当前层输出的结果\n        \n        // 开始遍历本层节点\n        while(size!==0){\n            // 出队（先入先出）\n            let currentNode = queue.shift()\n            \n            // 入队下一层的节点\n            if(currentNode.left){\n                queue.push(currentNode.left)\n            }\n            if(currentNode.right){\n                queue.push(currentNode.right)\n            }\n            \n            // 如果当前层为偶数 0 2 4，因为这里layer默认为0，所以0的时候从左向右输出\n            if(layer%2==0){\n                thisLayerArr.push(currentNode.val)\n            }else { // 为奇数层 1 3 5\n                thisLayerArr.unshift(currentNode.val)\n            }\n            \n            \n            // 本层节点数减一，当size为0时，表示该层遍历完毕\n            size--\n        }\n        \n        // 每次遍历一层后 layer++\n        layer++\n        \n        // 把本层的结果保存到最终结果数组中\n        resultArr.push(thisLayerArr)\n    }\n    \n    return resultArr\n    \n}\n</code></pre>\n<p>时间复杂度O(n)：n为遍历的节点总数</p>\n<p>空间复杂度O(n)：队列占用的空间</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=13&amp;tqId=23454&amp;ru=/practice/435fb86331474282a3499955f0a41e8b&amp;qru=/ta/coding-interviews/question-ranking\">JZ77 按之字形顺序打印二叉树</a></p>\n', '2021-12-16 19:26:52', '2021-12-16 19:26:52');
INSERT INTO `t_blog` VALUES ('13dd83a0-410c-11ec-94eb-3706a2e7018e', 'setTimeout 4ms延迟（科普）', '科普下为什么嵌套的setTimeout从第五级开始，最少会有4ms的延迟', '-1', 2, 'https://zhuanlan.zhihu.com/p/155752686', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 6, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>在前端技术圈子里面，对于 <code>setTimeout</code> 常常有一句结论，“<code>setTimeout</code> 的最小设置延迟是 4ms”。</p>\n<p>执行下面的代码，你会看到，设置为<code>0ms</code>延迟的的<code>setTimeout</code>，在嵌套的层级大于4级之后（也就是从第5级开始），每次实际的延迟都会大于等于4ms。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111091100507.png\" alt=\"setTimeout 4ms延迟\" /></p>\n<p>为什么会有这个规定呢？得追溯到远古时代，从操作系统的层面来看。</p>\n<h2>timeout的发展史</h2>\n<p>让我们先深入到操作系统的层面，windows 默认情况下的 timer resolution 是 <code>10-15.6ms</code>(这里你可以理解为 timer 的颗粒度)，也就是说最开始浏览器的 timer 依赖于操作系统层面的 timer resolution。换到 <code>setTimeout</code> 当中来讲，设定的最小延迟至少会是 <code>10ms</code>。但是从 CPU 性能来讲，处理器的速度已经从 1995 年的 500HZ 提升到 3GHZ 以上(2010年已经达到了)，而 windows 的默认 timer 却没有变化，仍然保持着原来的 <code>10-15.6ms</code>（这里你会看到浏览器厂商和操作系统厂商在不同角度下的思考）。浏览器厂商（chrome）认为默认计时器影响了网页的表达（ <code>10-15.6ms</code> 时间过于长）。对于浏览器内部来讲，如果 clock tick 很长，意味着浏览器会休眠很长的时间，从某一方面导致浏览器的性能下降。</p>\n<p>上面的解释告诉我们一个既定事实，最开始 window 下的所有浏览器的 timer 的实现都依赖于操作系统的 timer，也就是 <code>10-15.6ms</code>。实际的测试结果可以从 Erik Kay 的视觉排序测试和 John Resign（大名鼎鼎的 JQuery 的作者，你会发现大佬对底层都有自己的理解）的快速测试方案看到，<a href=\"https://link.zhihu.com/?target=https%3A//johnresig.com/blog/accuracy-of-javascript-time/\">具体 John Resign 在 2008 年的文章</a>。</p>\n<p>chrome 对于 <code>10-15.6ms</code> 的 timer 非常在意。我们知道，chrome 目的是高性能的现代浏览器，具体到 timer resolution，其希望量级达到亚毫米级别(小于 1ms)。因此，chrome 团队希望改变浏览器对于操作系统 timer 的依赖，其在 windows 和 linux/unix 系统下采用了不同的方案来达到其目的。linux/unix 有专门的 API 可以修改系统默认的 timer resolution，而在 windows 下就显得有点麻烦，最后 chromium 团队选取了和 Flash 和 Quicktime 同样的 API 来替代系统默认的 timer resolution。</p>\n<p>在修改了 OS 默认的 timer resolution之后，chrome 的性能有了很大的提升。具体到 chrome 1.0 beta 版本，timer resolution 设置的是 <code>1ms</code>（已经比较接近其团队期望）。可能有人会奇怪，既然追求低延迟，为什么不直接设置为 <code>0ms</code> 呢？</p>\n<p>其原因在于如果浏览器允许 <code>0ms</code>，会导致 JavaScript 引擎过度循环，也就是说如果浏览器架构是单进程的，那么可能网站很容易无响应。因为浏览器本身也是建立在 event loop 之上的，如果速度很慢的 JavaScript engine 通过 0ms timer 不断安排唤醒系统，那么 event loop 就会被阻塞。那么此时用户会面对什么情况呢？同时遇到 CPU spinning 和基本挂起的浏览器，想想就让人崩溃。如果一个浏览器经常让用户体验到这种情况，绝对没人愿意用的，毕竟很少有人愿意受虐。这也是为什么 chrome 1.0 beta 设置的是 <code>1ms</code>。</p>\n<p>看起来结果都非常不错，但是随后部分团队有 bug 报告（具体指的是两个，一个是前面说的纽约时报的网站 bug，另外一个就是英特尔团队发现的 chrome 不正常的电量消耗）。其发现 timer 导致 CPU spining，而 CPU spinning 的后果是计算机没有办法进入睡眠模式（低功耗模式），也就是耗电非常的快。因此，chrome 团队不得不解决现实问题（另外是由于当时 chrome 市场份额也没有如今这么大，所以不敢过于托大）。当时 chrome 团队的方案是对 timer 设置了很多的限制。后来，经过 chrome 团队的一些实验，发现将 <code>1ms</code> 提升到 <code>4ms</code>，在大部分机器上好像没有了 CPU spinning 和过于耗电的问题。在这种 tradeoff 的情况下达到了 chrome 团队的目标，更加精确的计时器，并且也没有产生更多的问题。</p>\n<p>说句题外话，其实在最开始，chrome 团队是有和 windows 团队进行过沟通的，希望 windows 能够提供动态调整硬件 clock tick interval 的功能来匹配上层应用程序的需求，但是沟通的结果并不是那么的好。这个可以从 Microsoft 曾今的一个演讲中理解到为什么其不愿意做出这样的改变，在演讲中，他们希望未来的 OS 能够为上层应用程序进行强制的较低唤醒速率（100ms）来减少很多行为不当的程序。也就是 chrome 团队的期望和 windows 团队的期望是有冲突的。到这里，我们就会理解到不同团队对同一个事物不同的考虑。</p>\n<p>随着 Chrome 团队对于 timer 的调整之后（性能提高很多），其他主流浏览器比如（Safari、opera、firefox、IE）都采用了 <code>4ms</code> 的设定，并且不同浏览器会进行不同条件的计时器节流（也就是最开始我们不同浏览器测试会不同结果的原因）。随后 HTML standard 才进行了相关规范的设定。</p>\n<p>其实，timer resolution 并不是一个经常被讨论的主题（因为需要很多基础知识，又偏向于底层），但实际上 timer resolution 一直在不断地发展。</p>\n<p>正如 Nicholas C.Zakas 在他的一篇文章提到，“We’re getting closer to the point of having per-millisecond control of the browser. When someone figures out how to manage timers without CPU interrupts, we’re likely to see timer resolution drop again. Until then, keep 4ms in mind, but remember that you still won’t always get that.”</p>\n<h2>总结</h2>\n<p>不同浏览器的最低时延会不一致，比如 chrome 的最低时延是 <code>1ms</code>。而如果 timer 嵌套层级很多，那么最低时延是 <code>4ms</code>。具体嵌套层级的阈值不同浏览器也不一致，HTML Standard 当中是 <code>&gt;5</code>，chrome 当中是 <code>&gt;=5</code>。</p>\n<h2>参考</h2>\n<p><a href=\"https://zhuanlan.zhihu.com/p/155752686\">https://zhuanlan.zhihu.com/p/155752686</a></p>\n', '2021-11-09 11:21:07', '2021-11-09 11:22:14');
INSERT INTO `t_blog` VALUES ('16796530-60be-11ec-b395-6d1b1a7579ec', '二叉搜索树的最近公共祖先', 'JZ68 二叉搜索树的最近公共祖先', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 2, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112191917763.png\" alt=\"image-20211219191733686\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112191917026.png\" alt=\"image-20211219191744984\" /></p>\n<h2>代码</h2>\n<h3>代码1 递归，利用二叉搜索树的特性</h3>\n<pre><code class=\"language-js\">/*\n递归\n*/\nfunction lowestCommonAncestor( root ,  p ,  q ) {\n    // write code here\n    let min = Math.min(p ,  q)\n    let max = Math.max(p ,  q)\n    \n    return dfs(root ,  min ,  max).val\n    \n    function dfs(root ,  min ,  max) {\n        if(root === null) return null // 没找到呢\n        if(root.val === p || root.val === q) return root // 找到了\n        \n        /*\n            // 不是二叉搜索树的递归 如下\n            let lval = dfs(root.left ,  p ,  q)\n            let rval = dfs(root.right ,  p ,  q)\n\n            // 都在左侧时\n            if(rval == null) return lval\n            // 都在右侧时\n            if(lval == null) return rval\n\n            // 否则就是在左右两侧\n            return root\n        */\n        \n        // 因为是二叉搜索树了，可以利用他的特性，左子树小于 根 小于右子树\n        if(root.val &gt; max){ // 比两个值都大时，从左边找\n            return dfs(root.left ,  min ,  max)\n        }else if(root.val &lt; min) {//比两个值都小时，从右边找\n            return dfs(root.right ,  min ,  max)\n        }else { // p q 的值介于中间，就是左右两侧\n            return root\n        }\n    }\n}\n</code></pre>\n<p>时间复杂度O(n)</p>\n<p>空间复杂度O(n)</p>\n<h3>代码2 深度优先遍历 遍历两次 找到路径后 硬解</h3>\n<pre><code class=\"language-js\">/*\n深度优先遍历 分别找到到两个节点的路径\n把路径保存到数组中\n然后两个路径有长有短，只需要遍历短的长度即可，因为路径都是从根节点开始的，最差也会返回一个根节点\n比如 一个路径为 3 5 6\n另一个路径为 3 5 2 7\n一个节点是6，一个节点是7，所以只需比较三次即可\n*/\nfunction lowestCommonAncestor( root ,  p ,  q ) {\n    let arr1 = [] // 保存到达p的路径\n    let arr2 = [] // 保存到达q的路径\n    \n    // 是否找到了这个节点，如果找到了就更新为true，跳出搜索\n    let isFind = false \n    \n    // dfs遍历root，分别找到到达o1和o2的路径信息\n    dfs(root, p, arr1)\n    isFind = false // 重置一下\n    dfs(root, q, arr2)\n    \n    // 开始查找最近的公共父节点，从头开始找\n    let i = 0\n    let result = null // 找到的最近父节点\n    let size = Math.min(arr1.length,arr2.length)\n    \n    while( i &lt; size){ // 倒着找，从倒数第二个开始找\n        if(arr1[i] !== arr2[i]) break;\n        result = arr1[i]\n        i++\n    }\n    \n    return result // 返回最近公共父节点\n    \n    \n    // 深度遍历，找到路径，保存到数组中\n    function dfs(root, o, arr){\n        // 出口，遍历到最后的空节点了\n        if(root === null) return\n        \n        arr.push(root.val)\n        // 如果找到了，更新标识，递归提前返回结果\n        if(root.val === o) {\n            isFind = true\n            return\n        }\n        \n        dfs(root.left, o, arr)\n        if(isFind) return // 如果已经找到了，提前返回\n        dfs(root.right, o, arr)\n        if(isFind) return // 如果已经找到了，提前返回\n        \n        // 如果发生回溯了，路径减一（即：把最后一个塞进去的值pop出去）\n        arr.pop()\n    }\n}\n</code></pre>\n<p>时间复杂度O(n)：两次dfs递归，每次最多递归n次。</p>\n<p>空间复杂度O(n)：两个存储路径的数组和递归的栈内存开销。</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/d9820119321945f588ed6a26f0a6991f?tpId=13&amp;tqId=2290592&amp;ru=/practice/e0cc33a83afe4530bcec46eba3325116&amp;qru=/ta/coding-interviews/question-ranking\">JZ68 二叉搜索树的最近公共祖先</a></p>\n', '2021-12-19 19:23:27', '2021-12-23 12:05:52');
INSERT INTO `t_blog` VALUES ('1910a970-5f1f-11ec-b395-6d1b1a7579ec', '二叉树的先序、中序、后序遍历（代码实现）', '递归实现', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 3, 0, 1, 2, 1, '', '<h2>先序遍历</h2>\n<blockquote>\n<p>先序遍历的访问顺序为：根节点→左节点→右节点（根左右）</p>\n</blockquote>\n<blockquote>\n<p>所以下图的访问顺序为：<code>A B D E C F</code></p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171638206.png\" alt=\"image-20211217163850130\" /></p>\n</blockquote>\n<h3>递归实现</h3>\n<pre><code class=\"language-js\">let result = []\n\n// 先序遍历 递归\nfunction preOrder(tree) {\n    // 终止条件\n    if (!tree) return;\n    \n    // 开始遍历\n    result.push(tree.val) // 根\n    preOrder(tree.left) // 左\n    preOrder(tree.right) // 右\n}\n\n// 测试\npreOrder(A)\nconsole.log(result); // [ \'A\', \'B\', \'D\', \'E\', \'C\', \'F\' ]\n</code></pre>\n<h2>中序遍历</h2>\n<blockquote>\n<p>中序遍历的访问顺序为：左子树→根节点→右子树（左根右）</p>\n<p>所以下图的访问顺序为：<code>D B E A F C</code></p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171703064.png\" alt=\"image-20211217170330000\" /></p>\n</blockquote>\n<h3>递归实现</h3>\n<pre><code class=\"language-js\">let result = []\n\n// 先序遍历 递归\nfunction inOrder(tree) {\n    // 终止条件\n    if (!tree) return;\n\n    // 开始中序遍历 左根右\n    preOrder(tree.left) // 左\n    result.push(tree.val) // 根\n    preOrder(tree.right) // 右\n}\n\n// 测试\npreOrder(A)\nconsole.log(result); // [ \'D\', \'B\', \'E\', \'A\', \'F\', \'C\' ]\n</code></pre>\n<h2>后序遍历</h2>\n<blockquote>\n<p>中序遍历的访问顺序为：左子树→右子树→根节点（左右根）</p>\n<p>所以下图的访问顺序为：<code>D E B F C A</code></p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171728852.png\" alt=\"image-20211217172810791\" /></p>\n</blockquote>\n<h3>递归实现</h3>\n<pre><code class=\"language-js\">let result = []\n\n// 后序遍历 递归\nfunction postOrder(tree) {\n    if (!tree) return;\n\n    // 开始遍历 左右根\n    postOrder(tree.left) // 左\n    postOrder(tree.right) // 右\n    result.push(tree.val) // 根\n\n}\n\n// 测试\npostOrder(A)\nconsole.log(result); // [ \'D\', \'E\', \'B\', \'F\', \'C\', \'A\' ]\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU0ODMyNDk0Mw==&amp;mid=2247487028&amp;idx=1&amp;sn=e06a0cd5760e62890e60e43a279a472b&amp;chksm=fb419d14cc36140257eb220aaeac182287b10c3cab5c803ebd54013ee3fc120d693067c2e960&amp;scene=21#wechat_redirect\">数据结构-6,树</a></p>\n', '2021-12-17 17:52:51', '2021-12-17 17:52:51');
INSERT INTO `t_blog` VALUES ('1d47dc80-3d8b-11ec-97a5-ef78eceb5d73', '评估关键渲染路径的几种方法', '作为每个可靠性能策略的基础，准确的评估和检测必不可少。 无法评估就谈不上优化。本文说明了评估 CRP 性能的不同方法。', '-1', 2, 'https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 20, 0, 1, 2, 1, 'http://api.bnbiye.cn/upload/png/2021-11-05/1de2e3f0-3e4f-11ec-97a5-ef78eceb5d73.png', '<h2>前言</h2>\n<p>作为每个可靠性能策略的基础，准确的评估和检测必不可少。 无法评估就谈不上优化。本文说明了评估 CRP <code>(Critical Rendering Path)关键渲染路径</code>性能的不同方法。</p>\n<ul>\n<li>Lighthouse 方法会对页面运行一系列自动化测试，然后生成关于页面的 CRP 性能的报告。 这一方法对您的浏览器中加载的特定页面的 CRP 性能提供了快速且简单的高级概览，让您可以快速地测试、循环访问和提高其性能。</li>\n<li>Navigation Timing API 方法会捕获<a href=\"https://en.wikipedia.org/wiki/Real_user_monitoring\">真实用户监控 (RUM)</a> 指标。如名称所示，这些指标捕获自真实用户与网站的互动，并为真实的 CRP 性能（您的用户在各种设备和网络状况下的体验）提供了准确的信息。</li>\n</ul>\n<p>通常情况下，最好利用 Lighthouse 发现明显的 CRP 优化机会，然后使用 Navigation Timing API 设置您的代码，以便监控应用在实际使用过程中的性能。</p>\n<h2>使用 Lighthouse 审核页面</h2>\n<p>Lighthouse 是一个网络应用审核工具，可以对特定页面运行一系列测试，然后在汇总报告中显示页面的结果。 您可以将 Lighthouse 作为 Chrome 扩展程序或 NPM 模块运行，这对将 Lighthouse 与持续集成系统集成非常有用。</p>\n<p>请参阅<a href=\"https://developers.google.com/web/tools/lighthouse\">使用 Lighthouse 审核网络应用</a>，开始使用 Lighthouse。</p>\n<p>您将 Lighthouse 作为 Chrome 扩展程序运行时，页面的 CRP 结果将如以下屏幕截图所示。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041856405.png\" alt=\"image-20211104185610314\" /></p>\n<p>请参阅<a href=\"https://developers.google.com/web/tools/lighthouse/audits/critical-request-chains\">关键请求链</a>，了解此审核结果的详细信息。</p>\n<h2>使用 Navigation Timing API 设置您的代码</h2>\n<p>结合使用 Navigation Timing API 和页面加载时发出的其他浏览器事件，您可以捕获并记录任何页面的真实 CRP 性能。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041856072.png\" alt=\"image-20211104185654018\" /></p>\n<p>上图中的每一个标签都对应着浏览器为其加载的每个网页追踪的细粒度时间戳。实际上，在这个具体例子中，我们展示的只是各种不同时间戳的一部分。我们暂且跳过所有与网络有关的时间戳，但在后面的课程中还会做详细介绍。</p>\n<p>那么，这些时间戳有什么含义呢？</p>\n<ul>\n<li><code>domLoading</code>: 这是整个过程的起始时间戳，浏览器即将开始解析第一批收到的 HTML 文档字节。</li>\n<li><code>domInteractive</code>: 表示浏览器完成对所有 HTML 的解析并且 DOM 构建完成的时间点。</li>\n<li><code>domContentLoaded</code>: 表示 DOM 准备就绪并且没有样式表阻止 JavaScript 执行的时间点，这意味着现在我们可以构建渲染树了。\n<ul>\n<li>许多 JavaScript 框架都会等待此事件发生后，才开始执行它们自己的逻辑。因此，浏览器会捕获<code>EventStart</code> 和<code>EventEnd</code> 时间戳，让我们能够追踪执行所花费的时间。</li>\n</ul>\n</li>\n<li><code>domComplete</code>: 顾名思义，所有处理完成，并且网页上的所有资源（图像等）都已下载完毕，也就是说，加载转环已停止旋转。</li>\n<li><code>loadEvent</code>: 作为每个网页加载的最后一步，浏览器会触发<code>onload</code> 事件，以便触发额外的应用逻辑。</li>\n</ul>\n<p>HTML 规范中规定了每个事件的具体条件: 应在何时触发、应满足什么条件等等。对我们而言，我们将重点放在与关键渲染路径有关的几个关键里程碑上:</p>\n<ul>\n<li><code>domInteractive</code> 表示 DOM 准备就绪的时间点。</li>\n<li><code>domContentLoaded</code> 一般表示<a href=\"http://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/\">DOM 和 CSSOM 均准备就绪</a>的时间点。\n<ul>\n<li>如果没有阻塞解析器的 JavaScript，则<code>DOMContentLoaded</code> 将在<code>domInteractive</code> 后立即触发。</li>\n</ul>\n</li>\n<li><code>domComplete</code> 表示网页及其所有子资源都准备就绪的时间点。</li>\n</ul>\n<p>这里给个图（自己理解上述内容后画的，加深一下印象）</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111052257965.png\" alt=\"浏览器首屏渲染流程\" /><br />\n分析如下：</p>\n<ol>\n<li>\n<p>首先主线程发起请求，去获取HTML文本资源。</p>\n</li>\n<li>\n<p>获取到HTML资源后，交给GUI引擎解析。</p>\n</li>\n<li>\n<p>解析过程中，遇到了<code>&lt;link href=&quot;xxx.css&gt;</code>标签，先暂停解析，将控制权交由主线程。因为CSS文件会影响页面样式，所以GUI引擎在生成CSSDOM树之前，如果遇到未加载的CSS文件时，会暂停解析（也就是我们常说的CSS文件会阻塞页面加载）</p>\n</li>\n<li>\n<p>主线程发起请求，获取CSS文本资源。</p>\n</li>\n<li>\n<p>获取完毕后，GUI引擎继续解析，遇到了<code>&lt;script src=&quot;xxx.js&quot;&gt;</code>，先暂停解析，将控制权交由主线程。因为浏览器中的JS文件中有可能会操作DOM或者改变CSS样式，所以GUI引擎在生成DOM树和CSSDOM树之前，如果遇到未加载的JS文件时，也会暂停解析（也就是我们常说的JS文件会阻塞页面加载）。</p>\n</li>\n<li>\n<p>主线程发起请求，获取JS文本资源。</p>\n</li>\n<li>\n<p>控制权交由JavaScript引擎，执行加载完成的JS文件。</p>\n</li>\n<li>\n<p>GUI引擎继续解析，遇到了<code>&lt;img src=&quot;http://xxx.png&quot;&gt;</code>标签，因为此刻的DOM树和CSSDOM树均未生成，浏览器会先抑制图片的onLoad事件，将该任务先放到任务队列中先不执行。即先不请求资源，等DOM 和 CSSOM 均准备完成后，再去请求（即图片资源并不会阻止DOM树和CSSDOM树的生成）。</p>\n<blockquote>\n<p>tip：虽然图片不会阻止DOM树和CSSDOM树的生成，但是会阻碍页面onLoad回调的触发时机，因为在触发页面的onLoad回调之前，需先触发domComplete回调，而domComplete回调触发即代表页面的所有资源都已请求完成，包括图片资源，所以图片资源假如没有请求完成时，会影响到onLoad回调触发的时机，并且很有可能在onLoad的回调中，也有处理DOM的操作，所以整体上看也会影响到页面的渲染，最好也做个优化，比如图片懒加载。</p>\n</blockquote>\n</li>\n<li>\n<p>HTML文件解析完毕，GUI引擎生成DOM树。</p>\n</li>\n<li>\n<p>GUI引擎生成CSSDOM树。</p>\n<blockquote>\n<p>tip：如果没有阻塞解析器的 JavaScript，则<code>DOMContentLoaded</code> 将在<code>domInteractive</code> 后立即触发。 即：生成DOM树后立即生成CSSDOM树</p>\n</blockquote>\n</li>\n<li>\n<p>GUI引擎根据DOM树和CSSDOM树生成渲染树。</p>\n</li>\n<li>\n<p>GUI引擎根据渲染树，开始布局（Layout），即计算元素的几何位置。</p>\n</li>\n<li>\n<p>GUI引擎开始绘制（Paint），将元素绘制到浏览器。</p>\n</li>\n<li>\n<p>在触发<code>domComplete</code>回调之前，发先任务队列有未加载的图片，JavaScript引擎执行加载图片回调</p>\n</li>\n<li>\n<p>主线程发起请求，加载图片资源（这时表示，所有资源都请求完毕，触发domComplete回调）</p>\n</li>\n<li>\n<p>浏览器加载的最后一步，JavaScript引擎触发页面的onLoad回调（以便触发额外的应用逻辑）。</p>\n</li>\n</ol>\n<h2>例子</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Critical Path: Measure&lt;/title&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;script&gt;\n      function measureCRP() {\n        var t = window.performance.timing,\n          interactive = t.domInteractive - t.domLoading,\n          dcl = t.domContentLoadedEventStart - t.domLoading,\n          complete = t.domComplete - t.domLoading;\n        var stats = document.createElement(\'p\');\n        stats.textContent = \'interactive: \' + interactive + \'ms, \' +\n            \'dcl: \' + dcl + \'ms, complete: \' + complete + \'ms\';\n        document.body.appendChild(stats);\n      }\n    &lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body onload=&quot;measureCRP()&quot;&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>上面的例子乍一看可能有点晕，但实际上也挺简单。Navigation Timing API 捕获所有相关时间戳，而我们的代码只是等待 <code>onload</code> 事件触发 - 回想一下，<code>onload</code> 事件在<code>domInteractive</code>、<code>domContentLoaded</code> 和 <code>domComplete</code> 之后触发 - 然后计算各个时间戳之间的间隔。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041903240.png\" alt=\"image-20211104190308160\" /></p>\n<p>完成了所有该做的工作，我们现在知道了需要追踪哪些具体的里程碑，以及用于输出这些评估的简单功能。请注意，除了将这些评估结果显示在网页上，您还可以修改代码，将这些评估结果发送到分析服务器上（<a href=\"https://support.google.com/analytics/answer/1205784\">Google Analytics（分析）会自动完成这项工作</a>），这是一种监控网页性能的好方法，可以借此找出哪些网页还需要作出进一步优化。</p>\n<h2>DevTools 怎么样呢？</h2>\n<p>尽管本文档使用 Chrome DevTools 的 Network 面板说明 CRP 概念，DevTools 当前并不非常适合 CRP 评估，因为它没有隔离关键资源的内置机制。运行 <a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp#lighthouse\">Lighthouse</a> 审核来帮助识别此类资源。</p>\n<p>下一节： <a href=\"http://www.bnbiye.cn/#/articleDetail/6f8f8d30-3d8b-11ec-97a5-ef78eceb5d73\">分析关键渲染路径性能</a></p>\n', '2021-11-05 00:20:24', '2021-11-06 11:10:01');
INSERT INTO `t_blog` VALUES ('1f3a9b90-5744-11ec-96d5-7933aca11ca0', '选择（OR）|', '选择是正则表达式中的一个术语，实际上是一个简单的“或”。\n\n在正则表达式中，它用竖线 `|` 表示。它匹配的是左右两边的表达式。', '-1', 2, 'https://zh.javascript.info/regexp-alternation', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 3, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>选择是正则表达式中的一个术语，实际上是一个简单的“或”。</p>\n<p>在正则表达式中，它用竖线 <code>|</code> 表示。</p>\n<p>例如，我们需要找出编程语言：HTML、PHP、Java 或 JavaScript。</p>\n<p>对应的正则表达式为：<code>html|php|java(script)?</code>。</p>\n<h2>一个小例子</h2>\n<pre><code class=\"language-js\">let reg = /html|php|css|java(script)?/gi;\n\nlet str = &quot;First HTML appeared, then CSS, then JavaScript, what is java or php?&quot;;\n\nconsole.log(str.match(reg)); // [ \'HTML\', \'CSS\', \'JavaScript\', \'java\', \'php\' ]\n</code></pre>\n<p>我们已知的一个相似符号 —— 方括号。就允许在许多字符中进行选择，例如 <code>gr[ae]y</code> 匹配 <code>gray</code> 或 <code>grey</code>。</p>\n<p>选择符号并非在字符级别生效，而是在表达式级别。正则表达式 <code>A|B|C</code> 意思是命中 <code>A</code>、<code>B</code> 或 <code>C</code> 其一均可。</p>\n<p>例如：</p>\n<ul>\n<li><code>gr(a|e)y</code> 严格等同 <code>gr[ae]y</code>。</li>\n<li><code>gra|ey</code> 匹配 “gra” or “ey”。</li>\n</ul>\n<p>我们通常用圆括号把模式中的选择部分括起来，像这样 <code>before(XXX|YYY)after</code>。</p>\n<h2>时间正则表达式</h2>\n<p>在之前的章节中有个任务是构建用于查找形如 <code>hh:mm</code> 的时间字符串，例如 <code>12:00</code>。但是简单的 <code>\\d\\d:\\d\\d</code> 过于模糊。它同时匹配 <code>25:99</code>。</p>\n<p>如何构建更优的正则表达式？</p>\n<p>我们可以应用到更多的严格匹配结果中：</p>\n<ul>\n<li>首个匹配数字必须是 <code>0</code> 或 <code>1</code>，同时其后还要跟随任一数字。</li>\n<li>或者是数字 <code>2</code> 之后跟随 <code>[0-3]</code>。</li>\n</ul>\n<p>构建正则表达式：<code>[01]\\d|2[0-3]</code>。</p>\n<p>接着可以添加冒号和分钟的部分。</p>\n<p>分钟的部分必须在 <code>0</code> 到 <code>59</code> 区间，在正则表达式语言中含义为首个匹配数字 <code>[0-5]</code> 其后跟随任一数字 <code>\\d</code>。</p>\n<p>把它们拼接在一起形成最终的模式 <code>[01]\\d|2[0-3]:[0-5]\\d</code>。</p>\n<p>快大功告成了，但仍然存在一个问题。选择符 <code>|</code> 在 <code>[01]\\d</code> 和 <code>2[0-3]:[0-5]\\d</code> 之间。这是错误的，因为它只匹配符号左侧或右侧任一表达式。</p>\n<pre><code class=\"language-js\">let reg = /[01]\\d|2[0-3]:[0-5]\\d/g;\n\n// 左边一半的规则 [01]\\d\nconsole.log(&quot;12&quot;.match(reg)); // [ \'12\' ]\n\n// 右边一半的规则 2[0-3]:[0-5]\\d\nconsole.log(&quot;23:59&quot;.match(reg)); // [ \'23:59\' ]\n</code></pre>\n<p>这个错误相当明显，但也是初学正则表达式的常见错误。</p>\n<p>我们需要添加一个插入语用于匹配时钟：<code>[01]\\d</code> 或 <code>2[0-3]</code>。</p>\n<p>以下为正确版本：</p>\n<pre><code class=\"language-js\">let reg = /([01]\\d|2[0-3]):[0-5]\\d/g;\n\nconsole.log(&quot;00:00 10:10 23:59 25:99 1:2 12&quot;.match(reg)); // [ \'00:00\', \'10:10\', \'23:59\' ]\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>\n<p>正则表达式中的方括号<code>[]</code>匹配的是一个一个的字符，比如：<code>[ab]</code>，表示这个位置可以是<code>a</code>或者是<code>b</code></p>\n</li>\n<li>\n<p>或<code>|</code>运算符匹配的是表达式，，比如：<code>abc|efg</code>，匹配的是左边的<code>abc</code>或者右边的<code>efg</code></p>\n</li>\n<li>\n<p>记住选择运算符最好用括号包裹一下，要不容易出错，比如：</p>\n<pre><code class=\"language-js\">// 假如想匹配的是 abcg 或者 aefg，这么写就会出错\nlet reg = /abc|efg/\n// 上面的表达式只会匹配 abc 或者 efg，因为或运算符匹配的是 表达式\n// 左边的表达式是 abc\n// 右边的表达式是 efg\n// 有一个符合的就会返回结果\n\nlet reg = /a(bc|ef)g/\n// 这样就会匹配到 abcg 或者 aefg 了\n</code></pre>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-alternation\">https://zh.javascript.info/regexp-alternation</a></p>\n', '2021-12-07 17:57:43', '2021-12-07 17:57:43');
INSERT INTO `t_blog` VALUES ('2631d1a0-5cc3-11ec-96d5-7933aca11ca0', '从尾到头打印链表', 'JZ6 从尾到头打印链表', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 2, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p>输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。</p>\n<p>如输入{1,2,3}的链表如下图:</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112141547935.png\" alt=\"image-20211214154726771\" /></p>\n<p>返回一个数组为[3,2,1]</p>\n<p>0 &lt;= 链表长度 &lt;= 10000</p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：{1,2,3}\n返回值：[3,2,1]\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：{67,0,24,58}\n返回值：[58,24,0,67]\n</code></pre>\n<h2>代码</h2>\n<h3>代码1</h3>\n<ol>\n<li>从头部节点开始遍历链表，将每次拿到的值存入一个数组中</li>\n<li>返回翻转后的数组</li>\n</ol>\n<pre><code class=\"language-js\">/*\n1. 从头到尾获取挨个获取val\n2. 把获取到的val保存到数组中\n3. 翻转数组，返回结果\n*/\nfunction printListFromTailToHead(head){\n    let tempArr = []\n    while(head) {\n        tempArr.push(head.val)\n        head = head.next\n    }\n    return tempArr.reverse()\n}\n</code></pre>\n<h3>代码2</h3>\n<ol>\n<li>遍历链表头指针，往一个数组的头部存值，使用<code>unshift</code>方法</li>\n<li>返回这个数组（省略了翻转数组这一步骤）</li>\n</ol>\n<pre><code class=\"language-js\">function printListFromTailToHead(head){\n    let tempArr = []\n    while(head){\n        tempArr.unshift(head.val)\n        head = head.next\n    }\n    return tempArr\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=23278&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\">JZ6 从尾到头打印链表</a></p>\n', '2021-12-14 17:49:37', '2021-12-14 17:51:41');
INSERT INTO `t_blog` VALUES ('276f1d80-5579-11ec-96d5-7933aca11ca0', 'Unicode：修饰符 “u” 和 class \\p {}', 'JavaScript 使用Unicode 编码对字符串进行编码。大多数字符使用 2 个字节编码，但这种方式只能编码最多 65536 个字符。', '-1', 2, 'https://zh.javascript.info/regexp-unicode#unicode-shu-xing-unicodepropertiesp', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 11, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>JavaScript 使用 <a href=\"https://en.wikipedia.org/wiki/Unicode\">Unicode 编码</a> （Unicode encoding）对字符串进行编码。大多数字符使用 2 个字节编码，但这种方式只能编码最多 65536 个字符。</p>\n<p>这个范围不足以对所有可能的字符进行编码，这就是为什么一些罕见的字符使用 4 个字节进行编码，比如 <code>𝒳</code> （数学符号 X）或者 <code>😄</code> （笑脸），一些象形文字等等。</p>\n<h2>Unicode编码</h2>\n<p>以下是一些字符对应的 unicode 编码：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>Unicode</th>\n<th>unicode 中的字节数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>a</td>\n<td><code>0x0061</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td>≈</td>\n<td><code>0x2248</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td>𝒳</td>\n<td><code>0x1d4b3</code></td>\n<td>4</td>\n</tr>\n<tr>\n<td>𝒴</td>\n<td><code>0x1d4b4</code></td>\n<td>4</td>\n</tr>\n<tr>\n<td>😄</td>\n<td><code>0x1f604</code></td>\n<td>4</td>\n</tr>\n</tbody>\n</table>\n<p>所以像 <code>a</code> 和 <code>≈</code> 这样的字符占用 2 个字节，而 <code>𝒳</code>，<code>𝒴</code> 和 <code>😄</code> 的对应编码则更长，它们具有 4 个字节的长度。</p>\n<p>很久以前，当 JavaScript 被发明出来的时候，Unicode 的编码要更加简单：当时并没有 4 个字节长的字符。所以，一部分语言特性在现在仍旧无法对 unicode 进行正确的处理。</p>\n<p>比如 <code>length</code> 认为这里的输入有 2 个字符：</p>\n<pre><code class=\"language-js\">console.log(\'😄\'.length); // 2\nconsole.log(\'𝒳\'.length); // 2\n</code></pre>\n<blockquote>\n<p>科普一下：</p>\n<p>计算机底层存储数据是以二进制的形式，每一位只能是0或者1。</p>\n<p><code>0000 0000</code>，这代表八位的二进制，可以表示的范围为<code>0000 0000 - 1111 1111</code>，也即表示十进制的<code>0 - 255</code>。</p>\n<p><code>0000 0000</code>，可以说它有八位，或者它有八比特，即：1位 = 1 比特（bit）。</p>\n<p>还有一个单位叫字节（byte），也是我们熟悉的大写的<code>B</code>。规定，一个字节由八位的二进制构成，即：1 byte = 8 bit 。</p>\n<p>而JavaScript在编写字符串时，使用的是Unicode编码，大多数字符由2个字节进行编码（所以用二进制表示就是 16位，2byte = 16位），也即 计算机编码一个字符时，</p>\n<p>大多数是16位的二进制，<code>0000 0000 0000 0000 - 1111 1111 1111 1111</code>，可以表示的范围为，<code>0 - 65535 </code>，所以使用两个字节编码字符串的时候，最多能表示出来 65536 种字符，对于现在显然是不够的，所以一些特殊的字符就使用了4个字节来编码。</p>\n<p>所以在上面的例子中，<code>😄.length</code>肉眼看是一个字符，应该输出<code>1</code>，但是却输出了<code>2</code>，就是因为它是使用4个字节编码的。</p>\n</blockquote>\n<p>默认情况下，正则表达式同样把一个 4 个字节的“长字符”当成一对 2 个字节长的字符。正如在字符串中遇到的情况，这将导致一些奇怪的结果。我们将很快在后面的文章中遇到 <a href=\"http://www.bnbiye.cn/#/articleDetail/d94ae140-5648-11ec-96d5-7933aca11ca0\">集合和范围 </a>。</p>\n<p>与字符串有所不同的是，正则表达式有一个修饰符 <code>u</code> 被用以解决此类问题。当一个正则表达式使用这个修饰符后，4 个字节长的字符将被正确地处理。同时也能够用上 Unicode 属性（Unicode property）来进行查找了。我们接下来就来了解这方面的内容。</p>\n<h2>Unicode 属性<code>\\p{}</code></h2>\n<blockquote>\n<p><strong>在 Firefox 和 Edge 中缺乏支持</strong></p>\n<p>尽管 unicode property 从 2018 年以来便作为标准的一部分, 但 unicode 属性在 Firefox (<a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1361876\">bug</a>) 和 Edge (<a href=\"https://github.com/Microsoft/ChakraCore/issues/2969\">bug</a>) 中并没有相应的支持。</p>\n<p>目前 <a href=\"http://xregexp.com/\">XRegExp</a> 这个库提供“扩展”的正则表达式，其中包括对 unicode property 的跨平台支持。</p>\n</blockquote>\n<p>Unicode 中的每一个字符都具有很多的属性。它们描述了一个字符属于哪个“类别”，包含了各种关于字符的信息。</p>\n<p>例如，如果一个字符具有 <code>Letter</code> 属性，这意味着这个字符归属于（任意语言的）一个字母表。而 <code>Number</code> 属性则表示这是一个数字：也许是阿拉伯语，亦或者是中文，等等。</p>\n<p>我们可以查找具有某种属性的字符，写作 <code>\\p{…}</code>。为了顺利使用 <code>\\p{…}</code>，一个正则表达式必须使用修饰符 <code>u</code>。</p>\n<p>举个例子，<code>\\p{Letter}</code> 表示任何语言中的一个字母。我们也可以使用 <code>\\p{L}</code>，因为 <code>L</code> 是 <code>Letter</code> 的一个别名（alias）。对于每种属性而言，几乎都存在对应的缩写别名。</p>\n<p>在下面的例子中 3 种字母将会被查找出：英语、格鲁吉亚语和韩语。</p>\n<p>例子1：</p>\n<pre><code class=\"language-js\">let str = &quot;A ბ ㄱ&quot;;\n\nconsole.log( str.match(/\\p{L}/gu) ); // A,ბ,ㄱ\nconsole.log( str.match(/\\p{L}/g) ); // null（没有匹配的文本，因为没有修饰符“u”）\n</code></pre>\n<p>例子2：</p>\n<pre><code class=\"language-js\">let str = &quot;A1ბ中ㄱa😄&quot;;\n\n// 没有加后缀 u 所以，\\p{L} ბ特殊字符匹配不到\nconsole.log(str.match(/\\w\\d\\p{L}/g)); // null\n\n// 有后缀 u 之后 \\p{L} ბ被匹配了出来\nconsole.log(str.match(/\\w\\d\\p{L}/gu)); // [ \'A1ბ\' ]\n</code></pre>\n<p>以下是主要的字符类别和它们对应的子类别：</p>\n<ol>\n<li>字母（Letter） <code>L</code>:\n<ol>\n<li>小写（lowercase） <code>Ll</code></li>\n<li>修饰（modifier） <code>Lm</code>,</li>\n<li>首字母大写（titlecase） <code>Lt</code>,</li>\n<li>大写（uppercase） <code>Lu</code>,</li>\n<li>其它（other） <code>Lo</code>。</li>\n</ol>\n</li>\n<li>数字（Number） <code>N</code>:\n<ol>\n<li>十进制数字（decimal digit） <code>Nd</code>,</li>\n<li>字母数字（letter number） <code>Nl</code>,</li>\n<li>其它（other） <code>No</code>。</li>\n</ol>\n</li>\n<li>标点符号（Punctuation） <code>P</code>:\n<ol>\n<li>链接符（connector） <code>Pc</code>,</li>\n<li>横杠（dash） <code>Pd</code>,</li>\n<li>起始引用号（initial quote） <code>Pi</code>,</li>\n<li>结束引用号（final quote） <code>Pf</code>,</li>\n<li>开（open） <code>Ps</code>,</li>\n<li>闭（close） <code>Pe</code>,</li>\n<li>其它（other） <code>Po</code>。</li>\n</ol>\n</li>\n<li>标记（Mark） <code>M</code> (accents etc):\n<ol>\n<li>间隔合并（spacing combining） <code>Mc</code>,</li>\n<li>封闭（enclosing） <code>Me</code>,</li>\n<li>非间隔（non-spacing） <code>Mn</code>。</li>\n</ol>\n</li>\n<li>符号（Symbol） <code>S</code>:\n<ol>\n<li>货币（currency） <code>Sc</code>,</li>\n<li>修饰（modifier） <code>Sk</code>,</li>\n<li>数学（math） <code>Sm</code>,</li>\n<li>其它（other） <code>So</code>。</li>\n</ol>\n</li>\n<li>分隔符（Separator） <code>Z</code>:\n<ol>\n<li>行（line） <code>Zl</code>,</li>\n<li>段落（paragraph） <code>Zp</code>,</li>\n<li>空格（space） <code>Zs</code>。</li>\n</ol>\n</li>\n<li>其它（Other） <code>C</code>:\n<ol>\n<li>控制符（control） <code>Cc</code>,</li>\n<li>格式（format） <code>Cf</code>,</li>\n<li>未分配（not assigned） <code>Cn</code>,</li>\n<li>私有（private use） <code>Co</code>,</li>\n<li>代理伪字符（surrogate） <code>Cs</code>。</li>\n</ol>\n</li>\n</ol>\n<p>因此，比如说我们需要小写的字母，就可以写成 <code>\\p{Ll}</code>，标点符号写作 <code>\\p{P}</code> 等等。</p>\n<p>也有其它派生的类别，例如：</p>\n<ul>\n<li><code>Alphabetic</code> (<code>Alpha</code>), 包含了字母 <code>L</code>, 加上字母数字 <code>Nl</code> （例如 Ⅻ – 罗马数字 12），加上一些其它符号 <code>Other_Alphabetic</code> (<code>OAlpha</code>)。</li>\n<li><code>Hex_Digit</code> 包括 16 进制数字 <code>0-9</code>，<code>a-f</code>。</li>\n<li>…等等</li>\n</ul>\n<p>Unicode 支持相当数量的属性，列出整个清单需要占用大量的空间，因此在这里列出相关的链接：</p>\n<ul>\n<li>列出一个字符的所有属性 https://unicode.org/cldr/utility/character.jsp.</li>\n<li>按照属性列出所有的字符 https://unicode.org/cldr/utility/list-unicodeset.jsp.</li>\n<li>属性的对应缩写形式：https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt.</li>\n<li>以文本格式整理的所有 Unicode 字符，包含了所有的属性：https://www.unicode.org/Public/UCD/latest/ucd/.</li>\n</ul>\n<h2>实例</h2>\n<h3>16进制数字</h3>\n<p>举个例子，让我们来查找 16 进制数字，写作 <code>xFF</code> 其中 <code>F</code> 是一个 16 进制的数字（0…9 或者 A…F）。</p>\n<p>一个 16 进制数字可以表示为 <code>\\p{Hex_Digit}</code>：</p>\n<pre><code class=\"language-js\">let regexp = /x\\p{Hex_Digit}\\p{Hex_Digit}/u;\n\nconsole.log(&quot;number: xAF&quot;.match(regexp)); // [ \'xAF\', index: 8, input: \'number: xAF\', groups: undefined ]\n</code></pre>\n<h3>中文字符</h3>\n<p>让我们再来考虑中文字符。</p>\n<p>有一个 unicode 属性 <code>Script</code> （一个书写系统），这个属性可以有一个值：<code>Cyrillic</code>，<code>Greek</code>，<code>Arabic</code>，<code>Han</code> （中文）等等，<a href=\"https://en.wikipedia.org/wiki/Script_(Unicode)\">这里是一个完整的列表</a>。</p>\n<p>为了实现查找一个给定的书写系统中的字符，我们需要使用 <code>Script=&lt;value&gt;</code>，例如对于西里尔字符：<code>\\p{sc=Cyrillic}</code>, 中文字符：<code>\\p{sc=Han}</code>，等等。</p>\n<pre><code class=\"language-js\">let regexp1 = /\\p{sc=Han}/gu; // returns Chinese hieroglyphs\nlet regexp2 = /\\p{sc=Cyrillic}/gu; // returns 西里尔字符 \n\nlet str = `Hello Привет 你好 123_456`;\n\nconsole.log(str.match(regexp1)); // [ \'你\', \'好\' ]\nconsole.log(str.match(regexp2)); // [ \'П\', \'р\', \'и\', \'в\', \'е\', \'т\' ]\n</code></pre>\n<h3>货币</h3>\n<p>表示货币的字符，例如 <code>$</code>，<code>€</code>，<code>¥</code>，具有 unicode 属性 <code>\\p{Currency_Symbol}</code>，缩写为 <code>\\p{Sc}</code>。</p>\n<p>让我们使用这一属性来查找符合“货币，接着是一个数字”的价格文本：</p>\n<pre><code class=\"language-js\">let regexp = /\\p{Sc}\\d/gu;\n\nlet str = `Prices: $2, €1, ¥9`;\n\nconsole.log(str.match(regexp)); // [ \'$2\', \'€1\', \'¥9\' ]\n</code></pre>\n<p>之后，在文章 <a href=\"http://www.bnbiye.cn/#/articleDetail/d427ae30-5677-11ec-96d5-7933aca11ca0\">量词</a> 中我们将会了解如何查找包含很多位的数字。</p>\n<h2>总结</h2>\n<p>修饰符 <code>u</code> 在正则表达式中提供对 Unicode 的支持。</p>\n<p>这意味着两件事：</p>\n<ol>\n<li>4 个字节长的字符被以正确的方式处理：被看成单个的字符，而不是 2 个 2 字节长的字符。</li>\n<li>Unicode 属性可以被用于查找中 <code>\\p{…}</code>。</li>\n</ol>\n<p>有了 unicode 属性我们可以查找给定语言中的词，特殊字符（引用，货币）等等。</p>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-unicode\">https://zh.javascript.info/regexp-unicode</a></p>\n', '2021-12-05 11:12:18', '2021-12-09 10:25:37');
INSERT INTO `t_blog` VALUES ('28792100-359c-11ec-94ec-9def32579e94', '一文读懂vertical-align', 'vertical-align作用 指定元素的垂直对齐方式，只对行内元素有效，就是display的属性为inline、inline-block、inline-table...', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 32, 0, 1, 2, 1, '', '<h2>vertical-align作用</h2>\n<p>指定元素的垂直对齐方式，只对行内元素有效，就是<code>display</code>的属性为<code>inline、inline-block、inline-table</code>，再加一个<code>table-cell (&lt;td&gt;&lt;/td&gt;)</code>的元素，</p>\n<h2>行内元素的几条线和行高</h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/753ce07755c046e6aa0b0ecb89e9b1c6~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211025145903994.png\" /></p>\n<p>图片来自：<a href=\"https://www.zhangxinxu.com/wordpress/2015/06/about-letter-x-of-css/\">https://www.zhangxinxu.com/wordpress/2015/06/about-letter-x-of-css/</a></p>\n<h3>上行线</h3>\n<p>图中的<code>ascent</code></p>\n<p>上行线和盒子最上边的一小块高度是上行线高度<code>ascender height</code></p>\n<h3>下行线</h3>\n<p>图中的<code>descent</code></p>\n<p>下行线和盒子最下边的一小块高度是下行线高度<code>descender height</code></p>\n<h3>基线</h3>\n<p>图中红色的线<code>baseline</code>，也就是字符<code>X</code>的最下边</p>\n<h3>中线</h3>\n<p>图中的 <code>median</code>，也就是x的底部，再往上多一个<code>x-height</code>高度后的那条线。</p>\n<p>大意就是：<code>middle</code>指的是基线往上1/2 <code>&quot;x-height&quot;</code>高度。可以近似脑补成字母<code>x</code>交叉点那个位置。</p>\n<p>由此可见，<code>vertical-align: middle</code>并不是绝对的垂直居中对齐，我们平常看到的<code>middle</code>效果只是一种近似的效果。原因很简单，因为不同的字体，其在行内盒子中的位置是不一样的，比方说’微软雅黑’就是一个字符下沉比较明显的字体，所有字符的位置相比其他字体要偏下一点。要是<code>vertical-align: middle</code>是相对容器中分线对齐，你会发现图标和文字不在一条线上，而相对于字符<code>x</code>的中心位置对齐，我们肉眼看上去就好像和文字居中对齐了。</p>\n<h3>行高 <code>line-height</code></h3>\n<p>最多的说法是两行字符基线与基线之间的距离，其实也是中线与中线之间的距离，也是上行线与上行线之间的距离，想怎么说就怎么说，高度都是一样的</p>\n<p>所以我这样理解：行高是 <code>上行线高度+上行线到下行线之间的高度 +下行线高度</code></p>\n<p>所以，当一个盒子的<code>height=line-height</code>时，文字就会垂直居中显示了</p>\n<p>当行高小于<code>height</code>时，文字就偏上显示，（因为行高不够所以偏上显示）</p>\n<p>当行高大于height时，文字就偏下显示，（因为行高冒了，所以文字就偏下显示）</p>\n<h2>vertical-align属性值</h2>\n<h3>操作表格单元格</h3>\n<p>如果是操作单元格<code>td</code>，表格单元格的值</p>\n<p><code>top</code>：使单元格内边距的上边缘与该行顶部对齐。（就是盒子模型的content的上边缘）</p>\n<p><code>middle</code>：使单元格内边距盒模型在该行内居中对齐。（就是盒子模型的content的中间）</p>\n<p><code>bottom</code>：使单元格内边距的下边缘与该行底部对齐。（就是盒子模型的content的底部）</p>\n<h3>行内元素值</h3>\n<blockquote>\n<p>tip 没有基线的元素，使用外边距的下边缘替代。</p>\n</blockquote>\n<h4>baseline</h4>\n<p>使元素的基线与父元素的基线对齐。</p>\n<h4>sub</h4>\n<p>使元素的基线与父元素的下标基线对齐。</p>\n<h4>super</h4>\n<p>使元素的基线与父元素的上标基线对齐。</p>\n<h4><code>text-top</code></h4>\n<p>使元素的顶部与父元素的字体顶部对齐。</p>\n<h4><code>text-bottom</code></h4>\n<p>使元素的底部与父元素的字体底部对齐。</p>\n<p><code>middle</code></p>\n<p>使元素的中部与父元素的基线加上父元素<code>x-height</code>（译注：<a href=\"https://www.zhangxinxu.com/wordpress/2015/06/about-letter-x-of-css/\">x高度</a>）的一半对齐。</p>\n<h4><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/length\"><code>length</code></a></h4>\n<p>使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。</p>\n<p>1、正值：基线向上移动</p>\n<p>2、负值：基线向下移动</p>\n<h4><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/percentage\"><code>percentage</code></a></h4>\n<p>使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height\"><code>line-height</code></a>属性的百分比。可以是负数。</p>\n<p>1、正值：基线向上移动</p>\n<p>2、负值：基线向下移动</p>\n<h2>例子理解</h2>\n<h3>辨别“行内元素的基线”与“行内元素所在行的基线”</h3>\n<p>1、<strong>行内元素的基线</strong>：就是字母x的下边沿，就是上面讲的<code>红色的线 baseline</code>，元素的基线和下行线之间还留有一定的距离，这些距离是留给那些带尾巴的字母或者是汉字的空间，比如<code>j,y,g</code>等等</p>\n<p>2、<strong>元素所在行的基线</strong>：就是所在行的<strong>基准元素</strong>，对齐时所依据的那条线。把基准元素所在行当作父元素，也就是说，所在行的基线由他的一个子元素--基准元素所决定。</p>\n<p><strong>如果基准元素采用中线对齐，那么所在行的基线就是基准元素的中线，如果基准元素采用顶线对齐，那么所在行的基线就是基准元素的顶线。</strong></p>\n<p>所以，基准元素依据哪条线对齐，父元素的基线就是哪条。</p>\n<p>另外，根据有无vertical-align属性，还可以分为下面三种情况</p>\n<p>（1）全部都没有添加vertical-align时，默认以基准元素的基线对齐。</p>\n<p>（2）基准元素添加vertical-align，同一行的其他inline box 没有添加，这时，就是上面说的情况，如果基准元素采用中线对齐，那么所在行的基线就是基准元素的中线，如果基准元素采用顶线对齐，那么所在行的基线就是基准元素的顶线。</p>\n<p>（3）当基准元素没有添加vertical-align，同一行的其他inline box添加了，这时添加vertical-align属性的inline box 以基准元素的默认的线对齐，代入例子就是，如果其他元素对齐方式改为<code>vertical-align: top</code>，那就对齐基准元素的top线，如果时bottom，就对齐bottom线，以此类推</p>\n<p>（4）基准元素和同一行的其他inline box都添加了<code>vertical-align</code>属性，这其实和第三种情况一样，基准元素因为是最高的那一个，无论怎么对齐，都是一样，位置不变，把整一行撑满了，其他元素就以基准元素的线去对齐，该对中线就对中线，该对上线就对上线，以此类推</p>\n<h3>基准元素</h3>\n<p><strong>同一行中最高的那个inline box就是这一行的基准元素</strong>。</p>\n<p>如果这个inline-box没有文字，则没有基线，默认基线位置为下外边距的边缘处，没有外边距时就是元素的最下边。</p>\n<p>如果有文字，基线就是上面提到的红色线<code>baseline</code>，也即字母<code>x</code>的最下边。</p>\n<h3>父元素基线计算方式</h3>\n<p>默认情况下，行内元素的垂直对齐方式都是以基线对齐</p>\n<ol>\n<li>\n<p>没有文字时，如下图所示</p>\n<ul>\n<li>黄色和绿色都是inline box，默认以这一行的基线对齐</li>\n<li>这一行的基线就是黄色的基线（因为它在这一行最高，也即是这一行的基准元素）</li>\n<li>黄色因为没有文字，默认没有基线，所以以它的下边距的边缘处为基线</li>\n<li>所以绿色框就以黄色块（也即这一行的基准元素）的基线对齐，绿色块本身默认以基线对齐，由于它也是没有文字的inline box，所以默认基线也是它的下边距的最外边缘处。最终就成了如下的布局样式。</li>\n</ul>\n<p>注意，inline-block元素间有空格或是换行会产生间隙，使用<code>font-size: 0;</code>可去除</p>\n</li>\n</ol>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94fe5ebcb15b49cfaee8a1c9d15f45d5~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211025161858917.png\" /></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    .father {\n        width: 300px;\n        border: 1px solid green;\n        font-size: 0;\n    }\n\n    .son1 {\n        display: inline-block;\n        width: 50px;\n        height: 100px;\n        background-color: yellow;\n        margin-bottom: 10px;\n    }\n\n    .son2 {\n        display: inline-block;\n        width: 50px;\n        height: 20px;\n        background-color: blue;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;div class=&quot;son1&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;son2&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e25b921d5974914929386a9a8b37a15~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211025163939676.png\" /></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    .son1 {\n        display: inline-block;\n        width: 50px;\n        height: 100px;\n        background-color: yellow;\n        margin-bottom: 10px;\n    }\n&lt;/style&gt;\n</code></pre>\n<ol start=\"2\">\n<li>有文字时，如下图所示\n<ul>\n<li>黄色和蓝色都是inline box，默认以这一行的基线对齐</li>\n<li>这一行的基线就是黄色的基线（因为它在这一行最高，也即是这一行的基准元素）</li>\n<li>黄色有文字，默认基线为上面说到的字母<code>x</code>的最下边，所以本行的基线就是<code>Son1</code>的基线</li>\n<li>所以绿色框就以黄色块（这一行的基准元素）的基线对齐，默认以基线对齐，因为绿色框也是有文字的，所以默认基线也是文字的基线。最终就成了如下的布局样式。</li>\n</ul>\n</li>\n</ol>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4689faf5227541e5acf1807fd980f7e0~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211025165244833.png\" /></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    .father {\n        width: 300px;\n        border: 1px solid green;\n        color: red;\n    }\n\n    .son1 {\n        display: inline-block;\n        width: 80px;\n        height: 100px;\n        background-color: yellow;\n    }\n\n    .son2 {\n        display: inline-block;\n        width: 80px;\n        height: 20px;\n        background-color: blue;\n    }\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;div class=&quot;son1&quot;&gt;Son1&lt;/div&gt;\n        &lt;div class=&quot;son2&quot;&gt;Son2&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>3、使用<code>vertical-align</code>实现<code>son2</code>垂直居中</p>\n<p>先来看一个效果，如下图，只是在son1增加了一个<code>vertical-align: middle;</code>，但是son2却跑到了中间，这是为什么呢？</p>\n<p>我们还按照上面一步步分析一下：</p>\n<ul>\n<li>son1和son2都是inline box，默认以这一行的基线对齐</li>\n<li>这一行的基准元素是黄色块（因为它最高），黄色块有文字，所以基线就是文字的基线，默认以基线对齐</li>\n<li>但是主动修改了son1（基准元素）的对齐方式<code>vertical-align:middle</code>，所以整行的对齐方式就变为了以son1（基准元素）的中线对齐。</li>\n<li>所以son2的基线就对齐了son1（所在行的基准元素）的中线，就形成了下面的效果。</li>\n</ul>\n<p>实际上，son2并没有完全在中间显示，有点偏上，因为son2的基线就是文字的基线，偏下一点，所以要想实现完全居中的效果，可以在son2上也加一个<code>vertical-align: middle</code></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f6b8faa4fc241b9ac2117c36a47f956~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211025172823184.png\" /></p>\n<h2>实战：使用伪元素和<code>vertical-align: middle</code>实现垂直居中</h2>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n\n    .parent {\n        width: 300px;\n        height: 300px;\n        border: 1px solid red;\n        text-align: center;\n    }\n\n    .child {\n        background: blue;\n        width: 100px;\n        height: 40px;\n        line-height: 40px;\n        color: #fff;\n        display: inline-block;\n        vertical-align: middle;\n    }\n\n    .parent::before {\n        content: \'\';\n        height: 100%;\n        display: inline-block;\n        vertical-align: middle;\n    }\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;parent&quot;&gt;\n        &lt;div class=&quot;child&quot;&gt;child&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/571765652acc4fe39e7312cdc985d628~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211025174754555.png\" /></p>\n<p>分析居中的原理：</p>\n<ul>\n<li>在parent增加了一个after伪元素，相当于这个伪元素和child变为了兄弟关系</li>\n<li>伪元素after设置为inline-block，高度设置为父元素的高度，child也设置为了inline-block</li>\n<li>这时伪元素after和child就变为了处于同一行的inline box</li>\n<li>默认以基准元素（也即伪元素after，因为它比较高）的基线对齐</li>\n<li>因为伪元素设置了<code>vertical-align: middle</code>属性，所以整行就以伪元素的中线对齐</li>\n<li>child因为有字，默认基线就是正常行内元素的基线，因为基线偏下，所以也给child增加一个<code>verticle-align: middle</code></li>\n<li>让child的中线和基准元素的中线对齐，最终就实现了垂直居中的效果</li>\n</ul>\n<p>参考：</p>\n<p><a href=\"https://www.jianshu.com/p/ce7e4a997a2c\">https://www.jianshu.com/p/ce7e4a997a2c</a></p>\n<p><a href=\"https://www.jianshu.com/p/59f31a1704de\">https://www.jianshu.com/p/59f31a1704de</a></p>\n<p><a href=\"https://juejin.cn/post/6844903621327323143#comment\">https://juejin.cn/post/6844903621327323143#comment</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align</a></p>\n<p><a href=\"https://www.zhangxinxu.com/wordpress/2015/06/about-letter-x-of-css/\">https://www.zhangxinxu.com/wordpress/2015/06/about-letter-x-of-css/</a></p>\n', '2021-10-25 22:02:15', '2021-10-26 20:44:49');
INSERT INTO `t_blog` VALUES ('2985aea0-48da-11ec-96d5-7933aca11ca0', 'js中的instanceof', '写代码时，假如有一个实例对象，想去调用它父亲的某个方法，但是我们并不确定它是否属于这个父亲的实例对象时，该怎么做呢？', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 1, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>我们知道js的原型链很长很长，一个对象在访问某个属性或者方法时，如果自己没有，就会去原型链上找，一层一层往上找，直到找到为止，（原型链的相关知识参考上一篇文章，<a href=\"http://www.bnbiye.cn/#/articleDetail/0bbfd760-420e-11ec-96d5-7933aca11ca0\">原型链</a>）。那么当我们在写代码时，假如有一个实例对象，想去调用它父亲的某个方法，但是我们并不确定它是否属于这个父亲的实例对象时，该怎么做呢？比如下面代码：</p>\n<pre><code class=\"language-js\">function Parent() { }\nParent.prototype.sayHi = function () {\n    console.log(\'hello\');\n}\n\nlet son = new Parent() \nson.sayHi() // 假如我们不知道这个son是哪来的，想调用sayHi方法\n</code></pre>\n<p>在上面例子中，我们有个构造方法<code>Parent</code>，它的原型上有个<code>sayHi()</code>方法，有一个实例对象<code>son</code>，假如我们不能确定<code>son</code>对象是不是通过<code>Parent</code>声明出来的，如果想更安全的调用<code>sayHi()</code>方法，可以增加一层判断，使用<code>instanceof</code>，如：</p>\n<pre><code class=\"language-js\">if (son instanceof Parent) { // 使用 instanceof 判断一下\n    son.sayHi()\n}\n</code></pre>\n<h2><code>instanceof</code>的工作原理</h2>\n<blockquote>\n<p><code>A instanceof B</code>，就是顺着<code>A</code>的<code>__proto__</code>往上找，看看能不能找到<code>B.prototype</code>，如果能找到就返回<code>true</code>，如果找不到，就返回<code>false</code>。</p>\n</blockquote>\n<p>借用一个<a href=\"http://www.bnbiye.cn/#/articleDetail/0bbfd760-420e-11ec-96d5-7933aca11ca0\">原型链</a>中的图。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111091631229.png\" alt=\"原型链\" /></p>\n<p>如图中的<code>f2</code>和<code>f1</code></p>\n<pre><code class=\"language-js\">function Foo() { }\nlet f1 = new Foo()\nconsole.log(f1.__proto__ === Foo.prototype); // true\nconsole.log(f1.__proto__.__proto__ === Object.prototype); // true\nconsole.log(f1.__proto__.__proto__.__proto__ === null); // true\n\nconsole.log(f1 instanceof Foo); // true\nconsole.log(f1 instanceof Object); // true\nconsole.log(f1 instanceof null); // TypeError: Right-hand side of \'instanceof\' is not an object\n</code></pre>\n<ol>\n<li>因为<code>f1.__proto__ === Foo.prototype</code>，在<code>f1</code>的原型链上找到了<code>Foo</code>的原型，所以<code>f1 instanceof Foo === true</code></li>\n<li>因为<code>f1.__proto__.__proto__ === Object.prototype</code>，在<code>f1</code>的原型链上找到了<code>Object</code>的原型，所以<code>f1 instanceof Object === true</code></li>\n</ol>\n<blockquote>\n<p>使用<code>typeof null </code>时，虽然返回值是<code>object</code>，但是<code>null</code>实际不是<code>object</code>，这是一个历史遗留问题，<code>null</code>在大多数语言中，被设计成空指针，指向了<code>Ox00</code>。参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</a></p>\n</blockquote>\n<h2>手写一个instanceof</h2>\n<ol>\n<li><code>A instanceof B</code>，方法传入两个参数，A和B</li>\n<li>判断<code>A</code>的<code>__proto__</code>链上能不能找到<code>B.prototype</code></li>\n<li>使用一个<code>while(true)</code>循环，一直往上找</li>\n</ol>\n<pre><code class=\"language-js\">function MyInstanceof(leftValue, rightValue) {\n    let rightPrototype = rightValue.prototype\n    let leftProto = leftValue.__proto__\n\n    while (true) {\n        // 出口\n        if (leftProto === null) {\n            return false\n        }\n\n        if (leftProto === rightPrototype) {\n            return true\n        }\n\n        leftProto = leftProto.__proto__\n    }\n}\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903613584654344#heading-1\">https://juejin.cn/post/6844903613584654344#heading-1</a></p>\n', '2021-11-19 09:43:57', '2021-11-19 09:43:57');
INSERT INTO `t_blog` VALUES ('32b34b70-5da9-11ec-b395-6d1b1a7579ec', '复杂链表的复制', 'JZ35 复杂链表的复制', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 1, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）。 下图是一个含有5个结点的复杂链表。图中实线箭头表示next指针，虚线箭头表示random指针。为简单起见，指向null的指针没有画出。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112152111467.png\" alt=\"image-20211215211111379\" /></p>\n<p>示例:</p>\n<p>输入:{1,2,3,4,5,3,5,#,2,#}</p>\n<p>输出:{1,2,3,4,5,3,5,#,2,#}</p>\n<p>解析:我们将链表分为两段，前半部分{1,2,3,4,5}为ListNode，后半部分{3,5,#,2,#}是随机指针域表示。</p>\n<p>以上示例前半部分可以表示链表为的ListNode:1-&gt;2-&gt;3-&gt;4-&gt;5</p>\n<p>后半部分，3，5，#，2，#分别的表示为</p>\n<p>1的位置指向3，2的位置指向5，3的位置指向null，4的位置指向2，5的位置指向null</p>\n<p>如下图:</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112152111058.png\" alt=\"image-20211215211136011\" /></p>\n<h2>示例</h2>\n<pre><code class=\"language-js\">输入：\n{1,2,3,4,5,3,5,#,2,#}\n返回值：\n{1,2,3,4,5,3,5,#,2,#}\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 使用哈希表（实际就是一个map存储一下映射关系）</h3>\n<pre><code class=\"language-js\">/*\n使用哈希表\n1. 先遍历一遍链表\n2. 按顺序复制链表的每一项\n3. 复制的同时将映射关系存在一个map中\n4. 最后在遍历一遍map，将随机指针指向对应的位置\n*/\nfunction Clone(pHead)\n{\n    // write code here\n    if(!pHead) return null\n    \n    // 定义一个虚拟头节点，用来保存新克隆的链表\n    let dummy = new RandomListNode(-1) \n    let pre = dummy \n    let current = pHead\n    \n    // 定义一个map用来保存老节点与新节点的映射关系\n    let map = new Map()\n    \n    while(current){\n        // 克隆当前节点\n        let cloneNode = new RandomListNode(current.label) \n        // 重新构造链表\n        pre.next = cloneNode\n        \n        // 记录映射关系\n        map.set(current, cloneNode)\n        \n        pre = pre.next\n        current = current.next\n    }\n    // 上面的遍历一遍之后，只复制了next的节点，随机节点并没有复制上\n    \n    \n    // 再遍历一遍map，把每个节点的随机指针附上值\n    // 因为map已经保存了每个克隆节点的映射关系，所以根据映射关系，就能找到对应的random指针\n    // map的key是老节点，value是新节点\n    for(let oldNode of Array.from(map.keys())){\n        let newCloneNode = map.get(oldNode)\n        let newRandom = map.get(oldNode.random)\n        newCloneNode.random = newRandom\n    }\n    \n    return dummy.next\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&amp;tqId=23254&amp;ru=/practice/886370fe658f41b498d40fb34ae76ff9&amp;qru=/ta/coding-interviews/question-ranking\">JZ35 复杂链表的复制</a></p>\n', '2021-12-15 21:16:22', '2021-12-15 21:16:22');
INSERT INTO `t_blog` VALUES ('32ee6610-5f11-11ec-b395-6d1b1a7579ec', '树的子结构', 'JZ26 树的子结构', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 2, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171608492.png\" alt=\"image-20211217160857402\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171609021.png\" alt=\"image-20211217160908964\" /></p>\n<h2>代码</h2>\n<h3>代码1 递归判断</h3>\n<pre><code class=\"language-js\">/*\n基本思路，遍历大树，找到与子结构根节点相同的节点\n然后传入判断函数进行遍历比较\n*/\nfunction HasSubtree(pRoot1, pRoot2)\n{\n    if(!pRoot1 || !pRoot2) return false\n    \n    // \n    if(pRoot1.val === pRoot2.val){\n        if( judge(pRoot1, pRoot2) ){\n            return true\n        }\n    }\n    \n    // 遍历左孩子或者右孩子\n    return HasSubtree(pRoot1.left, pRoot2) || HasSubtree(pRoot1.right, pRoot2)\n    \n    // 判断是否是子结构，返回true或false\n    function judge(root, subTree){\n        // 终止条件\n        if(subTree === null){ // 子树遍历完了，说明全部匹配\n            return true\n        }\n        if(root === null){ // 如果大树遍历完了，表示没有匹配\n            return false\n        }\n        \n        // 遍历它俩，如果相等的话，继续往下比对\n        if(root.val === subTree.val){\n            // 左边和右边都得相等\n            return judge(root.left, subTree.left) &amp;&amp; judge(root.right, subTree.right)\n        }\n        \n        // 如果有不相等的，直接返回\n        return false\n    }\n    \n}\n</code></pre>\n<p>时间复杂度O(MN)：其中 M,N分别为树 pRoot1和 树 pRoot2的节点数量；先序遍历树pRoot1 占用 O(M)，每次调用 dfs(A, B) 判断占用 O(N)。</p>\n<p>空间复杂度O(M)：当树 pRoot1 和树 pRoot2 都退化为链表时，递归调用深度最大。当 M≤N 时，遍历树pRoot1 与递归判断的总递归深度为 M ；当 M&gt;N 时，最差情况为遍历至树pRoot1叶子节点，此时总递归深度为 M。</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=23293&amp;ru=/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6&amp;qru=/ta/coding-interviews/question-ranking\">JZ26 树的子结构</a></p>\n', '2021-12-17 16:13:21', '2021-12-17 16:13:21');
INSERT INTO `t_blog` VALUES ('375e4490-5e67-11ec-b395-6d1b1a7579ec', '二叉搜索树的第k个节点', 'JZ54 二叉搜索树的第k个节点', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 2, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112161952532.png\" alt=\"image-20211216195245450\" /></p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：\n{5,3,7,2,4,6,8},3\n返回值：\n4\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：\n{},1\n返回值：\n-1\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 使用中序遍历（左根右）</h3>\n<pre><code class=\"language-js\">/*\n中序遍历 左根右\n二叉搜索树使用中序遍历后，最终的结果正好是从小到大排列的\n然后找出第K个值即可\n*/\nfunction KthNode( proot ,  k ) {\n    if(!proot || k===0) return -1\n    \n    let resultArr = [] // 中序遍历后保存的值\n    \n    // 中序遍历二叉搜索树，递归\n    function midOrder(root){\n        // 终止条件，遍历到头了\n        if(!root) return\n        \n        // 中序遍历，左根右\n        midOrder(root.left)\n        resultArr.push(root.val)\n        midOrder(root.right)\n    }\n    // 调用一下\n    midOrder(proot)\n    \n    if(resultArr.length &lt; k) return -1\n    return resultArr[k-1]\n}\n</code></pre>\n<p>时间复杂度O(n)：遍历的节点数</p>\n<p>空间复杂度O(n)：递归栈内存占用的空间</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/57aa0bab91884a10b5136ca2c087f8ff?tpId=13&amp;tqId=2305268&amp;ru=/practice/91b69814117f4e8097390d107d2efbe0&amp;qru=/ta/coding-interviews/question-ranking\">JZ54 二叉搜索树的第k个节点</a></p>\n', '2021-12-16 19:56:34', '2021-12-16 19:56:34');
INSERT INTO `t_blog` VALUES ('3c9212f0-3d8a-11ec-97a5-ef78eceb5d73', '构建渲染树', 'CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。', '-1', 2, 'https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 13, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>CSSOM 树和 DOM 树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。优化上述每一个步骤对实现最佳渲染性能至关重要。</p>\n<p>在前面介绍构建对象模型的章节中，我们根据 HTML 和 CSS 输入构建了 DOM 树和 CSSOM 树。 不过，它们都是独立的对象，分别网罗文档不同方面的信息: 一个描述内容，另一个则是描述需要对文档应用的样式规则。我们该如何将两者合并，让浏览器在屏幕上渲染像素呢？</p>\n<h2>构建渲染树流程</h2>\n<ul>\n<li>DOM 树与 CSSOM 树合并后形成渲染树。</li>\n<li>渲染树只包含渲染网页所需的节点。</li>\n<li>布局计算每个对象的精确位置和大小。</li>\n<li>最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。</li>\n</ul>\n<p>第一步是让浏览器将 DOM 和 CSSOM 合并成一个“渲染树”，网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041643745.png\" alt=\"image-20211104164303663\" /></p>\n<p>为构建渲染树，浏览器大体上完成了下列工作:</p>\n<ol>\n<li>从 DOM 树的根节点开始遍历每个可见节点。\n<ul>\n<li>某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。</li>\n<li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，上例中的 span 节点---不会出现在渲染树中，---因为有一个显式规则在该节点上设置了“display: none”属性。</li>\n</ul>\n</li>\n<li>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。</li>\n<li>发射可见节点，连同其内容和计算的样式。</li>\n</ol>\n<blockquote>\n<p><strong>Note:</strong> 简单提一句，请注意 <code>visibility: hidden</code> 与 <code>display: none</code> 是不一样的。前者隐藏元素，但元素仍占据着布局空间（即将其渲染成一个空框），而后者 (<code>display: none</code>) 将元素从渲染树中完全移除，元素既不可见，也不是布局的组成部分。</p>\n</blockquote>\n<h2>布局阶段 Layout</h2>\n<p>最终输出的渲染同时包含了屏幕上的所有可见内容及其样式信息。<strong>有了渲染树，我们就可以进入“布局”阶段。</strong></p>\n<p>到目前为止，我们计算了哪些节点应该是可见的以及它们的计算样式，但我们尚未计算它们在设备<a href=\"https://developers.google.com/web/fundamentals/design-and-ux/responsive#set-the-viewport\">视口</a>内的确切位置和大小---这就是“布局”阶段，也称为“自动重排”。</p>\n<p>为弄清每个对象在网页上的确切大小和位置，浏览器从渲染树的根节点开始进行遍历。让我们考虑下面这样一个简单的实例:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div style=&quot;width: 50%&quot;&gt;\n      &lt;div style=&quot;width: 50%&quot;&gt;Hello world!&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>以上网页的正文包含两个嵌套 div: 第一个（父）div 将节点的显示尺寸设置为视口宽度的 50%，---父 div 包含的第二个 div---将其宽度设置为其父项的 50%；即视口宽度的 25%。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041644402.png\" alt=\"image-20211104164422355\" /></p>\n<p>布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸: 所有相对测量值都转换为屏幕上的绝对像素。</p>\n<h2>绘制阶段 Paint</h2>\n<p>最后，既然我们知道了哪些节点可见、它们的计算样式以及几何信息，我们终于可以将这些信息传递给最后一个阶段: 将渲染树中的每个节点转换成屏幕上的实际像素。这一步通常称为“绘制”或“栅格化”。</p>\n<p>上述步骤都需要浏览器完成大量工作，所以相当耗时。不过，Chrome DevTools 可以帮助我们对上述所有三个阶段进行深入的了解。让我们看一下最初“hello world”示例的布局阶段:</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041644304.png\" alt=\"image-20211104164444258\" /></p>\n<ul>\n<li><code>Layout</code>事件在时间线中捕获渲染树构建以及位置和尺寸计算。</li>\n<li>布局完成后，浏览器会立即发出<code>Paint Setup</code>和<code>Paint</code>事件，将渲染树转换成屏幕上的像素。</li>\n</ul>\n<p>执行渲染树构建、布局和绘制所需的时间将取决于文档大小、应用的样式，以及运行文档的设备: 文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长（例如，单色的绘制开销“较小”，而阴影的计算和渲染开销则要“大得多”）。</p>\n<p>最后将在视口中看到下面的网页:</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041645894.png\" alt=\"image-20211104164507831\" /></p>\n<p>下面简要概述了浏览器完成的步骤:</p>\n<ol>\n<li>处理 HTML 标记并构建 DOM 树。</li>\n<li>处理 CSS 标记并构建 CSSOM 树。</li>\n<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>\n<li>根据渲染树来布局，以计算每个节点的几何信息。</li>\n<li>将各个节点绘制到屏幕上。</li>\n</ol>\n<p>我们的演示网页看起来可能很简单，实际上却需要完成相当多的工作。如果 DOM 或 CSSOM 被修改，您只能再执行一遍以上所有步骤，以确定哪些像素需要在屏幕上进行重新渲染。</p>\n<p><strong><em>优化关键渲染路径</em> 就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间。</strong> 这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。</p>\n<h2>重排（reflow）与重绘（replaint）</h2>\n<p>根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时有两个重要概念：replaint和reflow。</p>\n<p>replaint：屏幕的一部分重绘，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p>\n<p>reflow： 意味着元件的几何尺寸变了，我们需要重新验证并计算渲染树。是渲染树的一部分或全部发生了变化。这就是Reflow，或是Layout。</p>\n<p>所以我们应该尽量减少reflow和replaint，我想这也是为什么现在很少有用table布局的原因之一。</p>\n<p>display:none 会触发 reflow，visibility: hidden属性并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，所以visibility:hidden 只会触发 repaint，因为没有发生位置变化。</p>\n<p>有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批，然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。</p>\n<p>有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。</p>\n<p>下一节： <a href=\"http://www.bnbiye.cn/#/articleDetail/87a08d30-3d8a-11ec-97a5-ef78eceb5d73\">阻塞渲染的CSS</a></p>\n', '2021-11-05 00:14:07', '2021-11-05 16:35:01');
INSERT INTO `t_blog` VALUES ('3cf298f0-5ff9-11ec-b395-6d1b1a7579ec', '对称的二叉树', 'JZ28 对称的二叉树', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 1, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112181929306.png\" alt=\"image-20211218192933217\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112181929723.png\" alt=\"image-20211218192944683\" /></p>\n<h2>代码</h2>\n<h3>代码1 层次遍历的变形，一层一层的比对结果，对于只有一侧的节点，可以增加一个虚拟节点用来匹配对称性</h3>\n<pre><code class=\"language-js\">/*\n层次遍历，比对结果\n使用「层序遍历」的方式进行「逐层检查」，对于空节点使用 placeHolder 进行代指，同时确保不递归 placeHolder 对应的子节点。\n1. 起始时，将 root 节点入队；\n2. 从队列中取出节点，检查节点是否为 placeHolder 节点来决定是否继续入队：\n    2.1 当不是 placeHolder 节点时，将其左/右儿子进行入队，如果没有左/右儿子，则用 placeHolder 代替入队；\n    2.2 当是 placeHolder 节点时，则忽略\n3. 在进行流程  的同时使用「临时列表」记录当前层的信息，并检查当前层是否符合 “对称” 要求；\n4. 循环流程 2 和 3 直到整个队列为空。\n    \n*/\nfunction isSymmetrical(pRoot)\n{\n    if(!pRoot) return true // 空节点默认为对称节点\n    \n    //层次遍历，一层一层的比对\n    let q  = [] // 使用数组模拟队列 先入先出\n    q.push(pRoot) // 入队\n    \n    // 定义一个 占位节点，当某个节点只有左节点或者右节点时，比对的时候在另一侧塞一个占位节点\n    let placeHolder = new TreeNode(\'null\')\n    \n    // 开始层次遍历，变形，不一个一个遍历了，把每一行的数值塞到一个临时数组中，每次校验一行\n    while(q.length &gt; 0){\n        \n        let size = q.length\n        let list = [] // 临时数组，存储本层的数值，判断是否对称\n        \n        while(size &gt; 0){\n            let current = q.shift() // 每次出队一个，使用js的shift方法模拟出队\n            \n            // 如果这个节点是我们临时塞的占位节点，就无需遍历它的下一层了，所以加个判断\n            if(current !== placeHolder){ // 如果不是我们塞的占位节点的话\n                // 遍历下一层\n                q.push(current.left ? current.left : placeHolder) // 如果没有左子树，给塞一个占位节点\n                q.push(current.right ? current.right : placeHolder) // 如果没有右子树，给塞一个占位节点\n            }\n            // 临时数组保存这一层的值\n            list.push(current.val)\n            size--\n        }\n        // 检查当前层是否符合对称要求\n        // 如果本层不符合对称要求，直接返回false\n        if( !check(list) ) return false // 所以当有一层不符合对称的要求，程序直接就终止了，后序的层就不用判断了\n    }\n    \n    return true // 如果每一行都校验通过了，就返回true\n    \n    // 判断 左右两边是否对称\n    function check(list){\n        let i = 0;\n        let j = list.length -1 \n        \n        while(i&lt;j){\n            if(list[i] !== list[j]) return false\n            i++;\n            j--;\n        }\n        \n        return true\n    }\n    \n}\n</code></pre>\n<p>时间复杂度O(n)：时间复杂度：在层序遍历过程中，每个节点最多入队一次，同时在 <code>check</code> 检查对称性过程中，每层只会被检查一次。</p>\n<p>空间复杂度O(n)</p>\n<h3>代码2 递归检测对称性</h3>\n<pre><code class=\"language-js\">/*\n使用递归检测对称性\n如何定义两棵子树 a 和 b 是否 “对称” ？\n当且仅当两棵子树符合如下要求时，满足 “对称” 要求：\n1. 两棵子树根节点值相同；\n2. 两颗子树的左右子树分别对称，包括：\n    2.1 a 树的左子树与 b 树的右子树相应位置的值相等\n    2.2 a 树的右子树与 b 树的左子树相应位置的值相等\n\n*/\nfunction isSymmetrical(pRoot)\n{\n    return check(pRoot, pRoot)\n    \n    function check(root1, root2){\n        // 出口\n        if(root1 === null &amp;&amp; root2 === null) return true  // 两个值都为空，符合对称要求\n        if(root1 === null || root2 === null) return false // 一个值为null 另一个值不为null时，不符合对称要求 返回false\n        if(root1.val !== root2.val) return false // 两个值不相等 不符合对称要求，返回false\n        \n        return check(root1.left, root2.right) &amp;&amp; check(root1.right, root2.left)\n        \n    }\n}\n</code></pre>\n<p>时间复杂度O(n)：每个节点只会被检查一次</p>\n<p>空间复杂度O(n)</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb?tpId=13&amp;tqId=23452&amp;ru=/practice/9023a0c988684a53960365b889ceaf5e&amp;qru=/ta/coding-interviews/question-ranking\">JZ28 对称的二叉树</a></p>\n', '2021-12-18 19:54:21', '2021-12-18 19:54:21');
INSERT INTO `t_blog` VALUES ('3fbc4640-3d89-11ec-97a5-ef78eceb5d73', '构建DOM树和CSSDOM树', '浏览器渲染页面前需要先构建 DOM 和 CSSOM 树,DOM树是如何构建的呢，经历了哪些阶段呢', '-1', 2, 'https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 11, 0, 1, 2, 1, '', '<p>浏览器渲染页面前需要先构建 DOM 和 CSSOM 树。因此，我们需要确保尽快将 HTML 和 CSS 都提供给浏览器。</p>\n<h2>渲染流程</h2>\n<ul>\n<li>字节 → 字符 → 令牌 → 节点 → 对象模型。</li>\n<li>HTML 标记转换成文档对象模型 (DOM)；CSS 标记转换成 CSS 对象模型 (CSSOM)。</li>\n<li>DOM 和 CSSOM 是独立的数据结构。</li>\n<li>Chrome DevTools Timeline 让我们可以捕获和检查 DOM 和 CSSOM 的构建和处理开销。</li>\n</ul>\n<h2>文档对象模型 (DOM)</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;title&gt;Critical Path&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>让我们从可能的最简单情况入手: 一个包含一些文本和一幅图片的普通 HTML 页面。浏览器如何处理此页面？</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041635055.png\" alt=\"image-20211104163530889\" /></p>\n<ol>\n<li><strong>转换:</strong> 浏览器从磁盘或网络读取 HTML 的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。</li>\n<li><strong>令牌化:</strong> 浏览器将字符串转换成<a href=\"http://www.w3.org/TR/html5/\">W3C HTML5 标准</a>规定的各种令牌，例如，<code>&lt;html&gt;</code>、<code>&lt;body&gt;</code>，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。</li>\n<li><strong>词法分析:</strong> 发出的令牌转换成定义其属性和规则的“对象”。</li>\n<li><strong>DOM 构建:</strong> 最后，由于 HTML 标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系:<em>HTML</em> 对象是<em>body</em> 对象的父项，<em>body</em> 是<em>paragraph</em> 对象的父项，依此类推。</li>\n</ol>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041636331.png\" alt=\"image-20211104163650278\" /></p>\n<p><strong>整个流程的最终输出是我们这个简单页面的文档对象模型 (DOM)，浏览器对页面进行的所有进一步处理都会用到它。</strong></p>\n<p>浏览器每次处理 HTML 标记时，都会完成以上所有步骤: 将字节转换成字符，确定令牌，将令牌转换成节点，然后构建 DOM 树。这整个流程可能需要一些时间才能完成，有大量 HTML 需要处理时更是如此。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041637178.png\" alt=\"image-20211104163715136\" /></p>\n<blockquote>\n<p><strong>Note:</strong> 我们假定您对 Chrome DevTools 有着基础程度的熟悉，即您知道如何捕获网络瀑布，或记录时间线。如果您需要快速温习相关内容，请查看 <a href=\"https://developers.google.com/web/tools/chrome-devtools\">Chrome DevTools 文档</a>；</p>\n</blockquote>\n<p>如果您打开 Chrome DevTools 并在页面加载时记录时间线，就可以看到执行该步骤实际花费的时间。在上例中，将一堆 HTML 字节转换成 DOM 树大约需要 5 毫秒。对于较大的页面，这一过程需要的时间可能会显著增加。创建流畅动画时，如果浏览器需要处理大量 HTML，这很容易成为瓶颈。</p>\n<p>DOM 树捕获文档标记的属性和关系，但并未告诉我们元素在渲染后呈现的外观。那是 CSSOM 的责任。</p>\n<h2>CSS 对象模型 (CSSOM)</h2>\n<p>在浏览器构建我们这个简单页面的 DOM 时，在文档的 head 部分遇到了一个 link 标记，该标记引用一个外部 CSS 样式表: style.css。由于预见到需要利用该资源来渲染页面，它会立即发出对该资源的请求，并返回以下内容:</p>\n<pre><code class=\"language-css\">body { font-size: 16px }\np { font-weight: bold }\nspan { color: red }\np span { display: none }\nimg { float: right }\n</code></pre>\n<p>我们本可以直接在 HTML 标记内声明样式（内联），但让 CSS 独立于 HTML 有利于我们将内容和设计作为独立关注点进行处理: 设计人员负责处理 CSS，开发者侧重于 HTML，等等。</p>\n<p>与处理 HTML 时一样，我们需要将收到的 CSS 规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复 HTML 过程，不过是为 CSS 而不是 HTML:</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041639483.png\" alt=\"image-20211104163908446\" /></p>\n<p>CSS 字节转换成字符，接着转换成令牌和节点，最后链接到一个称为“CSS 对象模型”(CSSOM) 的树结构内:</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041639186.png\" alt=\"image-20211104163926142\" /></p>\n<p>CSSOM 为何具有树结构？为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。</p>\n<p>以上面的 CSSOM 树为例进行更具体的阐述。<em>span</em> 标记内包含的任何置于 body 元素内的文本都将具有 16 像素字号，并且颜色为红色 — font-size 指令从 body 向下级联至 span。不过，如果某个 span 标记是某个段落 (p) 标记的子项，则其内容将不会显示。</p>\n<p>还请注意，以上树并非完整的 CSSOM 树，它只显示了我们决定在样式表中替换的样式。每个浏览器都提供一组默认样式（也称为“User Agent 样式”），即我们不提供任何自定义样式时所看到的样式，我们的样式只是替换这些默认样式（例如<a href=\"http://www.iecss.com/\">默认 IE 样式</a>）。</p>\n<p>要了解 CSS 处理所需的时间，您可以在 DevTools 中记录时间线并寻找“Recalculate Style”事件: 与 DOM 解析不同，该时间线不显示单独的“Parse CSS”条目，而是在这一个事件下一同捕获解析和 CSSOM 树构建，以及计算的样式的递归计算。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041639768.png\" alt=\"image-20211104163953723\" /></p>\n<p>我们的小样式表需要大约 0.6 毫秒的处理时间，影响页面上的 8 个元素 — 虽然不多，但同样会产生开销。不过，这 8 个元素从何而来呢？CSSOM 和 DOM 是独立的数据结构！结果证明，浏览器隐藏了一个重要步骤。</p>\n<p>接下来，让我们谈一谈将 DOM 与 CSSOM 关联在一起的<a href=\"http://www.bnbiye.cn/#/articleDetail/3c9212f0-3d8a-11ec-97a5-ef78eceb5d73\">渲染树</a></p>\n', '2021-11-05 00:07:03', '2021-11-05 15:50:41');
INSERT INTO `t_blog` VALUES ('43673d90-5f4e-11ec-b395-6d1b1a7579ec', '二叉树中和为某一值的路径(二)', 'JZ34 二叉树中和为某一值的路径(二)', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 4, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112172324804.png\" alt=\"image-20211217232413713\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112172324658.png\" alt=\"image-20211217232427611\" /></p>\n<h2>代码</h2>\n<h3>代码1 深度优先遍历（DFS）遍历的过程中把路径记录下来</h3>\n<pre><code class=\"language-js\">/*\n深度优先遍历 \nlog(root.val)\ndfs(root.left)\ndfs(root.right)\n1. 遍历，每遍历一个节点，sum就减去val\n2. 当遍历到叶子节点时，sum正好等于零表示，这条路径正确\n3. 使用一个数组存储临时的路径记录\n4. 每次发生回溯时，将临时数组的最后一个值pop出去\n*/\nfunction FindPath(root, expectNumber)\n{\n    if(!root) return []\n    \n    let result = [] // 最终返回的结果\n    let path = [] // 记录遍历的路径\n    // 开始dfs遍历\n    dfs(root, expectNumber)\n    return result\n    \n    // 递归遍历\n    function dfs(root, expectNumber){\n        // 出口\n        if(!root) return; // 到头了\n        \n        path.push(root.val) // 记录遍历路径\n        \n        // 在当前路径，每遍历一个节点就减去一个值，\n        // 当正好等于0时，说明这条路径就是一个结果\n        expectNumber -= root.val \n        \n        // 如果遍历到了叶子节点，且expectNumber正好为0\n        if(!root.left &amp;&amp; !root.right &amp;&amp; expectNumber===0) {\n            // 说明这是个结果，把结果保存起来\n            result.push([...path])\n        }\n        \n        // 递归往下找\n        dfs(root.left, expectNumber)\n        dfs(root.right, expectNumber)\n        \n        // 发生回溯的过程中，把路径的最后一个值pop出去\n        path.pop()\n    }\n}\n</code></pre>\n<p>时间复杂度O(N)：递归遍历的节点个数为N</p>\n<p>空间复杂度O(N)</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/b736e784e3e34731af99065031301bca?tpId=13&amp;tqId=23276&amp;ru=/practice/508378c0823c423baa723ce448cbfd0c&amp;qru=/ta/coding-interviews/question-ranking\">JZ34 二叉树中和为某一值的路径(二)</a></p>\n', '2021-12-17 23:30:28', '2021-12-17 23:30:28');
INSERT INTO `t_blog` VALUES ('46990ae0-54ed-11ec-96d5-7933aca11ca0', '字符类', '正则表达式预设了一些字符类，用于表示一类字符的集合，比如表示`0-9`的数字集合`\\d`等，本节来一起学习一下。', '-1', 2, 'https://zh.javascript.info/regexp-character-classes', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 7, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>正则表达式预设了一些字符类，用于表示一类字符的集合，比如表示<code>0-9</code>的数字集合<code>\\d</code>等，本节来一起学习一下。</p>\n<h2>字符类</h2>\n<p>考虑一个实际的任务 – 我们有一个电话号码，例如 <code>&quot;+7(903)-123-45-67&quot;</code>，我们需要将其转换为纯数字：<code>79031234567</code>。</p>\n<p>为此，我们可以查找并删除所有非数字的内容。字符类可以帮助解决这个问题。</p>\n<p><strong>字符类（Character classes）</strong> 是一个特殊的符号，匹配特定集中的任何符号。</p>\n<p>首先，让我们探索“数字”类。它写为 <code>\\d</code>，对应于“任何一个数字”。</p>\n<p>例如，让我们找到电话号码的第一个数字：</p>\n<pre><code class=\"language-js\">let str = &quot;+7(903)-123-45-67&quot;;\n\nlet regexp = /\\d/;\n\nconsole.log(str.match(regexp)); // [ \'7\', index: 1, input: \'+7(903)-123-45-67\', groups: undefined ]\n</code></pre>\n<p>如果没有标志 <code>g</code>，则正则表达式仅查找第一个匹配项，即第一个数字 <code>\\d</code>。</p>\n<p>让我们添加 <code>g</code>标志来查找所有数字：</p>\n<pre><code class=\"language-js\">let str = &quot;+7(903)-123-45-67&quot;;\n\nlet regexp = /\\d/g;\n\nconsole.log(str.match(regexp));\n/*\n[\n  \'7\', \'9\', \'0\', \'3\',\n  \'1\', \'2\', \'3\', \'4\',\n  \'5\', \'6\', \'7\'\n]\n*/\nconsole.log(str.match(regexp).join(\'\')); // 79031234567\n</code></pre>\n<p>这是数字的字符类。还有其他字符类。</p>\n<p>最常用的是：</p>\n<h3><code>\\d</code>（来自digit）</h3>\n<p>数字：从 <code>0</code> 到 <code>9</code> 的字符。</p>\n<h3><code>\\s</code>（来自space）</h3>\n<p>空格符号：包括空格，制表符 <code>\\t</code>，换行符 <code>\\n</code> 和其他少数稀有字符，例如 <code>\\v</code>，<code>\\f</code> 和 <code>\\r</code>。</p>\n<h3><code>\\w</code>（来自word）</h3>\n<p>“单字”字符：拉丁字母或数字或下划线 <code>_</code>。非拉丁字母（如西里尔字母或印地文）不属于 <code>\\w</code>。</p>\n<blockquote>\n<p>例如，<code>\\d\\s\\w</code>表示“数字”，后跟“空格字符”，后跟“单字字符”，例如 <code>1 a</code>。</p>\n<p><strong>正则表达式可能同时包含常规符号和字符类。</strong></p>\n<p>例如，<code>CSS\\d</code> 匹配字符串 <code>CSS</code> 与后面的数字：</p>\n<pre><code class=\"language-js\">let str = &quot;Is there CSS4?&quot;;\nlet regexp = /CSS\\d/\n\nconsole.log(str.match(regexp)); // [ \'CSS4\', index: 9, input: \'Is there CSS4?\', groups: undefined ]\n</code></pre>\n<p>我们还可以使用许多字符类：</p>\n<pre><code class=\"language-js\">console.log(&quot;I love HTML5!&quot;.match(/\\s\\w\\w\\w\\w\\d/)); // [ \' HTML5\', index: 6, input: \'I love HTML5!\', groups: undefined ]\n</code></pre>\n<p>匹配项（每个正则表达式字符类都有对应的结果字符）：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112041716814.png\" alt=\"image-20211204171645691\" /></p>\n</blockquote>\n<h2>反向类</h2>\n<p>对于每个字符类，都有一个“反向类”，用相同的字母表示，但要以大写书写形式。</p>\n<p>“反向”表示它与所有其他字符匹配，例如：</p>\n<ol>\n<li><code>\\D</code>：非数字：除 <code>\\d</code> 以外的任何字符，例如字母。</li>\n<li><code>\\S</code>：非空格符号：除 <code>\\s</code> 以外的任何字符，例如字母。</li>\n<li><code>\\W</code>：非单字字符：除 <code>\\w</code> 以外的任何字符，例如非拉丁字母或空格。</li>\n</ol>\n<p>在这一章的开头，我们看到了如何从 <code>+7(903)-123-45-67</code> 这样的字符串中创建一个只包含数字的电话号码: 找到所有的数字并将它们连接起来。</p>\n<pre><code class=\"language-js\">let str = &quot;+7(903)-123-45-67&quot;;\n\nconsole.log(str.match(/\\d/g).join(\'\')); // 79031234567\n</code></pre>\n<p>另一种快捷的替代方法是查找非数字 <code>\\D</code> 并将其从字符串中删除：</p>\n<pre><code class=\"language-js\">let str = &quot;+7(903)-123-45-67&quot;;\n\nconsole.log( str.replace(/\\D/g, &quot;&quot;) ); // 79031234567\n</code></pre>\n<h2>点<code>（.）</code>是匹配任何字符</h2>\n<p>点 <code>.</code> 是一种特殊字符类，它与 “除换行符之外的任何字符” 匹配。例如：</p>\n<pre><code class=\"language-js\">console.log(&quot;Z&quot;.match(/./)); // [ \'Z\', index: 0, input: \'Z\', groups: undefined ]\n</code></pre>\n<p>或在正则表达式中间：</p>\n<pre><code class=\"language-js\">let regexp = /CS.4/;\n\nconsole.log(&quot;CSS4&quot;.match(regexp)); // [ \'CSS4\', index: 0, input: \'CSS4\', groups: undefined ]\nconsole.log(&quot;CS-4&quot;.match(regexp)); // [ \'CS-4\', index: 0, input: \'CS-4\', groups: undefined ]\nconsole.log(&quot;CS 4&quot;.match(regexp)); // [ \'CS 4\', index: 0, input: \'CS 4\', groups: undefined ]\n</code></pre>\n<p>请注意，点表示“任何字符”，而不是“缺少字符”。必须有一个与之匹配的字符：</p>\n<pre><code class=\"language-js\">console.log( &quot;CS4&quot;.match(/CS.4/) ); // null\n</code></pre>\n<h2>带有“s”标志时点字符类严格匹配任何字符</h2>\n<p>默认情况下，点与换行符 <code>\\n</code> 不匹配。</p>\n<p>例如，正则表达式 <code>A.B</code> 匹配 <code>A</code>，然后匹配 <code>B</code> 和它们之间的任何字符，除了换行符<code>\\n</code>：</p>\n<pre><code class=\"language-js\">console.log( &quot;A\\nB&quot;.match(/A.B/) ); // null (no match)\n</code></pre>\n<p>在许多情况下，当我们希望用点来表示“任何字符”（包括换行符）时。</p>\n<p>这就是标志 <code>s</code> 所做的。如果有一个正则表达式，则点 <code>.</code> 实际上匹配任何字符：</p>\n<pre><code class=\"language-js\">console.log(&quot;A\\nB&quot;.match(/A.B/s)); // [ \'A\\nB\', index: 0, input: \'A\\nB\', groups: undefined ]\n</code></pre>\n<blockquote>\n<p><strong>不支持 Firefox、IE、Edge</strong></p>\n<p>使用前可从 https://caniuse.com/#search=dotall 确认以获得最新的支持状态。在撰写本文时，它不包括 Firefox、IE、Edge。</p>\n<p>幸运的是，有一种替代方法可以在任何地方使用。我们可以使用诸如 <code>[\\s\\S]</code> 之类的正则表达式来匹配“任何字符”。</p>\n<pre><code class=\"language-js\">console.log(&quot;A\\nB&quot;.match(/A[\\s\\S]B/)); // [ \'A\\nB\', index: 0, input: \'A\\nB\', groups: undefined ]\n</code></pre>\n<p>模式 <code>[\\s\\S]</code> 从字面上说：“空格字符或非空格字符”。换句话说，“任何东西”。我们可以使用另一对互补的类，例如 <code>[\\d\\D]</code>。甚至是 <code>[^]</code> —— 意思是匹配任何字符，除了什么都没有。</p>\n<p>如果我们希望两种“点”都使用相同的模式，也可以使用此技巧：实际的点 <code>.</code> 具有常规方式（“不包括换行符”）以及一种使用 <code>[\\s\\S]</code> 或类似形式匹配“任何字符”。</p>\n</blockquote>\n<blockquote>\n<p><strong>注意空格</strong></p>\n<p>通常我们很少注意空格。对我们来说，字符串 <code>1-5</code> 和 <code>1 - 5</code> 几乎相同。</p>\n<p>但是，如果正则表达式未考虑空格，则可能无法正常工作。</p>\n<p>让我们尝试查找由连字符（-）分隔的数字：</p>\n<pre><code class=\"language-js\">console.log( &quot;1 - 5&quot;.match(/\\d-\\d/) ); // null, no match!\n</code></pre>\n<p>让我们修复一下，在正则表达式中添加空格：<code>/\\d - \\d/</code>：</p>\n<pre><code class=\"language-js\">console.log(&quot;1 - 5&quot;.match(/\\d - \\d/)); // [ \'1 - 5\', index: 0, input: \'1 - 5\', groups: undefined ]\n// or we can use \\s class:\nconsole.log(&quot;1 - 5&quot;.match(/\\d\\s-\\s\\d/)); // [ \'1 - 5\', index: 0, input: \'1 - 5\', groups: undefined ]\n</code></pre>\n<p><strong>空格是一个字符。与其他字符同等重要。</strong></p>\n<p>我们无法在正则表达式中添加或删除空格，并且期望能正常工作。</p>\n<p>换句话说，在正则表达式中，所有字符都很重要，空格也很重要。</p>\n</blockquote>\n<h2>总结</h2>\n<p>存在以下字符类：</p>\n<ul>\n<li><code>\\d</code> —— 数字。</li>\n<li><code>\\D</code> —— 非数字。</li>\n<li><code>\\s</code> —— 空格符号，制表符，换行符。</li>\n<li><code>\\S</code> —— 除了 <code>\\s</code> 。</li>\n<li><code>\\w</code> —— 拉丁字母，数字，下划线 <code>\'_\'</code>。</li>\n<li><code>\\W</code> —— 除了 <code>\\w</code>。</li>\n<li><code>.</code> —— 任何带有 <code>\'s\'</code> 标志的字符，否则为除换行符 <code>\\n</code>之外的任何字符。</li>\n</ul>\n<p>……但这还不是全部！</p>\n<p>JavaScript 用于字符串的 Unicode 编码提供了许多字符属性，例如：这个字母属于哪一种语言（如果它是一个字母）？它是标点符号吗？等等。</p>\n<p>我们也可以通过这些属性进行搜索。这需要标志 <code>u</code>，在下一篇文章中介绍。</p>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-character-classes\">https://zh.javascript.info/regexp-character-classes</a></p>\n', '2021-12-04 18:31:01', '2021-12-04 18:31:01');
INSERT INTO `t_blog` VALUES ('46fdf7c0-54ac-11ec-96d5-7933aca11ca0', 'js中Object的常用方法', '在平时学习中，经常会用到`Object`对象上得以一些自带的方法。比如类型判断的`Object.prototype.toString()`、获取对象的key`Object.keys()`、再或者定义一个不可枚举的属性`Object.defineProperty()`等等，一直都没有系统的学习过这个对象，今天就来好好的学习一下。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 6, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>在平时学习中，经常会用到<code>Object</code>对象上得以一些自带的方法。比如类型判断的<code>Object.prototype.toString()</code>、获取对象的key<code>Object.keys()</code>、再或者定义一个不可枚举的属性<code>Object.defineProperty()</code>等等，一直都没有系统的学习过这个对象，今天就来好好的学习一下。</p>\n<h2>Object构造函数</h2>\n<h3>创建对象的两种方式</h3>\n<ol>\n<li>\n<p>使用花括号<code>{name: \'John\'}</code></p>\n</li>\n<li>\n<p>使用Object构造方法</p>\n<ul>\n<li>如果给定值是 <code>null</code>或 <code>undefined</code>，将会创建并返回一个空对象</li>\n<li>如果传进去的是一个基本类型的值，则会构造其包装类型的对象</li>\n<li>如果传进去的是引用类型的值，仍然会返回这个值，经他们复制的变量保有和源对象相同的引用地址</li>\n</ul>\n<pre><code class=\"language-js\">let o1 = new Object(null)\nlet o2 = new Object(undefined) // 传null或undefined，会构建一个空对象\nconsole.log(o1); // {}\nconsole.log(o2); // {}\n\nlet o3 = new Object(1) // 传基本类型，会构造包装类对象\nconsole.log(o3); // [Number: 1]\n\nlet o4 = { name: \'John\' }\nlet o5 = new Object(o4) // 使用引用类型创建一个对象，会返回原对象（相同的引用地址）\nconsole.log(o5 === o4); // true\n</code></pre>\n</li>\n</ol>\n<h2>静态属性和方法</h2>\n<h3>Object.length</h3>\n<p>返回1</p>\n<pre><code class=\"language-js\">console.log(Object.length) // 1\n</code></pre>\n<h3>Object.assign()</h3>\n<p>拷贝一个对象的属性值到目标对象里。</p>\n<p>只会拷贝源对象自身的并且可枚举的属性到目标对象，属于浅拷贝。如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。</p>\n<pre><code class=\"language-js\">const target = { a: 1, b: 2 }; // 重复的键会被源对象覆盖\nconst source = { b: 4, c: 5 };\nconst returnedTarget = Object.assign(target, source);\n\nconsole.log(returnedTarget); // { a: 1, b: 4, c: 5 }\n\nlet o1 = Object.assign({}, { a: \'1\', b: \'2\' }) // 经常这么用去复制一个对象\nconsole.log(o1); // { a: \'1\', b: \'2\' }\n</code></pre>\n<h3>Object.create()</h3>\n<p>创建一个新对象，使用现有的对象来提供新创建的对象的<code>__proto__</code>。</p>\n<pre><code class=\"language-js\">let o1 = { name: \'John\' }\nlet o2 = Object.create(o1)\nconsole.log(o2); // {}\nconsole.log(o2.__proto__ === o1); // true\n</code></pre>\n<h3>Object.defineProperties()</h3>\n<p>直接在一个对象上定义新的属性或修改现有属性，并返回该对象。(参数的解释参考 Object.defineProperty()，它俩一样，只不过一个定义多个属性，一个每次只定义一个属性)</p>\n<pre><code class=\"language-js\">let obj = {}\nObject.defineProperties(obj, {\n    \'name\': {\n        value: \'John\',\n        writable: true,\n    },\n    \'age\': {\n        value: \'18\',\n        writable: false,\n    }\n})\n\nconsole.log(obj.name);// John\nconsole.log(obj.age);// 18\n\nobj.name = \'hhh\'\nconsole.log(obj.name);// hhh\n\nobj.age = 10\nconsole.log(obj.age); // 18 仍旧是18.并没有被改变\n</code></pre>\n<h3>Object.defineProperty()</h3>\n<p>定义对象的内部属性。属性有下面几个配置，可以分为两类，<strong>数据描述</strong>和<strong>存取描述</strong>。</p>\n<h4>数据描述</h4>\n<h5>configurable</h5>\n<p>默认为false，当为false时，表示属性不可以被改变，不可被删除。</p>\n<blockquote>\n<p>这里的属性不可被改变，指的是除了<code>value、writeable</code>特性外的其他特性是否可以被修改。</p>\n</blockquote>\n<pre><code class=\"language-js\">var o = {};\nObject.defineProperty(o, \'a\', {\n  get() { return 1; },\n  configurable: false // 已经配置 a属性的configurable属性为false了，所以除了value和writeable之外，所有的配置都不可再更改了\n});\n\n// 当尝试去更改 configurable 配置时，会报错\nObject.defineProperty(o, \'a\', {\n  configurable: true\n}); // throws a TypeError\n\n// 当尝试去修改 enumerable 配置时，也会报错\nObject.defineProperty(o, \'a\', {\n  enumerable: true\n}); // throws a TypeError\n\n// 当尝试去修改 set 配置时，也会报错\nObject.defineProperty(o, \'a\', {\n  set() {}\n}); // throws a TypeError (set was undefined previously)\n\n// 当尝试去修改 get 配置时，也会报错\nObject.defineProperty(o, \'a\', {\n  get() { return 1; }\n}); // throws a TypeError\n// (even though the new get does exactly the same thing)\n\n// 当尝试去修改 value 配置时，正常是可以修改的，但是本例中，因为我们定义的getter的原因，也会报错\nObject.defineProperty(o, \'a\', {\n  value: 12\n}); // throws a TypeError // (\'value\' can be changed when \'configurable\' is false but not in this case due to \'get\' accessor)\n\nconsole.log(o.a); // logs 1\n\n// 当我们尝试去删除这个属性时，无事发生，但是严格模式下就会报错额了\ndelete o.a; // Nothing happens\nconsole.log(o.a); // logs 1\n</code></pre>\n<p>上述例子中。如果 <code>o.a</code> 的 <code>configurable</code> 属性为 <code>true</code>，则不会抛出任何错误，并且，最后，该属性会被删除。</p>\n<h5>enumerable</h5>\n<p>默认为false，当为false时，表示该对象的属性不可被枚举。即是否能够使用<code>for in</code>或者<code>Object.keys()</code>枚举出来。</p>\n<pre><code class=\"language-js\">let obj = {}\nObject.defineProperty(obj, \'name\', {\n    enumerable: true, // 设置为可枚举\n    value: \'cheny\'\n})\nObject.defineProperty(obj, \'age\', {\n    enumerable: false, // 设置为不可枚举（默认值）\n    value: \'18\'\n})\n\nconsole.log(obj.name); // cheny\nconsole.log(obj.age); // 18\n\n// 当使用for in 去获取obj的可枚举属性时\nfor (const key in obj) {\n    console.log(`${key}: ${obj[key]}`); // name: cheny\n}\n// 发现只把name输出了出来，age并没有输出出来\n\nlet keys = Object.keys(obj)\nconsole.log(keys); // [ \'name\' ] 也是只有name，age并没有被获取到\n</code></pre>\n<h5>writable</h5>\n<p>默认为false，当为false时，value值不可被更改。（非严格模式下，尝试更改会无事发生，严格模式尝试更改会报错）</p>\n<pre><code class=\"language-js\">let obj = {}\nObject.defineProperty(obj, \'name\', {\n    writable: true,\n    value: \'cheny\'\n})\nconsole.log(obj.name); // cheny\n\n// 当我们试图修改name时\nobj.name = \'xzz\'\nconsole.log(obj.name); // xzz writable配置为true时，才会生效\n</code></pre>\n<h5>value</h5>\n<p>默认为undefined，表示属性的值，可以设置为任意类型。</p>\n<h4>存取描述</h4>\n<h5>get、set</h5>\n<ol>\n<li><code>get</code>：属性的getter函数，没有时默认为undefined。当访问该属性时会调用此函数。</li>\n<li><code>set</code>：属性的setter函数，没有时默认为undefined。当属性值被修改时，会调用此函数。方法会接收一个默认参数（也就是被赋予的新值）</li>\n</ol>\n<pre><code class=\"language-js\">let obj = {}\nObject.defineProperty(obj, \'name\', {\n    get() {\n        console.log(\'name 被获取了\');\n        return this.value\n    },\n\n    set(x) {\n        console.log(`name 被赋值了 ${x}`);\n        this.value = x\n    }\n\n})\n\nobj.name = \'cheny\' // name 被赋值了 cheny\n\nconsole.log(obj.name);\n/*\n    name 被获取了\n    cheny\n*/\n</code></pre>\n<blockquote>\n<p>！注意：假如，一个属性有了get或者set中的任意一个，或者两个都有，那么，就不能再有value或者writeable，他们不能同时存在，如果同时存在会报错，<code>TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute</code>。</p>\n</blockquote>\n<h4>一个问题</h4>\n<p>平时使用的<code>let obj = {} obj.a =\'hello\' </code>，与使用<code>Object.defineProperty()</code>为对象属性赋值时的区别</p>\n<pre><code class=\"language-js\">let o = {};\n\no.a = 1;\n// 等同于：\nObject.defineProperty(o, &quot;a&quot;, {\n  value: 1,\n  writable: true,\n  configurable: true,\n  enumerable: true\n});\n\nObject.defineProperty(o, &quot;a&quot;, { value : 1 });\n// 等同于：\nObject.defineProperty(o, &quot;a&quot;, {\n  value: 1,\n  writable: false,\n  configurable: false,\n  enumerable: false\n});\n</code></pre>\n<h3>Object.entries()</h3>\n<p>返回一个给定对象自身可枚举属性的键值对数组，关键词是 <strong>自身</strong>，其排列与使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in\"><code>for...in</code></a> 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）。</p>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\',\n    b: \'bbb\'\n}\n\nconsole.log(Object.entries(obj1)); // [ [ \'a\', \'aaa\' ], [ \'b\', \'bbb\' ] ]\n\n// 所以可以很方便的将对象转换为一个map\nlet map = new Map(Object.entries(obj1))\nconsole.log(map); // Map(2) { \'a\' =&gt; \'aaa\', \'b\' =&gt; \'bbb\' }\n</code></pre>\n<p>对比<code>for in</code>，<code>for in</code>遍历对象时，会把继承过来的<code>key</code>也输出出来，<code>Object.entries()</code>只会转换自身的属性。</p>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\'\n}\n\nlet obj2 = Object.create(obj1) // Object.create() 会返回一个新对象，新对象的__proto__会指向 obj1\n// 相当于 let obj2 = {__proto__: obj1}\n\nconsole.log(obj2.__proto__ === obj1); // true\n\nobj2.b = \'bbb\'\nobj2.c = \'ccc\'\n\nconsole.log(Object.entries(obj2)); // [ [ \'b\', \'bbb\' ], [ \'c\', \'ccc\' ] ]  只返回了自身上的属性\n\n// for in 遍历对象时 集成的属性也会被打印出来\nfor (const key in obj2) {\n    console.log(`${key}: ${obj2[key]}`);\n}\n/* \n    b: bbb\n    c: ccc\n    a: aaa\n*/\n</code></pre>\n<h3>Object.freeze()</h3>\n<p>冻结一个对象，被冻结后的对象不能被修改。</p>\n<ol>\n<li>不能添加新属性</li>\n<li>不能删除已有属性</li>\n<li>不能修改对象已有属性的可枚举性、可配置性、可写性</li>\n<li>不能修改已有的属性值（浅 不能修改，只管一层，第二次以后的对象还是可以修改）</li>\n<li>冻结的对象原型也不能修改</li>\n</ol>\n<p>严格模式执行上述操作会报错，非严格模式会忽略。</p>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\',\n    b: \'bbb\',\n    c: {\n        d: \'cccc\'\n    }\n}\n\nlet obj2 = Object.freeze(obj1)\n\nconsole.log(obj1 === obj2); // true 返回的仍旧是原对象\n\n// 但是修改是无效的\n\nobj2.a = \'hhh\'\nconsole.log(obj2); // { a: \'aaa\', b: \'bbb\', c: { d: \'cccc\' } }\n\nobj2.c.d = \'cheny\'\nconsole.log(obj2); // { a: \'aaa\', b: \'bbb\', c: { d: \'cheny\' } } 只管一层，深层的对象还是能修改\n</code></pre>\n<h3>Object.fromEntries()</h3>\n<p>把键值对列表转换为一个对象。</p>\n<ol>\n<li>\n<p>Map转Object</p>\n<pre><code class=\"language-js\">const map = new Map([[\'foo\', \'bar\'], [\'baz\', 42]]);\nconst obj = Object.fromEntries(map);\nconsole.log(obj); // { foo: &quot;bar&quot;, baz: 42 }\n</code></pre>\n</li>\n<li>\n<p>Array转Object</p>\n<pre><code class=\"language-js\">const arr = [[\'0\', \'a\'], [\'1\', \'b\'], [\'2\', \'c\']];\nconst obj = Object.fromEntries(arr);\nconsole.log(obj); // { 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot; }\n</code></pre>\n</li>\n<li>\n<p>对象转换</p>\n<p>对象先通过 <code>Object.entries()</code>转变为数组</p>\n<p>然后数组通过map过滤一遍</p>\n<p>然后返回的新数组再通过<code>Object.fromEntries()</code>转换为对象，达到对象转换的效果</p>\n<pre><code class=\"language-js\">const object1 = { a: 1, b: 2, c: 3 };\n\nconst object2 = Object.fromEntries(\n    Object.entries(object1)\n        .map(([key, val]) =&gt; [key, val * 2])\n);\n\nconsole.log(object2);\n// { a: 2, b: 4, c: 6 }\n</code></pre>\n</li>\n</ol>\n<h3>Object.getOwnPropertyDescriptor()</h3>\n<p>返回对象自有属性的属性描述符。</p>\n<pre><code class=\"language-js\">let obj = {}\nObject.defineProperty(obj, \'name\', {\n    configurable: true,\n    value: \'cheny\',\n    writable: true,\n    enumerable: true\n})\n\nconsole.log(obj.name); // cheny\nlet desc = Object.getOwnPropertyDescriptor(obj, \'name\')\nconsole.log(typeof desc); // object\nconsole.log(desc);\n/*\n{\n  value: \'cheny\',\n  writable: true,\n  enumerable: true,\n  configurable: true\n}\n*/\n</code></pre>\n<h3>Object.getOwnPropertyDescriptors()</h3>\n<p>用来获取一个对象的所有自身属性的描述符。</p>\n<pre><code class=\"language-js\">let obj = {}\nObject.defineProperties(obj, {\n    \'name\': {\n        value: \'John\',\n        writable: true,\n    },\n    \'age\': {\n        value: \'18\',\n        writable: false,\n    }\n})\n\nconsole.log(obj.name);// John\nconsole.log(obj.age);// 18\n\nlet desc = Object.getOwnPropertyDescriptors(obj)\nconsole.log(desc);\n/*\n{\n  name: {\n    value: \'John\',\n    writable: true,\n    enumerable: false,\n    configurable: false\n  },\n  age: {\n    value: \'18\',\n    writable: false,\n    enumerable: false,\n    configurable: false\n  }\n}\n*/\n</code></pre>\n<h3>Object.getOwnPropertyNames()</h3>\n<p>返回一个数组，该数组对元素是 <code>obj</code>自身拥有的枚举或不可枚举属性名称字符串。（不包含Symbol类型）</p>\n<pre><code class=\"language-js\">let obj1 = {}\nObject.defineProperties(obj1, {\n    name: {\n        value: \'hhh\',\n        enumerable: true\n    },\n    age: {\n        value: 18,\n        enumerable: false\n    }\n})\nconsole.log(obj1.name); // hhh\nconsole.log(obj1.age); // 18\n\n// 只会打印可枚举的\nfor (const key in obj1) {\n    console.log(key);\n}\n// name\n\n// 要是想把所有的key都获取到 使用 Object.getOwnPropertyNames()\n\nlet keys = Object.getOwnPropertyNames(obj1)\nconsole.log(keys); // [ \'name\', \'age\' ]  不可枚举的 age 也打印了出来\n</code></pre>\n<h3>Object.getOwnPropertySymbols()</h3>\n<p>返回一个给定对象自身的所有 Symbol 属性的数组。</p>\n<p>与<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\"><code>Object.getOwnPropertyNames()</code></a>类似，您可以将给定对象的所有符号属性作为 Symbol 数组获取。 请注意，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\"><code>Object.getOwnPropertyNames()</code></a>本身不包含对象的 Symbol 属性，只包含字符串属性。</p>\n<pre><code class=\"language-js\">let obj1 = {}\nlet symbol1 = Symbol(\'symbol1\')\nlet symbol2 = Symbol.for(\'symbol2\')\nObject.defineProperties(obj1, {\n    name: {\n        value: \'hhh\',\n        enumerable: true\n    },\n    age: {\n        value: 18,\n        enumerable: false\n    },\n    [symbol1]: {\n        value: \'localsymbol\'\n    },\n    [symbol2]: {\n        value: \'globalSymbol\'\n    },\n\n})\n\nlet keys = Object.getOwnPropertyNames(obj1)\nconsole.log(keys); // [ \'name\', \'age\' ] 无法获取到symbol，只能获取到字符串key\n\nlet key2 = Object.getOwnPropertySymbols(obj1)\nconsole.log(key2); // [ Symbol(symbol1), Symbol(symbol2) ]\n\nconsole.log(obj1[key2[0]]); // localsymbol\nconsole.log(obj1[key2[1]]); // globalSymbol\n</code></pre>\n<h3>Object.getPrototypeOf()</h3>\n<p>方法返回指定对象的原型（内部<code>[[Prototype]]</code>属性的值）。</p>\n<pre><code class=\"language-js\">function Foo() { }\nlet obj = new Foo()\n\nconsole.log(obj.__proto__ === Foo.prototype); // true\n\nlet proto = Object.getPrototypeOf(obj)\n\nconsole.log(proto === Foo.prototype); // true\nconsole.log(proto === obj.__proto__); // true\n</code></pre>\n<h3>Object.is()</h3>\n<p>判断两个值是否相等。</p>\n<blockquote>\n<p>与 === 类似，但是有区别</p>\n<ol>\n<li>===判断 +0和-0是相等的，Object.is判定它俩不相等</li>\n<li>=== 判断 NaN === NaN 会返回false，Object.is判定它俩相等</li>\n</ol>\n<p>==与===的区别参考另一篇文章：<a href=\"http://www.bnbiye.cn/#/articleDetail/e6f5d9b0-5109-11ec-96d5-7933aca11ca0\">js中==与===</a></p>\n</blockquote>\n<pre><code class=\"language-js\">console.log(+0 === -0); // true\nconsole.log(Object.is(+0, -0)); // false\n\nconsole.log(NaN === NaN); // false\nconsole.log(Object.is(NaN, NaN)); // true\n\n// 其余的都与 === 类似\nconsole.log(\'1\' === 1); // false\nconsole.log(Object.is(\'1\', 1)); // false\n</code></pre>\n<h3>Object.isExtensible()</h3>\n<p>判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</p>\n<p>默认情况下，对象是可扩展的：即可以为他们添加新的属性。以及它们的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\"><code>__proto__</code></a> 属性可以被更改。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions\"><code>Object.preventExtensions</code></a>，<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal\"><code>Object.seal</code></a> 或 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\"><code>Object.freeze</code></a> 方法都可以标记一个对象为不可扩展（non-extensible）。</p>\n<pre><code class=\"language-js\">// 新对象默认是可扩展的.\nlet empty = {};\nconsole.log(Object.isExtensible(empty)); // === true\n\n// ...可以变的不可扩展.\nObject.preventExtensions(empty);\nconsole.log(Object.isExtensible(empty)); // === false\n\n// 密封对象是不可扩展的.\nlet sealed = Object.seal({});\nconsole.log(Object.isExtensible(sealed)); // === false\n\n// 冻结对象也是不可扩展.\nlet frozen = Object.freeze({});\nconsole.log(Object.isExtensible(frozen)); // === false\n</code></pre>\n<h3>Object.isFrozen()</h3>\n<p>判断一个对象是否被<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\">冻结</a>。</p>\n<blockquote>\n<p>下面的例子就这一句话总结：</p>\n<p>一个对象是冻结的是指它不可<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\"><code>扩展</code></a>，所有属性都是不可配置的，且所有数据属性（即没有getter或setter组件的访问器的属性）都是不可写的。</p>\n</blockquote>\n<pre><code class=\"language-js\">// 一个对象默认是可扩展的,所以它是非冻结的.\nObject.isFrozen({}); // === false\n\n// 一个不可扩展的空对象同时是一个冻结对象.\nvar vacuouslyFrozen = Object.preventExtensions({});\nObject.isFrozen(vacuouslyFrozen) //=== true;\n\n// 一个非空对象默认是非冻结的.\nvar oneProp = { p: 42 };\nObject.isFrozen(oneProp) //=== false\n\n// 让这个对象变的不可扩展,并不意味着这个对象变成了冻结对象,\n// 因为p属性仍然是可以配置的(而且可写的).\nObject.preventExtensions(oneProp);\nObject.isFrozen(oneProp) //=== false\n\n// 此时,如果删除了这个属性,则它会成为一个冻结对象.\ndelete oneProp.p;\nObject.isFrozen(oneProp) //=== true\n\n\n// 一个不可扩展的对象,拥有一个不可写但可配置的属性,则它仍然是非冻结的.\nvar nonWritable = { e: &quot;plep&quot; };\nObject.preventExtensions(nonWritable);\nObject.defineProperty(nonWritable, &quot;e&quot;, { writable: false }); // 变得不可写\nObject.isFrozen(nonWritable) //=== false\n\n// 把这个属性改为不可配置,会让这个对象成为冻结对象.\nObject.defineProperty(nonWritable, &quot;e&quot;, { configurable: false }); // 变得不可配置\nObject.isFrozen(nonWritable) //=== true\n\n// 一个不可扩展的对象,拥有一个不可配置但可写的属性,则它仍然是非冻结的.\nvar nonConfigurable = { release: &quot;the kraken!&quot; };\nObject.preventExtensions(nonConfigurable);\nObject.defineProperty(nonConfigurable, &quot;release&quot;, { configurable: false });\nObject.isFrozen(nonConfigurable) //=== false\n\n// 把这个属性改为不可写,会让这个对象成为冻结对象.\nObject.defineProperty(nonConfigurable, &quot;release&quot;, { writable: false });\nObject.isFrozen(nonConfigurable) //=== true\n\n// 一个不可扩展的对象,值拥有一个访问器属性,则它仍然是非冻结的.\nvar accessor = { get food() { return &quot;yum&quot;; } };\nObject.preventExtensions(accessor);\nObject.isFrozen(accessor) //=== false\n\n// ...但把这个属性改为不可配置,会让这个对象成为冻结对象.\nObject.defineProperty(accessor, &quot;food&quot;, { configurable: false });\nObject.isFrozen(accessor) //=== true\n\n// 使用Object.freeze是冻结一个对象最方便的方法.\nvar frozen = { 1: 81 };\nObject.isFrozen(frozen) //=== false\nObject.freeze(frozen);\nObject.isFrozen(frozen) //=== true\n\n// 一个冻结对象也是一个密封对象.\nObject.isSealed(frozen) //=== true\n\n// 当然,更是一个不可扩展的对象.\nObject.isExtensible(frozen) //=== false\n</code></pre>\n<h3>Object.isSealed()</h3>\n<p>判断一个对象是否被密封。</p>\n<p>密封对象是指那些不可 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\"><code>扩展</code></a> 的，且所有自身属性都不可配置且因此不可删除（但不一定是不可写）的对象。</p>\n<pre><code class=\"language-js\">// 新建的对象默认不是密封的.\nvar empty = {};\nObject.isSealed(empty); // === false\n\n// 如果你把一个空对象变的不可扩展，则它同时也会变成个密封对象.\nObject.preventExtensions(empty);\nObject.isSealed(empty); // === true\n\n// 但如果这个对象不是空对象，则它不会变成密封对象,因为密封对象的所有自身属性必须是不可配置的.\nvar hasProp = { fee: &quot;fie foe fum&quot; };\nObject.preventExtensions(hasProp);\nObject.isSealed(hasProp); // === false\n\n// 如果把这个属性变的不可配置，则这个属性也就成了密封对象.\nObject.defineProperty(hasProp, \'fee\', {\n  configurable: false\n});\nObject.isSealed(hasProp); // === true\n\n// 最简单的方法来生成一个密封对象，当然是使用Object.seal.\nvar sealed = {};\nObject.seal(sealed);\nObject.isSealed(sealed); // === true\n\n// 一个密封对象同时也是不可扩展的.\nObject.isExtensible(sealed); // === false\n\n// 一个密封对象也可以是一个冻结对象,但不是必须的.\nObject.isFrozen(sealed); // === true ，所有的属性都是不可写的\nvar s2 = Object.seal({ p: 3 });\nObject.isFrozen(s2); // === false， 属性&quot;p&quot;可写\n\nvar s3 = Object.seal({ get p() { return 0; } });\nObject.isFrozen(s3); // === true ，访问器属性不考虑可写不可写,只考虑是否可配置\n</code></pre>\n<h3>Object.keys()</h3>\n<p>返回一个由一个给定对象的自身可枚举属性组成的数组</p>\n<pre><code class=\"language-js\">let obj1 = {}\nObject.defineProperties(obj1, {\n    name: {\n        value: \'hhh\',\n        enumerable: true\n    },\n    age: {\n        value: 18,\n        enumerable: false\n    },\n    job: {\n        value: \'soft\',\n        enumerable: true\n    }\n})\nconsole.log(obj1.name); // hhh\nconsole.log(obj1.age); // 18\nconsole.log(obj1.job); // 18\n\nconsole.log(Object.keys(obj1)); // [ \'name\', \'job\' ] 只返回自己可枚举的key\n</code></pre>\n<h3>Object.preventExtensions()</h3>\n<p>让一个对象变的不可扩展，也就是永远不能再添加新的属性。</p>\n<p>当对象变为不可扩展后，</p>\n<ol>\n<li>严格模式下，添加新属性会报错，非严格模式操作会忽略</li>\n<li>虽然不可以添加新属性，但是却可以删除之前的属性</li>\n<li>该方法会使<code>__proto__</code>不可变，如果尝试修改会报错</li>\n</ol>\n<pre><code class=\"language-js\">// &quot;use strict&quot;\nlet obj1 = {\n    a: \'aaa\',\n    b: \'bbb\'\n}\n\n// 让obj1 变得不可扩展，即不能添加新属性\nlet obj2 = Object.preventExtensions(obj1)\nconsole.log(obj2 === obj1); // true\n\n// 如果尝试添加，严格模式会报错\nobj1.c = \'ccc\'\n\nconsole.log(obj1.c); // undefined\n\n// 但是我们可以删除之前的属性\ndelete obj1.a\nconsole.log(obj1); // { b: \'bbb\' }\n\n// 然后我们再次尝试添加新属性，严格模式仍然会报错的，非严格模式就忽略，即 变为不可扩展的对象不能添加新属性，但是可以删除原来的属性\nobj1.a = \'dddd\'\nconsole.log(obj1);\n\n\nlet obj3 = {\n    name: \'cheny\'\n}\n\n// 变为不可哭扩展的对象，原型即锁死了，不能再修改，如果尝试修改会报错\n// TypeError: #&lt;Object&gt; is not extensible\n/* obj1.__proto__ = obj3\nconsole.log(obj1.__proto__ === obj3); */\n</code></pre>\n<h3>Object.seal()</h3>\n<p>封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。</p>\n<p>通常，一个对象是<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible\">可扩展的</a>（可以添加新的属性）。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError\"><code>TypeError</code></a>（在<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode\">严格模式</a> 中最常见的，但不唯一）。</p>\n<p>不会影响从原型链上继承的属性。但 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto\"><code>__proto__</code></a> ( ) 属性的值也会不能修改。</p>\n<p>返回被密封对象的引用。</p>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\',\n    b: \'bbb\'\n}\n\n// 让对象变为封闭的\nlet obj2 = Object.seal(obj1)\nconsole.log(obj1 === obj2); // true\n\n// 变为封闭的对象所有属性不可配置，所以当尝试删除一个属性时，严格模式就会报错\ndelete obj1.a\nconsole.log(obj1); // { a: \'aaa\', b: \'bbb\' } 并没有删除成功\n</code></pre>\n<h3>Object.setPrototypeOf()</h3>\n<p>置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或  <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null\"><code>null</code></a>。</p>\n<blockquote>\n<p><strong>警告:</strong> 由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 <code>[[Prototype]]</code>在<em><strong>各个</strong></em>浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 <code>obj.__proto__ = ...</code> 语句上的时间花费，而且可能会延伸到<em><strong>任何</strong></em>代码，那些可以访问<em><strong>任何</strong></em><code>[[Prototype]]</code>已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 <code>[[Prototype]]</code>。相反，你应该使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\"><code>Object.create()</code></a>来创建带有你想要的<code>[[Prototype]]</code>的新对象。</p>\n</blockquote>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\'\n}\n\nlet obj2 = {\n    b: \'bbb\'\n}\n\nObject.setPrototypeOf(obj1, obj2) // 相当于 obj1.__proto__ = obj2\n\nconsole.log(obj1.__proto__ === obj2); // true\n\n// 所以此时obj1就可以访问到obj2的属性了\nconsole.log(obj1.b); // bbb\n</code></pre>\n<h3>Object.values()</h3>\n<p>返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in\"><code>for...in</code></a>循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。</p>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\',\n    b: \'bbb\'\n}\n\nlet obj2 = {\n    c: \'ccc\',\n    d: \'ddd\',\n    __proto__: obj1\n}\n\nlet values = Object.values(obj2)\nconsole.log(values); // [ \'ccc\', \'ddd\' ]  obj2原型上的值不会被打印出来\n\n// 但是for in 会把原型上的值也打印出来\nfor (const key in obj2) {\n    console.log(`${key}: ${obj2[key]}`);\n}\n/*\n    c: ccc\n    d: ddd\n    a: aaa\n    b: bbb\n*/\n</code></pre>\n<h2>原型上的方法</h2>\n<h3>hasOwnProperty()</h3>\n<p>判断对象自身属性中是否具有指定的属性</p>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\',\n    b: \'bbb\'\n}\n\nlet obj2 = {\n    c: \'ccc\',\n    d: \'ddd\',\n    __proto__: obj1\n}\n\nlet hasOwnProperty = Object.prototype.hasOwnProperty.bind(obj2)\n\nconsole.log(hasOwnProperty(\'c\')); // true 只判断自己的key\nconsole.log(hasOwnProperty(\'a\')); // false 原型上的key不进行判断\n</code></pre>\n<h3>isPrototypeOf()</h3>\n<p>用于测试一个对象是否存在于另一个对象的原型链上。</p>\n<blockquote>\n<p><code>isPrototypeOf()</code> 与 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof\"><code>instanceof</code></a> 运算符不同。在表达式 &quot;<code>object instanceof AFunction</code>&quot;中，<code>object</code> 的原型链是针对 <code>AFunction.prototype</code> 进行检查的，而不是针对 <code>AFunction</code> 本身。</p>\n</blockquote>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\',\n    b: \'bbb\'\n}\n\nlet obj2 = {\n    c: \'ccc\',\n    d: \'ddd\',\n    __proto__: obj1\n}\n\nconsole.log(obj1.isPrototypeOf(obj2)); // true\n</code></pre>\n<h3>propertyIsEnumerable()</h3>\n<p>判断指定的属性是否可枚举。（只考虑自己本身的属性，原型链上的不考虑）</p>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\',\n    b: \'bbb\'\n}\n\nlet obj2 = {\n    c: \'ccc\',\n    d: \'ddd\',\n    __proto__: obj1\n}\nObject.defineProperty(obj2, \'e\', {\n    enumerable: false,\n    value: \'eee\'\n})\n\nconsole.log(obj2.e); // eee\n\nconsole.log(obj2.propertyIsEnumerable(\'c\')); // 自己的可枚举属性 true\nconsole.log(obj2.propertyIsEnumerable(\'a\')); // 继承的可枚举属性 不考虑。所以返回false\nconsole.log(obj2.propertyIsEnumerable(\'e\')); // 自己的不可枚举属性 false\n</code></pre>\n<h3>toLocaleString()</h3>\n<p>返回调用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\"><code>toString()</code></a> 的结果。此方法被用于派生对象为了特定语言环境的目的（locale-specific purposes）而重载使用。</p>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\"><code>Array</code></a>：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString\"><code>Array.prototype.toLocaleString()</code></a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number\"><code>Number</code></a>：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\"><code>Number.prototype.toLocaleString()</code></a></li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date\"><code>Date</code></a>：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date/toLocaleString\"><code>Date.prototype.toLocaleString()</code></a></li>\n</ul>\n<h3>toString()</h3>\n<p>返回一个表示该对象的字符串。<code>&quot;[object type]&quot;</code></p>\n<pre><code class=\"language-js\">let toString = Object.prototype.toString;\n\nconsole.log(toString.call(new Date)); // [object Date]\nconsole.log(toString.call(new String)); // [object String]\nconsole.log(toString.call(Math)); // [object Math]\n\nconsole.log(toString.call(new Map)); // [object Map]\nconsole.log(toString.call(new Set)); // [object Set]\nconsole.log(toString.call(Symbol())); // [object Symbol]\nconsole.log(toString.call(new Function)); // [object Function]\nconsole.log(toString.call(new RegExp)); // [object RegExp]\n\nconsole.log(toString.call(undefined)); // [object Undefined]\nconsole.log(toString.call(null)); // [object Null]\n</code></pre>\n<h3>valueOf()</h3>\n<p>返回指定对象的原始值。对象默认返回它自己</p>\n<pre><code class=\"language-js\">let obj1 = {\n    a: \'aaa\'\n}\n\nconsole.log(obj1.valueOf() === obj1); // true\n</code></pre>\n<h2>总结</h2>\n<h3>创建对象</h3>\n<ol>\n<li>\n<p>使用花括号<code>{}</code></p>\n</li>\n<li>\n<p>使用构造方法<code>new Object()</code></p>\n<ol>\n<li>如果传进去的是<code>null</code>或<code>undefined</code>，返回一个空对象</li>\n<li>如果传进去的是基本类型，会返回一个包装类对象</li>\n<li>如果传进去的是引用类型，会返回它本身</li>\n</ol>\n</li>\n<li>\n<p>使用静态方法<code>let xxx = Object.create(obj)</code></p>\n<p>返回的新对象会以<code>obj</code>为原型，即<code>xx.__proto__ = obj</code></p>\n</li>\n</ol>\n<h3>创建对象属性</h3>\n<ol>\n<li>\n<p>直接使用<code>.</code>，比如<code>obj.a = \'aaa\'</code>，或者直接在花括号中定义，比如<code>let obj = {a: \'aaa\'}</code></p>\n</li>\n<li>\n<p>使用<code>Object.defineProperty()</code>或者<code>Object.defineProperties()</code>，前者是一个一个的创建属性，后者是可以同时创建多个。</p>\n<p>使用这种方式可以同时创建属性的配置，包括：</p>\n<ol>\n<li><code>configurable</code>：属性是否可配置，默认为false</li>\n<li><code>writable</code>：属性是否可改变，默认为false</li>\n<li><code>enumerable</code>：属性是否可枚举，默认为false</li>\n<li><code>value</code>：属性的值，默认为undefined</li>\n<li><code>get、set</code>：属性的get和set方法，默认为undefined</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>二者的区别，使用<code>let obj = {a: \'aaa\'}</code>，类似于：</p>\n<pre><code class=\"language-js\">// let obj = {a: \'aaa\'}，类似于\nlet obj = {}\nObject.defineProperty(obj, \'a\',{\n    configurable: true,\n    writable: true,\n    enumerable: true,\n    value: \'aaa\'\n})\n</code></pre>\n</blockquote>\n<h3>获取属性描述</h3>\n<ol>\n<li>使用<code>Object.getOwnPropertyDescriptor()</code>：获取单个的属性描述</li>\n<li>或者<code>Object.getOwnPropertyDescriptors()</code>：获取对象上所有的属性描述，只会获取对象本身，继承的属性不会获取到</li>\n</ol>\n<h3>改变对象状态</h3>\n<ol>\n<li>\n<p>可扩展</p>\n<p>可扩展是指对象可以添加新的属性，创建的对象默认是可扩展的，即，可以添加新属性。</p>\n<ol>\n<li>可以使用<code>Object.preventExtensions()</code>使对象变得不可扩展。不可扩展同时会锁定对象的原型，即<code>__proto__</code>不可再改变。</li>\n<li>使用<code>Object.isEntensible()</code>，可以判断对象是否可扩展。</li>\n</ol>\n</li>\n<li>\n<p>封闭</p>\n<p>封闭是指，不可以添加新属性，并且当前对象的所有属性都不可配置，不可配置就是指，所有属性的<code>configurable</code>变为了<code>false</code>。</p>\n<p>所以，封闭的对象肯定是不可扩展的。</p>\n<ol>\n<li>可以使用<code>Object.seal()</code>使对象变为封闭状态。</li>\n<li>使用<code>Object.isSealed()</code>可以判断对象是否是封闭的。</li>\n</ol>\n</li>\n<li>\n<p>冻结</p>\n<p>冻结是比扩展和封闭更强的状态，限制的最死，一个对象变为冻结状态后，它不可扩展、所有属性都变的不可配置，并且所有的属性值都不可以再改变。</p>\n<ol>\n<li>可以使用<code>Object.freeze()</code>冻结一个对象。</li>\n<li>使用<code>Object.isFrozen()</code>判断一个对象是否是冻结的。</li>\n</ol>\n</li>\n</ol>\n<h3>对象的原型</h3>\n<ol>\n<li>\n<p>可以使用<code>Object.getPrototypeOf()</code>获取到一个对象的原型</p>\n</li>\n<li>\n<p>使用<code>Object.setPrototypeOf()</code>设置一个对象的原型</p>\n<p>建议不要直接设置一个对象的原型，因为内部执行会很慢，如果想设置一个对象的原型，可以直接使用<code>Object.create(obj)</code>创建一个对象，那这个新对象的<code>__proto__</code>就会指向参数<code>obj</code>。</p>\n</li>\n</ol>\n<h3>遍历对象，获取key或value</h3>\n<ol>\n<li>\n<p><code>Object.keys()</code>获取到对象上的所有key</p>\n</li>\n<li>\n<p><code>Object.values()</code>获取到对象上的所有value</p>\n</li>\n<li>\n<p><code>Object.entries()</code>获取到对象上的<code>key和value</code>，返回的是一个二维数组，比如：<code>[[a,\'aaa\'],[b,\'bbb\']]</code></p>\n</li>\n<li>\n<p><code>Object.fromEntries()</code>，把键值对列表转换为对象</p>\n<blockquote>\n<p>☛ 注意，上面的这些方法都只能获取到自己本身，可枚举的key或value，原型链上的是获取不到的，这就是它们与<code>for in</code>的区别，使用<code>for in</code>会把原型链上可枚举的属性也获取到。</p>\n<p>但是包括上面的方法以及<code>for in</code>，都是只能获取到可枚举的属性，不可枚举、和Symbol属性都是获取不到的</p>\n</blockquote>\n</li>\n</ol>\n<h3>获取所有的key，包括不可枚举、和symbol</h3>\n<ol>\n<li><code>Object.getOwnPropertyNames()</code>获取到自身的所有属性的key，包括不可枚举的属性，只包含字符串属性，不包括Symbol属性</li>\n<li><code>Object.getOwnPropertySymbols()</code>获取到自身的所有Symbol属性的key，如果对象没有Symbol属性，会返回一个空数组</li>\n</ol>\n<h3>其他</h3>\n<p>静态方法：</p>\n<ol>\n<li><code>Object.is()</code>，可以比较两个属性是否相等，它与<code>===</code>类似，但是有几个区别\n<ol>\n<li><code>===</code>会判定<code>NaN === NaN</code>为false，<code>+0 === -0</code>为true</li>\n<li><code>Object.is(NaN,NaN)</code>会返回true，<code>Object.is(+0, -0)</code>会返回false</li>\n</ol>\n</li>\n<li><code>Object.assign()</code>，可以赋值对象，不过是浅复制。</li>\n</ol>\n<p>原型链上的方法：</p>\n<ol>\n<li><code>hasOwnProperty()</code>可以判断自己身上是否有某个属性（不包含原型链上的，只是自己本身），symbol和不可枚举的也可以判断到</li>\n<li><code>propertyIsEnumerable()</code>判断自己身上的某个属性是否是可枚举的（不包含原型链上的，只是自己本身）</li>\n<li><code>isPrototypeOf()</code>判断对象是否在自己的原型链上，它与<code>instanceof</code>的区别在于，<code>instanceof</code>只会判断某个对象的<code>prtotype</code>属性，而这个方法是直接可以判断对象的。</li>\n<li><code>toLocalString()</code>可以忽略，用于衍生对象重载使用的</li>\n<li><code>valueOf()</code>也可以忽略，返回对象本身</li>\n<li><code>toString()</code>这个方法可以判断一个对象的真实类型，因为它会返回一个对象的类型字符串，<code>\'[object Type]\'</code>。</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object</a></p>\n<p><a href=\"https://segmentfault.com/a/1190000011294519\">https://segmentfault.com/a/1190000011294519</a></p>\n', '2021-12-04 10:45:44', '2021-12-04 10:45:44');
INSERT INTO `t_blog` VALUES ('48fb4e60-4606-11ec-96d5-7933aca11ca0', 'js中的new关键字', '使用常规的{}花括号可以创建一个对象，但是当我们想要创建相似的对象时，如果还使用{}就会产生很多冗余的代码，所以为了方便，js就设计了new关键字，我们可以对构造函数使用new操作符来创建一类相似的对象。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 3, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>使用常规的<code>{}</code>花括号可以创建一个对象，但是当我们想要创建相似的对象时，如果还使用<code>{}</code>就会产生很多冗余的代码，所以为了方便，js就设计了<code>new</code>关键字，我们可以对构造函数使用<code>new</code>操作符来创建一类相似的对象。</p>\n<h2>构造函数</h2>\n<h3>new</h3>\n<p>构造函数在技术上是常规函数。不过有两个约定：</p>\n<ol>\n<li>它们的命名通常以大写字母开头。</li>\n<li>它们只能由 <code>&quot;new&quot;</code> 操作符来执行。</li>\n</ol>\n<blockquote>\n<p>约定就是我们的代码书写习惯，应该尽量遵循。</p>\n</blockquote>\n<pre><code class=\"language-js\">function User(name) {\n    this.name = name;\n    this.isAdmin = false;\n}\n\nlet user = new User(&quot;Jack&quot;);\n\nconsole.log(user.name); // Jack\nconsole.log(user.isAdmin); // false\n</code></pre>\n<p>当一个函数被使用 <code>new</code> 操作符执行时，它按照以下步骤：</p>\n<ol>\n<li>一个新的空对象被创建并分配给 <code>this</code>。</li>\n<li>函数体执行。通常它会修改 <code>this</code>，为其添加新的属性。</li>\n<li>返回 <code>this</code> 的值。</li>\n</ol>\n<p>换句话说，<code>new User(...)</code> 做的就是类似的事情：</p>\n<pre><code class=\"language-js\">function User(name) {\n  // this = {};（隐式创建）\n\n  // 添加属性到 this\n  this.name = name;\n  this.isAdmin = false;\n\n  // return this;（隐式返回）\n}\n</code></pre>\n<p>所以 <code>new User(&quot;Jack&quot;)</code> 的结果是相同的对象：</p>\n<pre><code class=\"language-js\">let user = {\n  name: &quot;Jack&quot;,\n  isAdmin: false\n};\n</code></pre>\n<p>现在，如果我们想创建其他用户，我们可以调用 <code>new User(&quot;Ann&quot;)</code>，<code>new User(&quot;Alice&quot;)</code> 等。比每次都使用字面量创建要短得多，而且更易于阅读。</p>\n<p>这是构造器的主要目的 —— 实现可重用的对象创建代码。</p>\n<blockquote>\n<p>🚩从技术上讲，任何函数（除了箭头函数，它没有自己的 <code>this</code>）都可以用作构造器。即可以通过 <code>new</code> 来运行，它会执行上面的算法。“首字母大写”是一个共同的约定，以明确表示一个函数将被使用 <code>new</code> 来运行。</p>\n</blockquote>\n<h3>new.target（了解，不常用）</h3>\n<p>在一个函数内部，我们可以使用 <code>new.target</code> 属性来检查它是否被使用 <code>new</code> 进行调用了。</p>\n<p>对于常规调用，它为空，对于使用 <code>new</code> 的调用，则等于该函数：</p>\n<pre><code class=\"language-js\">function User() {\n    console.log(new.target);\n}\n\n// 不带 &quot;new&quot;：\nUser(); // undefined\n\n// 带 &quot;new&quot;：\nnew User(); // function User { ... }\n</code></pre>\n<p>它可以被用在函数内部，来判断该函数是被通过 <code>new</code> 调用的“构造器模式”，还是没被通过 <code>new</code> 调用的“常规模式”。</p>\n<p>我们也可以让 <code>new</code> 调用和常规调用做相同的工作，像这样：</p>\n<pre><code class=\"language-js\">function User(name) {\n    if (!new.target) { // 如果你没有通过 new 运行我\n        return new User(name); // ……我会给你添加 new\n    }\n\n    this.name = name;\n}\n\nlet john = User(&quot;John&quot;); // 将调用重定向到新用户\nconsole.log(john.name); // John\n</code></pre>\n<p>这种方法有时被用在库中以使语法更加灵活。这样人们在调用函数时，无论是否使用了 <code>new</code>，程序都能工作。</p>\n<p>不过，到处都使用它并不是一件好事，因为省略了 <code>new</code> 使得很难观察到代码中正在发生什么。而通过 <code>new</code> 我们都可以知道这创建了一个新对象。</p>\n<h3>构造器的return</h3>\n<p>通常，构造器没有 <code>return</code> 语句。它们的任务是将所有必要的东西写入 <code>this</code>，并自动转换为结果。</p>\n<p>但是，如果这有一个 <code>return</code> 语句，那么规则就简单了：</p>\n<ul>\n<li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li>\n<li>如果 <code>return</code> 返回的是一个原始类型，则忽略。</li>\n</ul>\n<p>换句话说，带有对象的 <code>return</code> 返回该对象，在所有其他情况下返回 <code>this</code>。</p>\n<p>例如，这里 <code>return</code> 通过返回一个对象覆盖 <code>this</code>：</p>\n<pre><code class=\"language-js\">function BigUser() {\n    this.name = &quot;John&quot;;\n    return { name: &quot;Godzilla&quot; };  // &lt;-- 返回这个对象\n}\n\nconsole.log(new BigUser().name);  // Godzilla，得到了那个对象\n</code></pre>\n<p>这里有一个 <code>return</code> 为空的例子（或者我们可以在它之后放置一个原始类型，没有什么影响）：</p>\n<pre><code class=\"language-js\">function SmallUser() {\n    this.name = &quot;John&quot;;\n    return; // &lt;-- 返回 this\n}\n\nconsole.log(new SmallUser().name);  // John\n</code></pre>\n<p>通常构造器没有 <code>return</code> 语句。这里我们主要为了完整性而提及返回对象的特殊行为。</p>\n<blockquote>\n<p>✈<strong>省略括号</strong></p>\n<p>顺便说一下，如果没有参数，我们可以省略 <code>new</code> 后的括号：</p>\n<pre><code class=\"language-js\">let user = new User; // &lt;-- 没有参数\n// 等同于\nlet user = new User();\n</code></pre>\n<p>这里省略括号不被认为是一种“好风格”，但是规范允许使用该语法。</p>\n</blockquote>\n<h3>构造器中的方法</h3>\n<p>使用构造函数来创建对象会带来很大的灵活性。构造函数可能有一些参数，这些参数定义了如何构造对象以及要放入什么。</p>\n<p>当然，我们不仅可以将属性添加到 <code>this</code> 中，还可以添加方法。</p>\n<p>例如，下面的 <code>new User(name)</code> 用给定的 <code>name</code> 和方法 <code>sayHi</code> 创建了一个对象：</p>\n<pre><code class=\"language-js\">function User(name) {\n    this.name = name;\n\n    this.sayHi = function () {\n        console.log(&quot;My name is: &quot; + this.name);\n    };\n}\n\nlet john = new User(&quot;John&quot;);\n\njohn.sayHi(); // My name is: John\n\n/*\njohn = {\n   name: &quot;John&quot;,\n   sayHi: function() { ... }\n}\n*/\n</code></pre>\n<h2>手写一个new</h2>\n<pre><code class=\"language-js\">function myNew() {\n    // 1、创建一个空对象\n    let obj = new Object()\n    let constructor = [].shift.call(arguments) // 获取构造方法\n\n    // 2、将新对象的原型指向 构造方法的prototype上\n    obj.__proto__ = constructor.prototype\n\n    // 3、获取到构造方法的返回值（如果原先构造方法有返回值，且是对象，那么原始的new会把这个对象返回出去，基本类型会忽略）\n\n    let ret = constructor.apply(obj, arguments) // 这里的arguments的第一个参数已经在最开始被shift了，所以剩下的参数全都是构造方法需要的值\n\n    // (ret || obj)是为了判断null，当为null时，也返回新对象\n    return typeof ret === \'object\' ? (ret || obj) : obj\n\n}\n</code></pre>\n<p>使用</p>\n<pre><code class=\"language-js\">function Person(name, age) {\n    this.name = name\n    this.age = age\n}\n\nlet p = myNew(Person, \'cheny\', 28)\nconsole.log(p instanceof Person);\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>\n<p>对构造函数使用<code>new</code>关键字会产生一个新对象。</p>\n</li>\n<li>\n<p>使用<code>new</code>时可以大致看成下面几步</p>\n<pre><code class=\"language-js\">function User(name) {\n  // 1、this = {};（隐式创建）\n\n  // 2、this.__proto__ = User.prototype\n\n  // 3、添加属性到 this\n  this.name = name;\n  this.isAdmin = false;\n\n  // 4、return this;（隐式返回）\n}\n</code></pre>\n</li>\n<li>\n<p>如果构造函数有返回值时，新对象有两种情况：</p>\n<ul>\n<li>如果 <code>return</code> 返回的是一个对象，则返回这个对象，而不是 <code>this</code>。</li>\n<li>如果 <code>return</code> 返回的是一个原始类型，则忽略。</li>\n</ul>\n</li>\n<li>\n<p>手写<code>new</code>时，应注意将新对象的<code>__proto__</code>指向构造方法的<code>prototype</code>上。</p>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/constructor-new\">https://zh.javascript.info/constructor-new</a></p>\n<p><a href=\"https://juejin.cn/post/6946022649768181774#heading-30\">https://juejin.cn/post/6946022649768181774#heading-30</a></p>\n', '2021-11-15 19:22:14', '2021-11-15 19:22:14');
INSERT INTO `t_blog` VALUES ('52704660-54e0-11ec-96d5-7933aca11ca0', '模式Patterns和修饰符flags', '正则表达式是搜索和替换字符串的一种强大方式。\n\n在 JavaScript 中，正则表达式通过内置的“RegExp”类的对象来实现，并与字符串集成。\n\n请注意，在各编程语言之间，正则表达式是有所不同的。在本教程中，我们只专注于 JavaScript。当然，它们有很多共同点，但在 Perl、Ruby 和 PHP 等语言下会有所不同。', '-1', 2, 'https://zh.javascript.info/regexp-introduction', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 10, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>正则表达式是搜索和替换字符串的一种强大方式。</p>\n<p>在 JavaScript 中，正则表达式通过内置的“RegExp”类的对象来实现，并与字符串集成。</p>\n<p>请注意，在各编程语言之间，正则表达式是有所不同的。在本教程中，我们只专注于 JavaScript。当然，它们有很多共同点，但在 Perl、Ruby 和 PHP 等语言下会有所不同。</p>\n<h2>正则表达式</h2>\n<p>正则表达式（可叫作“regexp”或者“reg”）包含 <strong>模式</strong> 和可选的 <strong>修饰符</strong>。</p>\n<p>两种创建方式：</p>\n<ol>\n<li>\n<p>较长一点的语法，使用<code>new RegExp()</code></p>\n<pre><code class=\"language-js\">regexp = new RegExp(&quot;pattern&quot;, &quot;flags&quot;);\n</code></pre>\n</li>\n<li>\n<p>较短的语法，使用反斜杠<code>/xxx/</code></p>\n<p>斜杠 <code>&quot;/&quot;</code> 会告诉 JavaScript 我们正在创建一个正则表达式。它的作用类似于字符串的引号。</p>\n<pre><code class=\"language-js\">regexp = /pattern/; // 没有修饰符\nregexp = /pattern/gmi; // 伴随修饰符 g、m 和 i（后面会讲到）\n</code></pre>\n</li>\n</ol>\n<h2>用法</h2>\n<p>如果要在字符串中进行搜索，可以使用 <a href=\"https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/search\">search</a> 方法。比如：</p>\n<pre><code class=\"language-js\">let str = &quot;I love JavaScript!&quot;; // 将在这里搜索\n\nlet regexp = /love/;\nconsole.log( str.search(regexp) ); // 2\n</code></pre>\n<p><code>str.search</code> 方法会查找模式 <code>/love/</code>，然后返回匹配项在字符串中的位置。我们可以猜到，<code>/love/</code> 是最简单的模式。它所做的就是简单的子字符串的查找。</p>\n<p>上面的代码等同于：</p>\n<pre><code class=\"language-js\">let str = &quot;I love JavaScript!&quot;; // 将在这里搜索\n\nlet substr = \'love\';\nconsole.log( str.search(substr) ); // 2\n</code></pre>\n<blockquote>\n<p>！什么时候使用 <code>new RegExp</code>?</p>\n<p>通常我们使用的都是简短语法 <code>/.../</code>。但是它不接受任何变量插入，所以我们必须在写代码的时候就知道确切的 regexp。</p>\n<p>另一方面，<code>new RegExp</code> 允许从字符串中动态地构造模式。</p>\n<p>所以我们可以找出需要搜索的字段，然后根据搜索字段创建 <code>new RegExp</code>：</p>\n<pre><code class=\"language-js\">let search = &quot;love&quot;; // 假设是从服务器接来的字符串\nlet regexp = new RegExp(search);\n\n// 找到用户想要的任何东西\nconsole.log( &quot;I love JavaScript&quot;.search(regexp));\n</code></pre>\n</blockquote>\n<h2>修饰符</h2>\n<p>正则表达式的修饰符可能会影响搜索结果。</p>\n<p>在 JavaScript 中，有 5 个修饰符：</p>\n<h3>i</h3>\n<p>使用此修饰符后，搜索时不区分大小写: <code>A</code> 和 <code>a</code> 没有区别（具体看下面的例子）。</p>\n<h3>g</h3>\n<p>使用此修饰符后，搜索时会查找所有的匹配项，而不只是第一个（在下一章会讲到）。</p>\n<h3>m</h3>\n<p>多行模式，只会影响到<code>^、$</code>，默认<code>^、$</code>匹配的是全文的开头和结尾，一旦使用<code>m</code>后，表示匹配每一行的开头和结尾（详见章节 <a href=\"http://www.bnbiye.cn/#/articleDetail/ae29d4d0-55a3-11ec-96d5-7933aca11ca0\">Flag &quot;m&quot; — 多行模式</a>）。</p>\n<h3>s</h3>\n<p>允许<code>.</code>运算符匹配换行符。默认<code>.</code>是匹配所有字符，但是不包括换行符，一旦开启<code>s</code>，<code>.</code>会连着换行符一起匹配。</p>\n<pre><code class=\"language-js\">let str = \'aaa\\nbbb\\nccc\'\nconsole.log(str.match(/.+/g)); // [ \'aaa\', \'bbb\', \'ccc\' ]\nconsole.log(str.match(/.+/gs)); // [ \'aaa\\nbbb\\nccc\' ]\n</code></pre>\n<h3>u</h3>\n<p>开启完整的 unicode 支持。该修饰符能够修正对于代理对的处理。更详细的内容见章节 <a href=\"http://www.bnbiye.cn/#/articleDetail/276f1d80-5579-11ec-96d5-7933aca11ca0\">Unicode：修饰符 “u” 和 class \\p{...}</a>。</p>\n<h3>y</h3>\n<p>粘滞模式，当在正则中想在指定位置处搜索时，可以使用<code>y</code>，是为了与<code>g</code>标志在指定位置处搜索做的区分。<code>g</code>在指定位置处搜索时默认会查找全部文本，<code>y</code>只会在当前位置搜索一次，并不会全文去匹配。（详见 <a href=\"http://www.bnbiye.cn/#/articleDetail/ef3306b0-581c-11ec-96d5-7933aca11ca0\">粘性标志 &quot;y&quot;，在位置处搜索</a>）</p>\n<h2>i修饰符</h2>\n<p>最简单的修饰符就是 <code>i</code> 了。</p>\n<p>示例代码如下：</p>\n<pre><code class=\"language-js\">let str = &quot;I love JavaScript!&quot;;\n\nconsole.log( str.search(/LOVE/) ); // -1（没找到）\nconsole.log( str.search(/LOVE/i) ); // 2\n</code></pre>\n<ol>\n<li>第一个搜索返回的是 <code>-1</code>（也就是没找到），因为搜索默认是区分大小写的。</li>\n<li>使用修饰符 <code>/LOVE/i</code>，在字符串的第 2 个位置上搜索到了 <code>love</code>。</li>\n</ol>\n<p>相比与简单的子字符串查找，<code>i</code> 修饰符已经让正则表达式变得更加强大了。但是这还不够。我们会在下一章节讲述其它修饰符和特性。</p>\n<h2>总结</h2>\n<ul>\n<li>一个正则表达式包含模式和可选修饰符：<code>g</code>、<code>i</code>、<code>m</code>、<code>u</code>、<code>y</code>。</li>\n<li>如果不使用我们在后面将要学到的修饰符和特殊标志，正则表达式的搜索就等同于子字符串查找。</li>\n<li><code>str.search(regexp)</code> 方法返回的是找到的匹配项的索引位置，如果没找到则返回 <code>-1</code>。</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-introduction\">https://zh.javascript.info/regexp-introduction</a></p>\n', '2021-12-04 16:58:17', '2021-12-09 10:20:51');
INSERT INTO `t_blog` VALUES ('53c38cb0-34a7-11ec-a1da-59f2d55bf031', '清除浮动', '清除浮动的三种方式，添加额外标签、添加伪类、父级变成BFC块', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 9, 0, 1, 2, 1, '', '<h2>添加额外标签<code>clear</code></h2>\n<pre><code class=\"language-html\">\n&lt;style&gt;\n    * {\n        margin: 0;\n    }\n\n    .box1 {\n        width: 200px;\n        height: 200px;\n        background-color: green;\n        float: left;\n    }\n\n    .box2 {\n        width: 300px;\n        height: 300px;\n        background-color: yellow;\n    }\n\n    .clear {\n        clear: both;\n    }\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<h2>使浮动元素的父级变为<code>BFC块</code></h2>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n\n    .parent {\n        overflow: hidden;\n    }\n\n    .box1 {\n        width: 200px;\n        height: 200px;\n        background-color: green;\n        float: left;\n    }\n\n    .box2 {\n        width: 300px;\n        height: 300px;\n        background-color: yellow;\n        float: left;\n    }\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;parent&quot;&gt;\n        &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n\n&lt;/body&gt;\n</code></pre>\n<h2>使用伪元素<code>:after</code></h2>\n<pre><code class=\"language-css\">.parent:after {\n    content: &quot;&quot;;\n    display: block;\n    height: 0;\n    clear: both;\n    visibility: hidden;\n}\n</code></pre>\n', '2021-10-24 16:49:41', '2021-10-24 16:49:41');
INSERT INTO `t_blog` VALUES ('53cf64b0-3d88-11ec-8015-f554da021b2a', '优化关键路径（引言篇）', '我们编写标记，屏幕上就会显示出漂亮的页面。浏览器到底是如何使用我们的 HTML、CSS 和 JavaScript 在屏幕上渲染像素的呢？', '-1', 2, 'https://developers.google.com/web/fundamentals/performance/critical-rendering-path', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 12, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p><em>优化关键渲染路径</em> 是指优先显示与当前用户操作有关的内容。</p>\n<p>要提供快速的网络体验，浏览器需要做许多工作。这类工作大多数是我们这些网络开发者看不到的: 我们编写标记，屏幕上就会显示出漂亮的页面。</p>\n<p>但浏览器到底是如何使用我们的 HTML、CSS 和 JavaScript 在屏幕上渲染像素的呢？</p>\n<p>从收到 HTML、CSS 和 JavaScript 字节到对其进行必需的处理，从而将它们转变成渲染的像素这一过程中有一些中间步骤，优化性能其实就是了解这些步骤中发生了什么 - 即<strong>关键渲染路径</strong> 。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041656620.png\" alt=\"image-20211104165618560\" /></p>\n<p>通过优化关键渲染路径，我们可以显著缩短首次渲染页面的时间。 此外，了解关键渲染路径还可以为构建高性能交互式应用打下基础。</p>\n<p>处理交互式更新的过程是相同的，只是在连续循环中完成，理想情况下每秒可以处理 60 帧！不过，我们先来看一下浏览器如何显示简单的网页。</p>\n<p>下一篇：<a href=\"http://www.bnbiye.cn/#/articleDetail/3fbc4640-3d89-11ec-97a5-ef78eceb5d73\">构建DOM树和CSSDOM树</a>]</p>\n', '2021-11-05 00:00:27', '2021-11-05 08:54:07');
INSERT INTO `t_blog` VALUES ('544247d0-4b8b-11ec-96d5-7933aca11ca0', 'js中的作用域', '我们知道js有作用域的概念，能否访问到某个变量，跟作用域有很大关系。在ES6之前，有全局作用域、函数作用域的概念，在ES6出现后，因为`let const`，出现了块级作用域的概念。我们通过例子来学习一下这几个作用域。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 9, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>我们知道js有作用域的概念，能否访问到某个变量，跟作用域有很大关系。在ES6之前，有全局作用域、函数作用域的概念，在ES6出现后，因为<code>let const</code>，出现了块级作用域的概念。我们通过例子来学习一下这几个作用域。</p>\n<h2>全局作用域</h2>\n<p>在代码中任何地方都能访问到的变量属于全局作用域。</p>\n<h3>例子1</h3>\n<p>最外层函数和最外层函数外面定义的变量属于全局作用域。</p>\n<pre><code class=\"language-js\">var a = \'aaa\' // 最外层的变量\n\nfunction fn() { // 最外层的函数\n\n    var b = \'bbb\' // 内层变量\n\n    function fn2() { // 内层函数\n        console.log(b);\n    }\n    fn2()\n}\n\nconsole.log(a); // aaa\n\nfn() // bbb\n\nconsole.log(b); // ReferenceError: b is not defined\n\nfn2() // ReferenceError: fn2 is not defined\n</code></pre>\n<h3>例子2</h3>\n<p>所有未定义直接赋值的变量，自动声明为拥有全局作用域。会直接挂载到全局对象上，浏览器端为<code>window</code>对象，node端为<code>global</code>对象。</p>\n<pre><code class=\"language-js\">// 浏览器端\nfunction fn() {\n    a = \'aaa\'\n    var b = \'bbb\'\n}\nfn()\nconsole.log(a); // aaa\nconsole.log(window.a); // aaa\nconsole.log(b); // ReferenceError: b is not defined\n</code></pre>\n<pre><code class=\"language-js\">// node环境\nfunction fn() {\n    a = \'aaa\'\n    var b = \'bbb\'\n}\nfn()\nconsole.log(a); // aaa\nconsole.log(global.a); // aaa\nconsole.log(b); // ReferenceError: b is not defined\n</code></pre>\n<h3>例子3</h3>\n<p>所有全局对象下的属性拥有全局作用域。（浏览器端是<code>window</code>，node端是<code>global</code>）</p>\n<pre><code class=\"language-js\">// 浏览器端\nfunction fn() {\n    console.log(alert); // ƒ alert() { [native code] }\n}\nfn()\nconsole.log(alert); // ƒ alert() { [native code] }\n</code></pre>\n<pre><code class=\"language-js\">// node端\nfunction fn() {\n    console.log(setImmediate); // [Function: setImmediate]\n}\nfn()\nconsole.log(setImmediate); // [Function: setImmediate]\n</code></pre>\n<h3>小结</h3>\n<ol>\n<li>最外层函数 和 在最外层函数外面定义的变量属于全局作用域。</li>\n<li>所有未定义，直接赋值的变量自动声明为属于全局作用域，比如<code>a = \'aaa\'</code></li>\n<li>全局对象下的属性属于全局作用域（浏览器端是<code>window</code>，node端是<code>global</code>）</li>\n</ol>\n<blockquote>\n<p>🚩在最外层使用<code>var</code>声明的变量，或者使用<code>function</code>声明的函数变量，浏览器端默认就直接挂载到了全局对象window上面，比如：</p>\n<pre><code class=\"language-js\">function fn() { }\nvar a = \'aaa\'\n\nconsole.log(window.a); // aaa\nconsole.log(window.fn); // ƒ fn() { }\n</code></pre>\n<p>如果，我们在最外层写了很多这样的代码，变量定义都没有用函数包裹，那么就全部挂载到了<code>window</code>对象上，很容易就污染全局命名空间，引起命名冲突。（node端没啥事，node这样写不会挂在在<code>global</code>对象上，如果想挂载上面一个新的全局对象，可以使用<code>globalThis.xxx = \'aaa\'，或者啥也不加xxx = \'aaa\'</code>）。</p>\n<p>其实导致这样的原因，还是因为<code>var</code>这个早期的变量声明方式，改成<code>let</code>就没啥事了，不过<code>function</code>声明的变量还是挂载上去：</p>\n<pre><code class=\"language-js\">function fn() { }\nlet a = \'aaa\'\n\nconsole.log(window.a); // undefined\nconsole.log(window.fn); // ƒ fn() { }\n</code></pre>\n<p>所以想避免，最好使用匿名的立即执行函数包裹一下：</p>\n<pre><code class=\"language-js\">(function () {\n    var a = \'aaa\'\n    function b() { }\n})()\n\nconsole.log(a); // ReferenceError: a is not defined，包裹后就不会污染全局对象了\nconsole.log(b); // ReferenceError: b is not defined\n</code></pre>\n</blockquote>\n<h2>函数作用域</h2>\n<p>函数作用域也是我们说的局部作用域，是指声明在函数内部的变量，只允许在函数的内部访问。函数作用域是分层的（因为可以函数套函数），内层作用域可以访问到外层的变量，反之则不行。比如：</p>\n<pre><code class=\"language-js\">function fn1() {\n    var a = \'aaa\'\n    function fn2() {\n        console.log(a);\n    }\n    fn2()\n}\nfn1() // aaa\nconsole.log(a); // ReferenceError: a is not defined\nfn2() // ReferenceError: fn2 is not defined\n</code></pre>\n<h2>块级作用域</h2>\n<p>要想弄懂块级作用域，先得搞懂<code>var </code>和  <code>let、const </code>。</p>\n<h3>var 和  let 、const</h3>\n<ul>\n<li>\n<p><code>var</code>和<code>function</code>声明的变量，在运行时，会先做一次变量提升，<code>var</code>提升的只是声明，真正赋值的还在之前的地方。</p>\n<p>块级作用域是<code>ES6</code>有了<code>let const</code>而新出的概念，在<code>ES5</code>时代，声明变量只能够使用<code>var</code>，但是<code>var</code>有很多反人类的设定，比如，你使用<code>var</code>声明一个变量后，你在声明位置处之前都能调用到这个变量，虽然是<code>undefined</code>，但是也很难受。我们都知道，这是因为js在执行一段代码时，会先有一个预编译的过程，<code>var</code>和<code>function</code>声明的变量都会做一个提升，比如下面的这段代码，你很难一眼看出来它输出个啥：</p>\n<pre><code class=\"language-js\">console.log(a);\nvar a = \'aaa\'\nfunction a() { }\nconsole.log(a);\n</code></pre>\n<p>我们其实可以在脑海里做一下提升，<code>var</code>和<code>function</code>都会提升，提升之后的效果就是最上面一排是<code>var</code>，然后是<code>function</code>，记住<code>var</code>只提升声明，提升后的效果如下：</p>\n<pre><code class=\"language-js\">var a // 提升\nfunction a() { } // 提升\nconsole.log(a); // [Function: a]\na = \'aaa\'\nconsole.log(a); // aaa\n</code></pre>\n<p>所以最后就看出来了，先输出<code>[Function: a]</code>，再输出<code>aaa</code>。</p>\n</li>\n<li>\n<p><code>var</code>声明的变量能够重复声明，不会报错，<code>let</code>和<code>const</code>就不行。</p>\n<p>如果我们用 <code>let</code> 在同一作用域下将同一个变量声明两次，则会出现错误：</p>\n<pre><code class=\"language-js\">let user;\nlet user; // SyntaxError: \'user\' has already been declared\n</code></pre>\n<p>但是使用 <code>var</code>，我们可以重复声明一个变量，不管多少次都行。如果我们对一个已经声明的变量使用 <code>var</code>，这条新的声明语句会被忽略：</p>\n<pre><code class=\"language-js\">var user = &quot;Pete&quot;;\nvar user = &quot;John&quot;; // 这个 &quot;var&quot; 无效（因为变量已经声明过了）\n// ……不会触发错误\nconsole.log(user) // John\n</code></pre>\n</li>\n<li>\n<p><code>var</code>声明的变量没有块级作用域（来了来了，太奇葩了）。</p>\n<p>用 <code>var</code> 声明的变量，不是函数作用域就是全局作用域。它们在代码块外也是可见的（也就是说，<code>var</code> 声明的变量只有函数作用域和全局作用域，没有块级作用域），比如下面这个例子：</p>\n<pre><code class=\"language-js\">if (true) {\n  var test = true; // 使用 &quot;var&quot; 而不是 &quot;let&quot;\n}\nconsole.log(test) // true，变量在 if 结束后仍存在\n</code></pre>\n<p>由于 <code>var</code> 会忽略代码块，因此我们有了一个全局变量 <code>test</code>。</p>\n<p>如果我们在第二行使用 <code>let test</code> 而不是 <code>var test</code>，那么该变量将仅在 <code>if</code> 内部可见：</p>\n<pre><code class=\"language-js\">if (true) {\n  let test = true; // 使用 &quot;let&quot;\n}\nconsole.log(test) // Error: test is not defined\n</code></pre>\n<p>对于循环也是这样的，<code>var</code> 声明的变量没有块级作用域也没有循环局部作用域：</p>\n<pre><code class=\"language-js\">for (var i = 0; i &lt; 10; i++) {\n  var one = 1;\n  // ...\n}\nconsole.log(i) // 10，&quot;i&quot; 在循环结束后仍可见，它是一个全局变量\nconsole.log(one) // 1，&quot;one&quot; 在循环结束后仍可见，它是一个全局变量\n</code></pre>\n<p>对于普通代码块也是这样的，比如：</p>\n<pre><code class=\"language-js\">{\n    var message = &quot;Hello&quot;;\n}\n\n{\n    var message = &quot;Goodbye&quot;;\n}\n\nconsole.log(message); // Goodbye\n</code></pre>\n<p>根本就没有块的概念，直接在最外边拿到了最后一次赋值的<code>Goodbye</code>，但是<code>let</code>却有块的概念，如果改为<code>let</code>声明，在代码块的外部是访问不到<code>message</code>的，只能在代码块的内部访问，比如：</p>\n<pre><code class=\"language-js\">{\n    let message = &quot;Hello&quot;;\n    console.log(message) // Hello\n}\n\n{\n    let message = &quot;Goodbye&quot;;\n    console.log(message) // Goodbye\n}\n\nconsole.log(message); // ReferenceError: message is not defined\n</code></pre>\n<p>可以看到，<code>var</code> 穿透了 <code>if</code>，<code>for</code> 和其它代码块。这是因为在早期的 JavaScript 中，块没有词法环境，而 <code>var</code> 就是这个时期的代表之一。</p>\n</li>\n</ul>\n<blockquote>\n<p><code>const</code>与<code>let</code>的基本特性都是一致的，无法重复声明，声明位置处之前是无法使用的，有块级作用域。它俩唯一的区别是，<code>const</code>声明的变量，声明时就必须给个初始值，不给就会报错。而一旦初始化值后，该值是不允许在改变的。所以<code>const</code>一般用来声明一些不需要改变的值，比如<code>Math.PI</code>等等。</p>\n</blockquote>\n<h3>块级作用域小结</h3>\n<p>通过了解<code>var</code>和<code>let、const</code>的区别后，我们也已经知道了块级作用域到底是个什么东西，如果变量全部使用老古董<code>var</code>去声明，根本就没有块级作用域的概念，只有当使用<code>let、const</code>声明时，才有这个概念。所以简单的总结一下。</p>\n<ol>\n<li>块级作用域可以通过<code>let</code>和<code>const</code>来触发，<code>var</code>不会触发块级作用域。</li>\n<li>只要有花括号<code>{}</code>，使用<code>let</code>和<code>const</code>后，都可以触发块级作用域，比如基本的代码块<code>{}</code>、<code>if</code>中的代码块<code>if(){}</code>、<code>for</code>中的代码块<code>for(){}</code>、<code>function</code>中的代码块<code>function(){}</code>等等。</li>\n<li>使用<code>let</code>和<code>const</code>触发块级作用域后，变量不会提升，不允许重复声明，声明的变量只能在当前的代码块内部使用。</li>\n</ol>\n<h2>作用域链</h2>\n<p>作用域也有链的概念，在函数作用域声明变量时，函数里面可以套函数，这样层层嵌套，最后也形成了一个链式结构。当访问一个变量时，类似于原型链，也会一层一层的向上找，如果当前作用域找不到，就到父作用域找，一直找到全局作用域如果还没找到，那么就直接报错（<code>ReferenceError: xxx is not defined</code>）。</p>\n<blockquote>\n<p>🚩在作用域链中找一个变量时，会首先在函数创建的那个作用域里找，这里必须强调一下“创建”，而不是“调用”。比如：</p>\n<pre><code class=\"language-js\">let a = 10\nfunction fn() {\n    let b = 20\n    function fn2() {\n        console.log(a + b);\n    }\n    return fn2\n}\n\nlet x = fn()\nlet b = 200\nx() // 30 最后结果是 30 而不是 210，所以与创建的作用域有关，与在哪里调用无关\n</code></pre>\n</blockquote>\n<h2>总结</h2>\n<ol>\n<li>在ES6之前，js只有全局作用域和函数作用域的概念（也称局部作用域），ES6之后，随着<code>let和const</code>的出现，出现了块级作用域的概念。</li>\n<li>全局作用域是指：使用<code>function</code>声明在最外层的函数 或者 声明在最外层函数外边的变量，这些变量就属于全局作用域。\n<ol>\n<li>如果在浏览器环境下，在最外层使用<code>var</code>和<code>function</code>声明的变量，会默认挂在在全局对象<code>window</code>下面。</li>\n<li>全局对象下的属性和方法，都属于全局作用域（浏览器端为<code>window</code>，node端为<code>global</code>）。</li>\n<li>如果不加任何修饰，直接对一个变量赋值，比如<code>a = 10</code>，那么这个变量将会直接被挂载到全局对象上（浏览器端挂载在<code>window</code>上，node端挂载到<code>global</code>上）。</li>\n</ol>\n</li>\n<li>函数作用域也称局部作用域，是指声明在函数内部的变量，只有在函数内部才能访问到。函数作用域是分层的，内层作用域可以访问到外层的变量，反之不可以。</li>\n<li>块级作用域是ES6出现的概念，只有当使用<code>let</code>或者<code>const</code>才会触发，<code>var</code>不会触发块级作用域。\n<ol>\n<li>只要有花括号<code>{}</code>，使用<code>let</code>和<code>const</code>后，都可以触发块级作用域，比如基本的代码块<code>{}</code>、<code>if</code>中的代码块<code>if(){}</code>、<code>for</code>中的代码块<code>for(){}</code>、<code>function</code>中的代码块<code>function(){}</code>等等。</li>\n<li>使用<code>let</code>和<code>const</code>触发块级作用域后，变量不会提升，不允许重复声明，变量只能在当前的代码块内部使用。</li>\n</ol>\n</li>\n<li>作用域链的概念类似于原型链，当访问一个变量时，会首先在函数当前作用域中找，如果找不到就去父作用域中找，直到找到为止，如果找不到，就会报错（<code>ReferenceError: xxx is not defined</code>）。\n<ol>\n<li>注意：找变量时，是在函数<code>创建</code>的作用域下一层一层往上找，跟<code>调用</code>的位置没关系。</li>\n</ol>\n</li>\n<li><code>var</code>和<code>let、const</code>的区别\n<ol>\n<li><code>var</code>有变量提升，允许重复声明，可以在声明前调用。（注意，<code>function</code>声明的函数也会提升，如果同时存在<code>var</code>和<code>function</code>，最终提升的效果是<code>var</code>的声明总会在<code>function</code>的上面）。</li>\n<li><code>var</code>只有全局作用域和函数作用域的概念，那些花括号包裹的代码块，比如<code>{}</code>、<code>if(){}</code>、<code>for(){}</code>、<code>while(){}</code>，（除了<code>function</code>包裹的函数作用域外），<code>var</code>全都会无视它们，都会将变量的声明提升到花括号外面去。</li>\n<li><code>let</code>和<code>const</code>不存在变量提升、不允许重复声明、不允许在声明之前调用。</li>\n<li>使用<code>let</code>和<code>const</code>声明的变量会触发块级作用域，即上面说的那些花括号<code>{}</code>包裹的变量，变量只能在当前块下面访问，外部是访问不到的。</li>\n<li><code>const</code>相较于<code>let</code>还是有点区别的，<code>const</code>一般用于声明常量，且在声明时必须初始化一个值，否则会报错，而一旦初始化值后，就不能再改变。<code>let</code>则可以先声明，等使用的时候再进行赋值，也可以声明时直接赋值。<code>let</code>声明的变量允许改变。</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/var#var-mei-you-kuai-ji-zuo-yong-yu\">https://zh.javascript.info/var#var-mei-you-kuai-ji-zuo-yong-yu</a></p>\n', '2021-11-22 19:57:12', '2021-11-22 19:57:12');
INSERT INTO `t_blog` VALUES ('556df770-51ea-11ec-96d5-7933aca11ca0', 'js中的数字类型number', '在js中，number有两种表示方法，常规数字和bigint，本章看一下常规的数字类型都有哪些需要注意的地方。', '-1', 2, 'https://zh.javascript.info/number', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 8, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>在js中，number有两种表示方法，常规数字和bigint。</p>\n<p>在现代 JavaScript 中，数字（number）有两种类型：</p>\n<ol>\n<li>JavaScript 中的常规数字以 64 位的格式 <a href=\"https://en.wikipedia.org/wiki/IEEE_754-2008_revision\">IEEE-754</a> 存储，也被称为“双精度浮点数”。这是我们大多数时候所使用的数字，我们将在本章中学习它们。</li>\n<li>BigInt 数字，用于表示任意长度的整数。有时会需要它们，因为常规数字不能超过 <code>253</code> 或小于 <code>-253</code>。由于仅在少数特殊领域才会用到 BigInt，因此我们在特殊的章节 <a href=\"https://zh.javascript.info/bigint\">BigInt</a> 中对其进行了介绍。</li>\n</ol>\n<p>所以，在这里我们将讨论常规数字类型。现在让我们开始学习吧。</p>\n<h2>数字的简单表示1e6</h2>\n<p>数字如果零很多的时候，可以使用<code>e</code>表示，<code>e</code>后面跟个数字，表示补充多少0，比如：</p>\n<pre><code class=\"language-js\">let a = 1000000 // 6个0\nlet b = 1e6 // 表示 1* 1000000\nconsole.log(a === b) // true\n\nlet c = 0.0000001 // 1. 小数点向左移动7位，所以数0的个数的话，前面正好有7个0\nlet d = 1e-7 // 表示 1/ 10000000（7个0）\nconsole.log(c === d); // true\n</code></pre>\n<h2>十六进制、二进制和八进制</h2>\n<h3>十六进制</h3>\n<p><a href=\"https://en.wikipedia.org/wiki/Hexadecimal\">十六进制</a> 数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。所以自然地，有一种较短的写方法：<code>0x</code>，然后是数字。</p>\n<p>使用前缀<code>0x</code>表示的数字，可用数字和字母表示<code>0-9 a-f</code>，</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let a = 0xff // 16进制 使用0x为前缀 0-9 a-f\n\nconsole.log(a); // 255\nconsole.log(typeof a); // number\n\nconsole.log(0xa); // 10\nconsole.log(0xb); // 11\nconsole.log(0xc); // 12\nconsole.log(0xd); // 13\nconsole.log(0xe); // 14\nconsole.log(0xf); // 15\n</code></pre>\n<h3>二进制</h3>\n<p>前缀使用<code>Ob</code>表示的数字，只可以使用<code>0 1</code>表示</p>\n<pre><code class=\"language-js\">let a = 0b11111111 // 二进制形式的 255\nconsole.log(a); // 255\n\nconsole.log(0b0); // 0\nconsole.log(0b1); // 1\n</code></pre>\n<h3>八进制</h3>\n<p>前缀使用<code>0o</code>表示的数字，可以使用数字为<code>0-7</code></p>\n<pre><code class=\"language-js\">let a = 0o377 // 八进制形式的 255\nconsole.log(a); // 255\n\nconsole.log(0o0); // 0\nconsole.log(0o1); // 1\nconsole.log(0o2); // 2\nconsole.log(0o3); // 3\nconsole.log(0o4); // 4\nconsole.log(0o5); // 5\nconsole.log(0o6); // 6\nconsole.log(0o7); // 7\n</code></pre>\n<blockquote>\n<p>注意：只有这三种进制支持这种写法。对于其他进制，我们应该使用函数 <code>parseInt</code></p>\n</blockquote>\n<h2>number.toString(base)</h2>\n<p>方法 <code>num.toString(base)</code> 返回在给定 <code>base</code> 进制数字系统中 <code>num</code> 的字符串表示形式。</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let num = 255;\nlet a = num.toString(16)\nlet b = num.toString(8)\nlet c = num.toString(2)\n\nconsole.log(a); // ff\nconsole.log(b); // 377\nconsole.log(c); // 11111111\n\nconsole.log(typeof a); // string\nconsole.log(typeof b); // string\nconsole.log(typeof c); // string\n</code></pre>\n<p><code>base</code> 的范围可以从 <code>2</code> 到 <code>36</code>。默认情况下是 <code>10</code>。</p>\n<p>常见的用例如下：</p>\n<ul>\n<li><strong>base=16</strong> 用于十六进制颜色，字符编码等，数字可以是 <code>0..9</code> 或 <code>A..F</code>。</li>\n<li><strong>base=2</strong> 主要用于调试按位操作，数字可以是 <code>0</code> 或 <code>1</code>。</li>\n<li><strong>base=36</strong> 是最大进制，数字可以是 <code>0..9</code> 或 <code>A..Z</code>。所有拉丁字母都被用于了表示数字。对于 <code>36</code> 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 URL。可以简单地使用基数为 <code>36</code> 的数字系统表示：</li>\n</ul>\n<pre><code class=\"language-js\">console.log(123456..toString(36)); // 2n9c\n</code></pre>\n<blockquote>\n<p><strong>使用两个点来调用一个方法</strong></p>\n<p>请注意 <code>123456..toString(36)</code> 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 <code>toString</code>，那么我们需要在它后面放置两个点 <code>..</code>。</p>\n<p>如果我们放置一个点：<code>123456.toString(36)</code>，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。</p>\n<p>也可以写成 <code>(123456).toString(36)</code>。</p>\n</blockquote>\n<h2>舍入</h2>\n<p>舍入（rounding）是使用数字时最常用的操作之一。</p>\n<p>这里有几个对数字进行舍入的内建函数：</p>\n<h3>Math.floor</h3>\n<p>向下舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-2</code>。</p>\n<h3>Math.ceil</h3>\n<p>向上舍入：<code>3.1</code> 变成 <code>4</code>，<code>-1.1</code> 变成 <code>-1</code>。</p>\n<h3>Math.round</h3>\n<p>向最近的整数舍入：<code>3.1</code> 变成 <code>3</code>，<code>3.6</code> 变成 <code>4</code>，<code>-1.1</code> 变成 <code>-1</code>。</p>\n<h3>Math.trunc（IE 浏览器不支持这个方法）</h3>\n<p>移除小数点后的所有内容而没有舍入：<code>3.1</code> 变成 <code>3</code>，<code>-1.1</code> 变成 <code>-1</code>。</p>\n<h3>小例子</h3>\n<pre><code class=\"language-js\">let num = 3.4\nlet a = Math.floor(num)\nlet b = Math.ceil(num)\nlet c = Math.round(num)\nlet d = Math.trunc(num)\n\nconsole.log(a); // 3\nconsole.log(b); // 4\nconsole.log(c); // 3\nconsole.log(d); // 3\n\nconsole.log(typeof a); // number\nconsole.log(typeof b); // number\nconsole.log(typeof c); // number\nconsole.log(typeof d); // number\n</code></pre>\n<p>这些函数涵盖了处理数字小数部分的所有可能方法。但是，如果我们想将数字舍入到小数点后 <code>n</code> 位，该怎么办？</p>\n<p>例如，我们有 <code>1.2345</code>，并且想把它舍入到小数点后两位，仅得到 <code>1.23</code>。</p>\n<p>有两种方式可以实现这个需求：</p>\n<ol>\n<li>\n<p>乘除法</p>\n<p>例如，要将数字舍入到小数点后两位，我们可以将数字乘以 <code>100</code>（或更大的 10 的整数次幂），调用舍入函数，然后再将其除回。</p>\n<pre><code class=\"language-js\">let num = 1.23456;\nlet a = Math.floor(num * 100) / 100\n\nconsole.log(a); // 1.23\nconsole.log(typeof a); // number\n</code></pre>\n</li>\n<li>\n<p>函数 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed\">toFixed(n)</a> 将数字舍入到小数点后 <code>n</code> 位，并以字符串形式返回结果。</p>\n<pre><code class=\"language-js\">let num1 = 1.34\nlet num2 = 1.35\n\nlet a = num1.toFixed(1)\nlet b = num2.toFixed(1)\n\n// 截断时类似于Math.round，会四舍五入\nconsole.log(a); // 1.3\nconsole.log(b); // 1.4\n\n// 返回的是字符串\nconsole.log(typeof a); // string\nconsole.log(typeof b); // string\n\n// 位数不够会补0\nconsole.log(1.34.toFixed(5)); // 1.34000\n</code></pre>\n<p>我们可以使用一元加号或 <code>Number()</code> 调用，将其转换为数字：<code>+ num.toFixed(5)</code>。</p>\n</li>\n</ol>\n<h2>不精确的计算</h2>\n<p>在内部，数字是以 64 位格式 <a href=\"http://en.wikipedia.org/wiki/IEEE_754-1985\">IEEE-754</a> 表示的，所以正好有 64 位可以存储一个数字：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。</p>\n<p>如果一个数字太大，则会溢出 64 位存储，并可能会导致无穷大：</p>\n<pre><code class=\"language-js\">console.log(1e500); // Infinity\n</code></pre>\n<p>这可能不那么明显，但经常会发生的是，精度的损失。</p>\n<p>考虑下这个（falsy！）测试：</p>\n<pre><code class=\"language-js\">console.log(0.1 + 0.2 === 0.3); // false\n</code></pre>\n<p>没错，如果我们检查 <code>0.1</code> 和 <code>0.2</code> 的总和是否为 <code>0.3</code>，我们会得到 <code>false</code>。</p>\n<p>奇了怪了！如果不是 <code>0.3</code>，那能是啥？</p>\n<pre><code class=\"language-js\">console.log(0.1 + 0.2); // 0.30000000000000004\n</code></pre>\n<p>哎哟！这个错误比不正确的比较的后果更严重。想象一下，你创建了一个电子购物网站，如果访问者将价格为 <code>¥ 0.10</code> 和 <code>¥ 0.20</code> 的商品放入了他的购物车。订单总额将是 <code>¥ 0.30000000000000004</code>。这会让任何人感到惊讶。</p>\n<p>但为什么会这样呢？</p>\n<p>一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 <code>0.1</code>，<code>0.2</code> 这样的小数，实际上在二进制形式中是无限循环小数。</p>\n<p>换句话说，什么是 <code>0.1</code>？<code>0.1</code> 就是 <code>1</code> 除以 <code>10</code>，<code>1/10</code>，即十分之一。在十进制数字系统中，这样的数字表示起来很容易。将其与三分之一进行比较：<code>1/3</code>。三分之一变成了无限循环小数 <code>0.33333(3)</code>。</p>\n<p>在十进制数字系统中，可以保证以 <code>10</code> 的整数次幂作为除数能够正常工作，但是以 <code>3</code> 作为除数则不能。也是同样的原因，在二进制数字系统中，可以保证以 <code>2</code> 的整数次幂作为除数时能够正常工作，但 <code>1/10</code> 就变成了一个无限循环的二进制小数。</p>\n<p>使用二进制数字系统无法 <strong>精确</strong> 存储 <em>0.1</em> 或 <em>0.2</em>，就像没有办法将三分之一存储为十进制小数一样。</p>\n<p>IEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许我们看到“极小的精度损失”，但是它确实存在。</p>\n<p>我们可以看到：</p>\n<pre><code class=\"language-js\">console.log(0.1.toFixed(20)); // 0.10000000000000000555\n</code></pre>\n<p>当我们对两个数字进行求和时，它们的“精度损失”会叠加起来。</p>\n<p>这就是为什么 <code>0.1 + 0.2</code> 不等于 <code>0.3</code>。</p>\n<blockquote>\n<p><strong>不仅仅是 JavaScript</strong></p>\n<p>许多其他编程语言也存在同样的问题。</p>\n<p>PHP，Java，C，Perl，Ruby 给出的也是完全相同的结果，因为它们基于的是相同的数字格式。</p>\n</blockquote>\n<p>我们能解决这个问题吗？当然，最可靠的方法是借助方法 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed\">toFixed(n)</a> 对结果进行舍入：</p>\n<pre><code class=\"language-js\">let sum = 0.1 + 0.2;\nconsole.log(sum.toFixed(2)); // 0.30\n</code></pre>\n<p>请注意，<code>toFixed</code> 总是返回一个字符串。它确保小数点后有 2 位数字。如果我们有一个电子购物网站，并需要显示 <code>¥ 0.30</code>，这实际上很方便。对于其他情况，我们可以使用一元加号将其强制转换为一个数字：</p>\n<pre><code class=\"language-js\">let sum = 0.1 + 0.2;\nconsole.log(+sum.toFixed(2)); // 0.3\n</code></pre>\n<p>我们可以将数字临时乘以 100（或更大的数字），将其转换为整数，进行数学运算，然后再除回。当我们使用整数进行数学运算时，误差会有所减少，但仍然可以在除法中得到：</p>\n<pre><code class=\"language-js\">console.log((0.1 * 10 + 0.2 * 10) / 10); // 0.3\nconsole.log((0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001\n</code></pre>\n<blockquote>\n<p><strong>有趣的事儿</strong></p>\n<p>尝试运行下面这段代码：</p>\n<pre><code class=\"language-js\">// Hello！我是一个会自我增加的数字！\nconsole.log(9999999999999999); //  显示 10000000000000000\n</code></pre>\n<p>出现了同样的问题：精度损失。有 64 位来表示该数字，其中 52 位可用于存储数字，但这还不够。所以最不重要的数字就消失了。</p>\n<p>JavaScript 不会在此类事件中触发 error。它会尽最大努力使数字符合所需的格式，但不幸的是，这种格式不够大到满足需求。</p>\n</blockquote>\n<h2>isFinite和isNaN</h2>\n<p>还记得这两个特殊的数值吗？</p>\n<ul>\n<li><code>Infinity</code>（和 <code>-Infinity</code>）是一个特殊的数值，比任何数值都大（小）。</li>\n<li><code>NaN</code> 代表一个 error。</li>\n</ul>\n<p>它们属于 <code>number</code> 类型，但不是“普通”数字，因此，这里有用于检查它们的特殊函数：</p>\n<ul>\n<li>\n<p><code>isNaN(value)</code> 将其参数转换为数字，然后测试它是否为 <code>NaN</code>：</p>\n<pre><code class=\"language-js\">console.log(isNaN(NaN)); // true\nconsole.log(isNaN(\'123\')); // false\nconsole.log(isNaN(\'a123\')); // true\n</code></pre>\n</li>\n<li>\n<p><code>isFinite(value)</code> 将其参数转换为数字，如果是常规数字，则返回 <code>true</code>，而不是 <code>NaN/Infinity/-Infinity</code>：</p>\n<pre><code class=\"language-js\">console.log( isFinite(&quot;15&quot;) ); // true\nconsole.log( isFinite(&quot;str&quot;) ); // false，因为是一个特殊的值：NaN\nconsole.log( isFinite(Infinity) ); // false，因为是一个特殊的值：Infinity\n</code></pre>\n<p>有时 <code>isFinite</code> 被用于验证字符串值是否为常规数字。</p>\n<p>请注意，在所有数字函数中，包括 <code>isFinite</code>，空字符串或仅有空格的字符串均被视为 <code>0</code>。</p>\n<blockquote>\n<p><strong>与 <code>Object.is</code> 进行比较</strong></p>\n<p>有一个特殊的内建方法 <a href=\"https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/is\"><code>Object.is</code></a>，它类似于 <code>===</code> 一样对值进行比较，但它对于两种边缘情况更可靠：</p>\n<ol>\n<li>它适用于 <code>NaN</code>：<code>Object.is(NaN，NaN) === true</code>，这是件好事。</li>\n<li>值 <code>0</code> 和 <code>-0</code> 是不同的：<code>Object.is(0，-0) === false</code>，从技术上讲这是对的，因为在内部，数字的符号位可能会不同，即使其他所有位均为零。</li>\n</ol>\n<p>在所有其他情况下，<code>Object.is(a，b)</code> 与 <code>a === b</code> 相同。</p>\n<p>这种比较方式经常被用在 JavaScript 规范中。当内部算法需要比较两个值是否完全相同时，它使用 <code>Object.is</code>（内部称为 <a href=\"https://tc39.github.io/ecma262/#sec-samevalue\">SameValue</a>）。</p>\n</blockquote>\n</li>\n</ul>\n<h2>parseInt与parseFloat</h2>\n<p>使用加号 <code>+</code> 或 <code>Number()</code> 的数字转换是严格的。如果一个值不完全是一个数字，就会失败：</p>\n<pre><code class=\"language-js\">console.log( +&quot;100px&quot; ); // NaN\n</code></pre>\n<p>唯一的例外是字符串开头或结尾的空格，因为它们会被忽略。</p>\n<p>但在现实生活中，我们经常会有带有单位的值，例如 CSS 中的 <code>&quot;100px&quot;</code> 或 <code>&quot;12pt&quot;</code>。并且，在很多国家，货币符号是紧随金额之后的，所以我们有 <code>&quot;19€&quot;</code>，并希望从中提取出一个数值。</p>\n<p>这就是 <code>parseInt</code> 和 <code>parseFloat</code> 的作用。</p>\n<p>它们可以从字符串中“读取”数字，直到无法读取为止。如果发生 error，则返回收集到的数字。函数 <code>parseInt</code> 返回一个整数，而 <code>parseFloat</code> 返回一个浮点数：</p>\n<pre><code class=\"language-js\">console.log( parseInt(\'100px\') ); // 100\nconsole.log( parseFloat(\'12.5em\') ); // 12.5\n\nconsole.log( parseInt(\'12.3\') ); // 12，只有整数部分被返回了\nconsole.log( parseFloat(\'12.3.4\') ); // 12.3，在第二个点出停止了读取\n</code></pre>\n<p>某些情况下，<code>parseInt/parseFloat</code> 会返回 <code>NaN</code>。当没有数字可读时会发生这种情况：</p>\n<pre><code class=\"language-js\">console.log( parseInt(\'a123\') ); // NaN，第一个符号停止了读取\n</code></pre>\n<blockquote>\n<p><strong>parseInt(str, radix)` 的第二个参数</strong></p>\n<p><code>parseInt()</code> 函数具有可选的第二个参数。它指定了数字系统的基数，因此 <code>parseInt</code> 还可以解析十六进制数字、二进制数字等的字符串：</p>\n<pre><code class=\"language-js\">console.log( parseInt(\'0xff\', 16) ); // 255\nconsole.log( parseInt(\'ff\', 16) ); // 255，没有 0x 仍然有效\n\nconsole.log( parseInt(\'2n9c\', 36) ); // 123456\n</code></pre>\n</blockquote>\n<h2>总结</h2>\n<p>要写有很多零的数字：</p>\n<ul>\n<li>将 <code>&quot;e&quot;</code> 和 0 的数量附加到数字后。就像：<code>123e6</code> 与 <code>123</code> 后面接 6 个 0 相同。</li>\n<li><code>&quot;e&quot;</code> 后面的负数将使数字除以 1 后面接着给定数量的零的数字。例如 <code>123e-6</code> 表示 <code>0.000123</code>（<code>123</code> 的百万分之一）。</li>\n</ul>\n<p>对于不同的数字系统：</p>\n<ul>\n<li>可以直接在十六进制（<code>0x</code>），八进制（<code>0o</code>）和二进制（<code>0b</code>）系统中写入数字。</li>\n<li><code>parseInt(str，base)</code> 将字符串 <code>str</code> 解析为在给定的 <code>base</code> 数字系统中的整数，<code>2 ≤ base ≤ 36</code>。</li>\n<li><code>num.toString(base)</code> 将数字转换为在给定的 <code>base</code> 数字系统中的字符串。</li>\n</ul>\n<p>要将 <code>12pt</code> 和 <code>100px</code> 之类的值转换为数字：</p>\n<ul>\n<li>使用 <code>parseInt/parseFloat</code> 进行“软”转换，它从字符串中读取数字，然后返回在发生 error 前可以读取到的值。</li>\n</ul>\n<p>小数：</p>\n<ul>\n<li>使用 <code>Math.floor</code>，<code>Math.ceil</code>，<code>Math.trunc</code>，<code>Math.round</code> 或 <code>num.toFixed(precision)</code> 进行舍入。</li>\n<li>请确保记住使用小数时会损失精度。</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/number\">https://zh.javascript.info/number</a></p>\n', '2021-11-30 22:32:23', '2021-11-30 22:33:47');
INSERT INTO `t_blog` VALUES ('561993b0-4e5b-11ec-96d5-7933aca11ca0', '闭包', '面试的时候经常会问到闭包的概念，经常是一时语塞，不知道怎么回答。本篇文章就来对闭包做一个总结，通过回答下面几个问题，让你彻底了解闭包。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 1, 4, 0, 1, 2, 1, 'http://cdn.qiniu.bnbiye.cn/img/202111241022319.png', '<h2>前言</h2>\n<p>面试的时候经常会问到闭包的概念，经常是一时语塞，不知道怎么回答。本篇文章就来对闭包做一个总结，通过回答下面几个问题，让你彻底了解闭包。</p>\n<ol>\n<li>什么是闭包</li>\n<li>闭包的作用原理</li>\n<li>js中的词法环境</li>\n<li>闭包的应用场景</li>\n</ol>\n<h2>什么是闭包</h2>\n<p>我们先来看一个闭包的例子。</p>\n<h3>一个小例子</h3>\n<p>在下面的代码中，我们声明了一个函数<code>fn()</code>，返回值是一个匿名函数。所以我们调用一下<code>fn()</code>可以拿到这个匿名函数，将其赋值到<code>fn2</code>变量上，然后调用<code>fn2</code>。这时你会惊奇的发现，我们每次调用<code>fn2</code>，都能够访问到<code>fn</code>中定义的变量<code>a</code>，并且每执行一次，<code>a</code>都会在原来的基础上自增1。也就是说，<code>fn</code>函数内部定义的变量<code>a</code>，并没有在<code>fn()</code>执行完毕后销毁掉，仍然存储在内存中。这是为什么呢？</p>\n<p>按我们正常的理解，原函数<code>fn()</code>在调用一次后，内部的局部变量<code>a</code>理应被销毁掉了（大部分语言都具有的特性），但是在这个例子中我们发现并没有。这是为什么呢？</p>\n<pre><code class=\"language-js\">function fn() {\n    let a = 10\n    return function () {\n        return a++\n    }\n}\n\nlet fn2 = fn()\nconsole.log(fn2()); //10\nconsole.log(fn2()); //11\nconsole.log(fn2()); //12\n</code></pre>\n<h3>闭包的定义</h3>\n<p>实际上，上述例子中返回的匿名函数，就是<code>js</code>中所谓的闭包。因此我们给出js中闭包的定义，如下：</p>\n<p><strong>闭包：是指内部函数总是可以访问到其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。</strong></p>\n<p>定义参考：<a href=\"https://zh.javascript.info/closure\">https://zh.javascript.info/closure</a></p>\n<h2>闭包的作用原理</h2>\n<pre><code class=\"language-js\">function fn() {\n    let a = 10\n    return function () {\n        return a++\n    }\n}\n\nlet fn2 = fn()\nconsole.log(fn2()); //10\nconsole.log(fn2()); //11\nconsole.log(fn2()); //12\n</code></pre>\n<p>我们从内存和词法环境的角度分析一下上面的例子，如下图所示：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241022319.png\" alt=\"闭包\" /></p>\n<ol>\n<li>\n<p>我们使用<code>function</code>创建了一个函数<code>fn</code>时，函数存储在堆内存中，对应的变量指向内存地址（图中的<code>Ox123</code>）。</p>\n</li>\n<li>\n<p>当使用<code>let fn2 = fn()</code>我们获取到<code>fn</code>的返回值时，得到了一个新的匿名函数（图中的<code>Ox456</code>），变量<code>fn2</code>指向这块内存地址。</p>\n<blockquote>\n<p>🚩在js中，每个运行的函数，代码块<code>{}</code>以及整个脚本，都有一个被称为词法环境的内部（隐藏）的关联对象，该对象由两部分组成：</p>\n<ul>\n<li>环境记录（Environment Record）：一个存储所有局部变量作为其属性（还包括一些其他信息，例如<code>this</code>的值）的对象。</li>\n<li>对外部词法环境的引用<code>[[Environment]]</code>，与外部代码相关联。</li>\n</ul>\n<p>函数在创建时，<code>js</code>引擎就默认将该函数创建时对外部环境的引用保存了下来（也即自己来自哪里），所以，，本例中的<code>fn2()</code>，因为它是执行<code>fn1()</code>创建出来的，所以<code>fn2()</code>的词法环境会保留着<code>fn1</code>的引用（图中<code>Ox456</code>中的<code>[[Environment]]: Ox123</code>），所以当<code>fn2</code>在自己的词法环境中没有找到某个变量时，就会去它外部的词法环境<code>Ox123</code>中去寻找。</p>\n<p>参考：<a href=\"https://zh.javascript.info/closure\">https://zh.javascript.info/closure</a></p>\n</blockquote>\n</li>\n<li>\n<p>当我们调用<code>fn2()</code>时，返回值是<code>a++</code>，而<code>Ox456</code>的词法环境中并没有变量<code>a</code>，所以会去外部词法环境（<code>Ox123</code>）中找，于是就找到<code>Ox123</code>中的<code>let a = 10</code>。</p>\n</li>\n<li>\n<p>当调用多次<code>fn2()</code>时，每次访问的都是<code>Ox123</code>中的<code>a</code>变量，所以<code>a</code>变量将在同一位置处增加到<code>11，12</code>等。</p>\n</li>\n</ol>\n<h2>词法环境</h2>\n<p>在上面分析闭包的作用原理时，提到了词法环境的概念，这有点涉及到了js底层的一些概念，我们来一起看一下js的词法环境是个啥。</p>\n<p>为了使内容更清晰，这里将分步骤进行讲解。</p>\n<p>参考：<a href=\"https://zh.javascript.info/closure\">https://zh.javascript.info/closure</a></p>\n<h3>Step 1. 变量</h3>\n<p>在 JavaScript 中，每个运行的函数，代码块 <code>{...}</code> 以及整个脚本，都有一个被称为 <strong>词法环境（Lexical Environment）</strong> 的内部（隐藏）的关联对象。</p>\n<p>词法环境对象由两部分组成：</p>\n<ol>\n<li><strong>环境记录（Environment Record）</strong>： 一个存储所有局部变量作为其属性（包括一些其他信息，例如 <code>this</code> 的值）的对象。</li>\n<li>对 <strong>外部词法环境</strong> 的引用，与外部代码相关联。</li>\n</ol>\n<p>一个“变量”只是 <strong>环境记录</strong> 这个特殊的内部对象的一个属性。“获取或修改变量”意味着“获取或修改词法环境的一个属性”。</p>\n<p>举个例子，这段没有函数的简单的代码中只有一个词法环境：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241140688.png\" alt=\"image-20211124114030634\" /></p>\n<p>这就是所谓的与整个脚本相关联的 <strong>全局</strong> 词法环境。</p>\n<p>在上面的图片中，矩形表示环境记录（变量存储），箭头表示外部引用。全局词法环境没有外部引用，所以箭头指向了 <code>null</code>。</p>\n<p>随着代码开始并继续运行，词法环境发生了变化。</p>\n<p>这是更长的代码：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241141440.png\" alt=\"image-20211124114115401\" /></p>\n<p>右侧的矩形演示了执行过程中全局词法环境的变化：</p>\n<ol>\n<li>当脚本开始运行，词法环境预先填充了所有声明的变量。\n<ul>\n<li>最初，它们处于“未初始化（Uninitialized）”状态。这是一种特殊的内部状态，这意味着引擎知道变量，但是在用 <code>let</code> 声明前，不能引用它。几乎就像变量不存在一样。</li>\n</ul>\n</li>\n<li>然后 <code>let phrase</code> 定义出现了。它尚未被赋值，因此它的值为 <code>undefined</code>。从这一刻起，我们就可以使用变量了。</li>\n<li><code>phrase</code> 被赋予了一个值。</li>\n<li><code>phrase</code> 的值被修改。</li>\n</ol>\n<p>现在看起来都挺简单的，是吧？</p>\n<ul>\n<li>变量是特殊内部对象的属性，与当前正在执行的（代码）块/函数/脚本有关。</li>\n<li>操作变量实际上是操作该对象的属性。</li>\n</ul>\n<blockquote>\n<p>👨<strong>词法环境是一个规范对象</strong></p>\n<p>“词法环境”是一个规范对象（specification object）：它仅仅是存在于 <a href=\"https://tc39.es/ecma262/#sec-lexical-environments\">编程语言规范</a> 中的“理论上”存在的，用于描述事物如何运作的对象。我们无法在代码中获取该对象并直接对其进行操作。</p>\n<p>但 JavaScript 引擎同样可以优化它，比如清除未被使用的变量以节省内存和执行其他内部技巧等，但显性行为应该是和上述的无差。</p>\n</blockquote>\n<h3>Step 2. 函数声明</h3>\n<p>一个函数其实也是一个值，就像变量一样。</p>\n<p><strong>不同之处在于函数声明的初始化会被立即完成。</strong></p>\n<p>当创建了一个词法环境（Lexical Environment）时，函数声明会立即变为即用型函数（不像 <code>let</code> 那样直到声明处才可用）。</p>\n<p>这就是为什么我们可以在（函数声明）的定义之前调用函数声明。</p>\n<p>例如，这是添加一个函数时全局词法环境的<strong>初始状态</strong>：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241149112.png\" alt=\"image-20211124114950054\" /></p>\n<p>正常来说，这种行为仅适用于函数声明，而不适用于我们将函数分配给变量的函数表达式，例如 <code>let say = function(name)...</code>。</p>\n<h3>Step 3. 内部和外部的词法环境</h3>\n<p>在一个函数运行时，在调用刚开始时，会自动创建一个新的词法环境以存储这个调用的局部变量和参数。</p>\n<p>例如，对于 <code>say(&quot;John&quot;)</code>，它看起来像这样（当前执行位置在箭头标记的那一行上）：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241151226.png\" alt=\"image-20211124115136181\" /></p>\n<p>在这个函数调用期间，我们有两个词法环境：内部一个（用于函数调用）和外部一个（全局）：</p>\n<ul>\n<li>内部词法环境与 <code>say</code> 的当前执行相对应。它具有一个单独的属性：<code>name</code>，函数的参数。我们调用的是 <code>say(&quot;John&quot;)</code>，所以 <code>name</code> 的值为 <code>&quot;John&quot;</code>。</li>\n<li>外部词法环境是全局词法环境。它具有 <code>phrase</code> 变量和函数本身。</li>\n</ul>\n<p>内部词法环境引用了 <code>outer</code>。</p>\n<blockquote>\n<p>👩<strong>当代码要访问一个变量时 —— 首先会搜索内部词法环境，然后搜索外部环境，然后搜索更外部的环境，以此类推，直到全局词法环境。</strong></p>\n<p>如果在任何地方都找不到这个变量，那么在严格模式下就会报错（在非严格模式下，为了向下兼容，给未定义的变量赋值会创建一个全局变量）。</p>\n<p>未定义的变量就是没有使用<code>let、const</code>或者<code>var</code>声明的变量，比如<code>a = 10</code>，没有任何前缀，这种变量在非严格模式下会直接挂载到全局对象下面（浏览器端是window，node端是global）。</p>\n</blockquote>\n<p>在这个示例中，搜索过程如下：</p>\n<ul>\n<li>对于 <code>name</code> 变量，当 <code>say</code> 中的 <code>alert</code> 试图访问 <code>name</code> 时，会立即在内部词法环境中找到它。</li>\n<li>当它试图访问 <code>phrase</code> 时，然而内部没有 <code>phrase</code>，所以它顺着对外部词法环境的引用找到了它。</li>\n</ul>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241157226.png\" alt=\"image-20211124115717176\" /></p>\n<h3>Step 4. 返回函数</h3>\n<p>看一个例子：</p>\n<pre><code class=\"language-js\">function makeCounter() {\n  let count = 0;\n\n  return function() {\n    return count++;\n  };\n}\n\nlet counter = makeCounter();\n</code></pre>\n<p>在每次 <code>makeCounter()</code> 调用的开始，都会创建一个新的词法环境对象，以存储该 <code>makeCounter</code> 运行时的变量。</p>\n<p>因此，我们有两层嵌套的词法环境，就像上面的示例一样：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241214514.png\" alt=\"image-20211124121441462\" /></p>\n<p>不同的是，在执行 <code>makeCounter()</code> 的过程中创建了一个仅占一行的嵌套函数：<code>return count++</code>。我们尚未运行它，仅创建了它。</p>\n<p><strong>所有的函数在“诞生”时都会记住创建它们的词法环境</strong>。从技术上讲，这里没有什么魔法：所有函数都有名为 <code>[[Environment]]</code> 的隐藏属性，该属性保存了对创建该函数的词法环境的引用。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241216437.png\" alt=\"image-20211124121602390\" /></p>\n<p>因此，<code>counter.[[Environment]]</code> 有对 <code>{count: 0}</code> 词法环境的引用。这就是函数记住它创建于何处的方式，与函数被在哪儿调用无关。<code>[[Environment]]</code> 引用在函数创建时被设置并永久保存。</p>\n<p>稍后，当调用 <code>counter()</code> 时，会为该调用创建一个新的词法环境，并且其外部词法环境引用获取于 <code>counter.[[Environment]]</code>：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241217924.png\" alt=\"image-20211124121726875\" /></p>\n<p>现在，当 <code>counter()</code> 中的代码查找 <code>count</code> 变量时，它首先搜索自己的词法环境（为空，因为那里没有局部变量），然后是外部 <code>makeCounter()</code> 的词法环境，并且在哪里找到就在哪里修改。</p>\n<p><strong>在变量所在的词法环境中更新变量。</strong></p>\n<p>这是执行后的状态：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111241218671.png\" alt=\"image-20211124121842622\" /></p>\n<p>如果我们调用 <code>counter()</code> 多次，<code>count</code> 变量将在同一位置增加到 <code>2</code>，<code>3</code> 等。</p>\n<blockquote>\n<p>👴通过本小节对词法环境的学习，对闭包中内部函数为何能访问到外部环境中的变量有了更深刻的理解。</p>\n<p>上面这种，内部函数可以访问到外部函数中的变量和参数，即使在其外部函数被返回（寿命终结）了之后也没关系，这样的函数就称之为闭包。</p>\n<p>在某些编程语言中，这是不可能的，或者应该以特殊的方式编写函数来实现。但是在在 JavaScript 中，因为有了闭包和词法环境，就出现了这样的效果。如果仔细的去思考，你会发现，其实在 JavaScript 中，<strong>所有函数都是天生闭包的</strong>。</p>\n<p>也就是说：JavaScript 中的函数会自动通过隐藏的 <code>[[Environment]]</code> 属性记住创建它们的位置，所以它们都可以访问外部变量。</p>\n<p>（不过有个例外，使用<code>new Function()</code>创建的函数，其<code>[[Environment]]</code>会默认指向全局环境，因此，此类函数无法访问外部（outer）变量，只能访问全局变量），<code>new Function()</code>的使用参考另一篇文章 <a href=\"https://zh.javascript.info/new-function\">new-function</a>。</p>\n<p>在面试时，前端开发者通常会被问到“什么是闭包？”，正确的回答应该是闭包的定义，并解释清楚为什么 JavaScript 中的所有函数都是闭包的，以及可能的关于 <code>[[Environment]]</code> 属性和词法环境原理的技术细节。</p>\n</blockquote>\n<h2>应用场景</h2>\n<h3>柯里化函数</h3>\n<p>假如有个获取面积的函数，如下面的代码所示，假如宽总是同一个值，每次都需要重新写一份。</p>\n<pre><code class=\"language-js\">// 假设我们有一个求长方形面积的函数\nfunction getArea(width, height) {\n    return width * height\n}\n// 如果我们碰到的长方形的宽总是10\nconst area1 = getArea(10, 20)\nconst area2 = getArea(10, 30)\nconst area3 = getArea(10, 40)\n</code></pre>\n<p>我们可以使用闭包，将函数做一次封装，如下：</p>\n<pre><code class=\"language-js\">// 我们可以使用闭包柯里化这个计算面积的函数\nfunction getArea(width) {\n    return height =&gt; {\n        return width * height\n    }\n}\n\nconst getTenWidthArea = getArea(10)\n// 之后碰到宽度为10的长方形就可以这样计算面积\nconst area1 = getTenWidthArea(20)\n\n// 而且如果遇到宽度偶尔变化也可以轻松复用\nconst getTwentyWidthArea = getArea(20)\n</code></pre>\n<p>柯里化可以避免频繁调用具有相同参数函数，同时又能够轻松的复用。</p>\n<h3>实现私有方法或变量</h3>\n<pre><code class=\"language-js\">function funOne(i){\n    function funTwo(){\n        console.log(\'数字：\' + i);\n    }\n    return funTwo;\n};\nvar fa = funOne(110);\nvar fb = funOne(111);\nvar fc = funOne(112);\nfa();       // 输出：数字：110\nfb();       // 输出：数字：111\nfc();       // 输出：数字：112\n</code></pre>\n<p>其实就是模块的方式, 现代化的打包最终其实就是每个模块的代码都是相互独立的。</p>\n<h3>立即调用函数 IIFE</h3>\n<p>在之前，JavaScript 中只有 <code>var</code> 这一种声明变量的方式，并且这种方式声明的变量没有块级作用域，程序员们就发明了一种模仿块级作用域的方法。这种方法被称为“立即调用函数表达式”（immediately-invoked function expressions，IIFE）。</p>\n<p>如今，我们不应该再使用 IIFE 了，但是你可以在旧脚本中找到它们。</p>\n<p>IIFE 看起来像这样：</p>\n<pre><code class=\"language-js\">(function() {\n\n  var message = &quot;Hello&quot;;\n\n  console.log(message); // Hello\n\n})();\n</code></pre>\n<p>这里，创建了一个函数表达式并立即调用。因此，代码立即执行并拥有了自己的私有变量。</p>\n<p>函数表达式被括号 <code>(function {...})</code> 包裹起来，因为当 JavaScript 引擎在主代码中遇到 <code>&quot;function&quot;</code> 时，它会把它当成一个函数声明的开始。但函数声明必须有一个函数名，所以这样的代码会导致错误：</p>\n<pre><code class=\"language-js\">// 尝试声明并立即调用一个函数\nfunction() { // SyntaxError: Function statements require a function name\n\n  var message = &quot;Hello&quot;;\n\n  console.log(message); \n\n}();\n</code></pre>\n<p>即使我们说：“好吧，那我们加一个名称吧”，但它仍然不工作，因为 JavaScript 不允许立即调用函数声明：</p>\n<p>因此，需要使用圆括号把该函数表达式包起来，以告诉 JavaScript，这个函数是在另一个表达式的上下文中创建的，因此它是一个函数表达式：它不需要函数名，可以立即调用。</p>\n<p>除了使用括号，还有其他方式可以告诉 JavaScript 在这我们指的是函数表达式：</p>\n<pre><code class=\"language-js\">// 创建 IIFE 的方法\n\n(function() {\n  console.log(&quot;Parentheses around the function&quot;);\n})();\n\n(function() {\n  console.log(&quot;Parentheses around the whole thing&quot;);\n}());\n\n!function() {\n  console.log(&quot;Bitwise NOT operator starts the expression&quot;);\n}();\n\n+function() {\n  console.log(&quot;Unary plus starts the expression&quot;);\n}();\n</code></pre>\n<p>在上面的所有情况中，我们都声明了一个函数表达式并立即运行它。请再注意一下：如今我们没有理由来编写这样的代码。</p>\n<h3>缓存一些结果</h3>\n<pre><code class=\"language-js\">function funParent(){\n    let memo = [];\n    function funTwo(i){\n        memo.push(i);\n        console.log(memo.join(\',\'))\n    }\n    return funTwo;\n};\n\nconst fn = funParent();\n\nfn(1); // 1\nfn(2); // 1,2\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>闭包是指：内部函数总能够访问到外部函数的变量和参数，即使外部函数被返回了（寿命终结）之后</li>\n<li>在 JavaScript 中，每个运行的函数，代码块 <code>{...}</code> 以及整个脚本，都有一个被称为 <strong>词法环境（Lexical Environment）</strong> 的内部（隐藏）的关联对象。对象包括两部分\n<ol>\n<li><strong>环境记录（Environment Record）</strong>： 一个对象，存储了它所有的局部变量，还包括一些其他信息，例如 <code>this</code> 的值。</li>\n<li>对 <strong>外部词法环境</strong> 的引用<code>[[Environment]]</code>，与外部代码相关联（函数在创建时，js引擎就默认给绑定上了，我们是访问不到的）。</li>\n</ol>\n</li>\n<li>因为函数在创建时，会默认绑定外部词法环境<code>[[Environment]]</code>（即自己从哪来的），所以js中所有的函数都是天然闭包。但是有一个例外，使用<code>new Function</code>创建的函数，创建时引擎会默认将<code>[[Environment]]</code>绑定在全局，所以它是无法访问到局部变量的。</li>\n<li>因为闭包的这些特性，所以有下面几个应用场景：\n<ol>\n<li>函数柯里化：将函数封装为<code>fn()()()</code>的形式，在某些应用场景上会更灵活。</li>\n<li>实现私有方法或变量：其实就是模块化的最终结果，为了各个模块不相互影响，每个模块实际上都是一个独立的闭包。</li>\n<li>立即调用函数 IIFE：早期没有块级作用域时，为了实现私有变量，程序员发明的模仿块级作用域的方法，<code>(function(){})()</code>。</li>\n<li>缓存结果：将计算的结果，先保存在闭包父级函数的某个变量上，在执行闭包函数时，先进行一次判断，如果已经有了计算结果，直接从缓存中拿。</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/closure\">https://zh.javascript.info/closure</a></p>\n', '2021-11-26 09:51:13', '2021-11-26 09:55:21');
INSERT INTO `t_blog` VALUES ('56340d60-3b7f-11ec-8015-f554da021b2a', '防抖和节流', '在绑定scroll、resize这类事件时，被触发的频率是非常高的，每次触发都会执行绑定的事件函数。如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。所以就出现了节流和防抖技术。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 15, 0, 1, 2, 1, '', '<p>在绑定scroll、resize这类事件时，被触发的频率是非常高的，每次触发都会执行绑定的事件函数。如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。所以就出现了节流和防抖技术。</p>\n<h2>防抖debouncing，怎么个防抖法？</h2>\n<h3>防抖和不防抖前后会有什么效果</h3>\n<p>假如不防抖，只要你一直滚鼠标滑轮，就会一直触发事件函数。但是将你的事件函数，通过防抖函数包裹一下之后，整体给人的感觉就变了。你随便滑，事件函数就是不触发，只有当你停止滑动时，然后等待延时毫秒数之后，事件函数才会触发。或者是你随便滑，只有在刚开始执行一次事件函数，其余时间都不执行。</p>\n<p>一句话总结一下：当停止滑动的时候才会触发事件函数，或，只有最开始执行一次事件函数（不太严谨，但是就这个效果）</p>\n<h3>简易版防抖函数</h3>\n<p>下面实现一个简易版的防抖函数，有几点需要注意一下</p>\n<ul>\n<li>当给window绑定scroll事件后，每次滚动窗口时都会触发绑定的事件函数</li>\n<li>实际的事件函数是<code>debounce</code>函数的返回值，返回值也是一个函数，所以每次都会执行这个返回值</li>\n<li>返回值里实际做了两件事，先清除定时器timeout，然后再赋值一个新的</li>\n</ul>\n<blockquote>\n<p>question：这里为什么每次都能访问到同一个timeout</p>\n<p>因为执行的是返回的函数，然后timeout定义在执行函数的外面，那么可以看作这个timeout是声明在全局里，所以每次访问的都是同一个。</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;script&gt;\n    // 简单的防抖动函数\n    function debounce(func, wait) {\n        // 定时器\n        let timeout\n        return function () {\n            // 每次触发滚动事件时先清除定时器\n            clearTimeout(timeout)\n            // 指定 xx ms后触发真正想执行的操作\n            timeout = setTimeout(func, wait)\n        }\n    }\n    // 等待绑定的事件函数\n    function realHandleFunc() {\n        console.log(\'在滚动\');\n    }\n\n    // 没采用防抖\n    // window.addEventListener(\'scroll\', realHandleFunc)\n\n    // 采用防抖\n    window.addEventListener(\'scroll\', debounce(realHandleFunc, 500))\n&lt;/script&gt;\n</code></pre>\n<h3>优化后的防抖函数</h3>\n<p>增加了一个是否立即执行的标识immediate，控制事件函数是在滚动最开始执行还是滚动结束后执行，true表示一开始就立即执行，false表示滚动停止后执行。</p>\n<ul>\n<li>\n<p>当immediate为false，滚动停止后执行，分析如下</p>\n<ol>\n<li>当不停的滚动窗口时，开始调用绑定的debounce函数</li>\n<li>实际调用的是debounce函数的返回值（因为debounce返回值为一个函数）</li>\n<li>执行返回函数时，先定义了变量later，不用管，程序继续往下走</li>\n<li>因为immediate为false，所以callNow的值也为false，程序继续往下走</li>\n<li>先清除一下上一次滚动设置的timeout ，clearTimeout(timeout)</li>\n<li>给timeout设置延时函数，timeout = setTimeout(later, wait)</li>\n<li>callNow为false，不执行函数 func</li>\n</ol>\n<p>因为不停的在滚动，所以会一直重复上面的3-7步，当停止滚动时，这时看第6步，还有最后一个延时函数没有清除，所以等待wait毫秒后，就会执行第三步定义得later函数，later函数做了两件事，清除最后一次的timeout，此时的<code>!immediate</code>的值为true，所以会执行最终的执行函数 func。这样就达成了我们想要的效果——真正的执行函数只在滚动停止后执行一遍，其余时间不执行。（在later函数，增加对immediate的判断是为了和滚动一开始就执行的情况做兼容处理）。</p>\n</li>\n<li>\n<p>当immediate为true时，滚动一开始就执行，持续滚动期间不再执行，分析如下</p>\n<ol>\n<li>当不停的滚动窗口时，开始调用绑定的debounce函数</li>\n<li>实际调用的是debounce函数的返回值，因为debounce返回值为一个函数</li>\n<li>执行返回函数时，先定义了变量later，不用管，程序继续往下走</li>\n<li>因为immediate为true，第一次进来时 timeout尚未赋值，所以<code>!timeout</code>的值也为true，得到callNow的值为true</li>\n<li>先清除一下上一次滚动设置的timeout ，clearTimeout(timeout)</li>\n<li>给timeout设置延时函数，timeout = setTimeout(later, wait)</li>\n<li>首次callNow为true，立即执行最终的事件函数 func()</li>\n</ol>\n<p>然后因为不停的滚动，会再次重复上面的3-7步，只不过略有不同，因为不是第一次了，callNow的值有所改变，从第4步开始改变<br />\n4. 因为immediate为true，此时 timeout已经被上一次的执行函数附上了值，所以<code>!timeout</code>的值为false，得到callNow的值为false<br />\n4. 先清除一下上一次滚动设置的timeout ，clearTimeout(timeout)<br />\n4. 给timeout设置延时函数，timeout = setTimeout(later, wait)<br />\n4. callNow为false，不会再次执行一遍 func()</p>\n<p>当最后停止滚动时，这时看第6步，还有最后一个延时函数没有清除，所以等待wait毫秒后，就会执行第三步定义的later函数，later函数做了两件事，清除最后一次的timeout，然后此时的<code>!immediate</code>的值为false，所以也不会再执行一遍 func函数。这样就达成了我们想要的效果——真正的执行函数只在刚滚动的时候执行一遍，其余时间不执行。</p>\n</li>\n</ul>\n<pre><code class=\"language-html\">&lt;script&gt;\n    // 优化后的防抖动函数\n    function debounce(func, wait, immediate) {\n        // 定时器\n        let timeout\n        return function () { // 2\n            \n            let later = function () { // 3\n                timeout = null\n                if (!immediate) func()\n            }\n\n            let callNow = immediate &amp;&amp; !timeout // 4\n            clearTimeout(timeout) // 5\n\n            timeout = setTimeout(later, wait) // 6\n            if (callNow) func() // 7\n        }\n    }\n    // 等待绑定的事件函数\n    function realHandleFunc() {\n        console.log(\'在滚动\');\n    }\n\n    // 没采用防抖\n    // window.addEventListener(\'scroll\', realHandleFunc)\n\n    // 采用防抖\n    window.addEventListener(\'scroll\', debounce(realHandleFunc, 500, false)) // 1\n&lt;/script&gt;\n</code></pre>\n<h2>节流throttling，怎么个节流法？</h2>\n<p>防抖是挺好用的，但是也无法适宜于所有的场景，因为防抖只能在滚动刚开始或者滚动结束时执行事件函数。那么假如在图片懒加载的场景下，我们希望图片在不停的下滑时也能加载出来，而不是停止下滑后，等待wait毫秒的延迟后才加载。这个时候，我们希望即使页面在不断被滚动，但是滚动 handler 也可以以一定的频率被触发（譬如 250ms 触发一次），这类场景，就要用到另一种技巧，称为节流函数（throttling）。</p>\n<h3>简易版节流函数</h3>\n<p><code>throttle(func, wait, mustRun)</code></p>\n<p>func：为真正的需要被执行的函数</p>\n<p>wait：真正的执行函数间隔多少毫秒执行一次</p>\n<p>mustRun：在不停止滑动时，每间隔mustRun毫秒，执行函数必须被执行一次</p>\n<p>分析代码的执行</p>\n<ol>\n<li>当不停的滚动窗口时，开始调用绑定的throttle函数</li>\n<li>实际调用的是throttle函数的返回值，因为throttle返回值为一个函数</li>\n<li>执行返回函数时，先定义了当前时间currentTime，不用管，程序继续往下走</li>\n<li>先清除一下上一次的timeout，程序继续往下走</li>\n<li>在返回函数的函数体外，声明了一个startTime（因为startTime声明在返回函数的外部，所以可以默认当作全局变量，所以在每次执行返回函数时，都能访问到这个唯一的startTime），判断已经过去的时间间隔（currentTime - startTime）是否大于必须执行的时间间隔（mustRun）<br />\n5.1 若果大于，说明执行函数该执行了，执行func，然后更新startTime的值（startTime = currentTime<br />\n5.2 若果不大于，说明间隔时间还没到，不用执行，重新赋值timeout（timeout = setTimeout(func, wait)）</li>\n</ol>\n<p>所以就实现了期望的效果，即使在滑动途中，也能每间隔一段间隔时间触发一次执行函数。注意，在停止滚动的时候，还有最后一次的timeout没有清除，所以停住滚动后，间隔wait毫秒后还会执行一次func。</p>\n<pre><code class=\"language-html\">&lt;script&gt;\n    // 简单的节流函数\n    function throttle(func, wait, mustRun) {\n        // 定时器\n        let timeout\n        let startTime = new Date()\n\n        return function () { // 2\n            let currentTime = new Date() // 3\n            clearTimeout(timeout) // 4\n\n\n            // 如果达到了规定的触发时间间隔， 触发handler\n            if (currentTime - startTime &gt;= mustRun) { // 5.1\n                func()\n                startTime = currentTime\n            } else { // 5.2\n                timeout = setTimeout(func, wait)\n            }\n\n        }\n    }\n    // 等待绑定的事件函数\n    function realHandleFunc() {\n        console.log(\'在滚动\');\n    }\n\n    // 没采用防抖\n    // window.addEventListener(\'scroll\', realHandleFunc)\n\n    // 采用防抖\n    window.addEventListener(\'scroll\', throttle(realHandleFunc, 500, 1000)) // 1\n&lt;/script&gt;\n</code></pre>\n<h2>应用场景</h2>\n<ul>\n<li>图片的懒加载</li>\n<li>Echarts的resize</li>\n<li>滚动到一定位置后，显示返回顶部图标</li>\n</ul>\n<h2>参考链接</h2>\n<p><a href=\"https://www.cnblogs.com/coco1s/p/5499469.html\">https://www.cnblogs.com/coco1s/p/5499469.html</a></p>\n', '2021-11-02 09:51:03', '2021-11-02 10:11:33');
INSERT INTO `t_blog` VALUES ('5a41a680-59b4-11ec-96d5-7933aca11ca0', 'Date的常用方法', '本章对`js`中的`Date`对象常用方法做一个梳理。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 11, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>本章对<code>js</code>中的<code>Date</code>对象常用方法做一个梳理。</p>\n<h2>构造方法</h2>\n<p>可以使用<code>new Date()</code>创建一个日期的实例对象。如果不使用<code>new</code>，直接调用构造方法，会返回一个当前时间的字符串。</p>\n<pre><code class=\"language-js\">// 不使用new 返回一个本地时间的字符串\nconsole.log(Date()); // Fri Dec 10 2021 11:59:55 GMT+0800 (中国标准时间)\nconsole.log(typeof Date());  // string\n\n// 使用new，才会创建一个时间类型的对象\nlet date = new Date()\nconsole.log(date); // 2021-12-10T03:59:55.176Z\nconsole.log(typeof date); // object\nconsole.log(Object.prototype.toString.call(date)); // [object Date]\n</code></pre>\n<p>构造方法的参数有四种基本形式</p>\n<ol>\n<li>\n<p>没有参数：表示实例化的是当前的日期和时间</p>\n<pre><code class=\"language-js\">let date = new Date()\nconsole.log(date) // 2021-12-10T04:15:40.078Z\nconsole.log(typeof date); // object\n</code></pre>\n</li>\n<li>\n<p>Unix时间戳：传的是一个整数值，代表的从<code>1970-01-01 00:00:00</code>开始的毫秒数，如果是负数，就是之前的时间</p>\n<pre><code class=\"language-js\">// 1970-01-01 00:00:00\nlet date1 = new Date(0)\nconsole.log(date1); // 1970-01-01T00:00:00.000Z\n\n// 1970-01-01 00:00:00 的后一秒\nlet date2 = new Date(1000)\nconsole.log(date2); // 1970-01-01T00:00:01.000Z\n\n// 1970-01-01 00:00:00 的前一秒\nlet date3 = new Date(-1000)\nconsole.log(date3); // 1969-12-31T23:59:59.000Z\n</code></pre>\n</li>\n<li>\n<p>表示日期的字符串</p>\n<p>如果只有一个参数，并且是字符串，那么它会被自动解析。该算法与 <code>Date.parse</code> 所使用的算法相同，我们将在下文中进行介绍。</p>\n<pre><code class=\"language-js\">/* \n字符串的格式应该为 YYYY-MM-DDTHH:mm:ss.sssZ\n1. YYYY-MM-DD —— 日期：年-月-日。\n2. 字符 &quot;T&quot; 是一个分隔符。\n3. HH:mm:ss.sss —— 时间：小时，分钟，秒，毫秒。\n4. 可选字符 \'Z\' 为 +-hh:mm 格式的时区。单个字符 Z 代表 UTC+0 时区。\n*/\nlet date1 = new Date(\'2021-12-10\')\nconsole.log(date1); // 2021-12-10T00:00:00.000Z\n/*\n2021-12-10T00:00:00.000Z 表示 UTC标准时区\n如果是北京时间，因为在东八区，表示的时间应该为\n2021-12-10T08:00:00.000+08:00\n*/\n\n\n// 字符串是UTC标准时间\nlet date2 = new Date(\'2021-12-10T12:33:10.123Z\')\nconsole.log(date2); // 2021-12-10T12:33:10.123Z\n\n// 字符串是东八区时间格式 东八区的时间被转换为了UTC标准时间\nlet date3 = new Date(\'2021-12-10T13:49:10.123+08:00\')\nconsole.log(date3); // 2021-12-10T05:49:10.123Z\n\n// 如果不带后缀 默认为本地时间 所以被转换为了标准时间\nlet date4 = new Date(\'2021-12-10 13:49:10\')\nconsole.log(date4); // 2021-12-10T05:49:10.000Z\n\n// 后缀是 +08:00 表示传的是东八区的时间 准换为UTC标准时间\nlet date5 = new Date(\'2021-12-10 13:49:10+08:00\')\nconsole.log(date5); // 2021-12-10T05:49:10.000Z\n\n// 后缀是 +00:00 表示传的本身就是UTC标准时间\nlet date6 = new Date(\'2021-12-10 13:49:10+00:00\')\nconsole.log(date6); // 2021-12-10T13:49:10.000Z\n</code></pre>\n</li>\n<li>\n<p>分别提供日期与时间的每一个成员</p>\n<p><code>new Date(year, month, date, hours, minutes, seconds, ms)</code></p>\n<p>使用当前时区中的给定组件创建日期。只有前两个参数是必须的。</p>\n<pre><code class=\"language-js\">/*\n- `year` 必须是四位数：`2013` 是合法的，`98` 是不合法的。\n- `month` 计数从 `0`（一月）开始，到 `11`（十二月）结束。\n- `date` 是当月的具体某一天，如果缺失，则为默认值 `1`。\n- 如果 `hours/minutes/seconds/ms` 缺失，则均为默认值 `0`。\n*/\n\n// 2021-12-10 14:08:00\nlet date = new Date(2021, 11, 10, 14, 08)\nconsole.log(date); // 2021-12-10T06:08:00.000Z\n</code></pre>\n</li>\n</ol>\n<h3>构造方法小结</h3>\n<ul>\n<li>如果没有输入任何参数，则Date的构造器会依据系统设置的当前时间来创建一个Date对象。</li>\n<li>如果提供了至少两个参数，其余的参数均会默认设置为 1（如果没有指定 day 参数）或者 0（如果没有指定 day 以外的参数）。</li>\n<li>JavaScript的时间由世界标准时间（UTC）1970年1月1日开始，用毫秒计时，一天由 86,400,000 毫秒组成。<code>Date</code> 对象的范围是 -100,000,000 天至 100,000,000 天（等效的毫秒值）。</li>\n<li><code>Date</code> 对象为跨平台提供了统一的行为。时间属性可以在不同的系统中表示相同的时刻，而如果使用了本地时间对象，则反映当地的时间。</li>\n<li><code>Date</code> 对象支持多个处理 UTC 时间的方法，也相应地提供了应对当地时间的方法。UTC，也就是我们所说的格林威治时间，指的是time中的世界时间标准。而当地时间则是指执行JavaScript的客户端电脑所设置的时间。</li>\n<li>以一个函数的形式来调用 <code>Date</code> 对象（即不使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new\"><code>new</code></a> 操作符）会返回一个代表当前日期和时间的字符串。</li>\n</ul>\n<h2>静态方法</h2>\n<h3>Date.now()</h3>\n<p>返回自 1970 年 1 月 1 日 00:00:00 (UTC) 到当前时间的毫秒数。</p>\n<pre><code class=\"language-js\">console.log(Date.now()) // 1639116960077\n</code></pre>\n<h3>Date.parse()</h3>\n<p>接收一个表示时间的字符串，返回对应的时间戳，如果不能解析就返回<code>NaN</code></p>\n<blockquote>\n<p>最好不要用这个方法，不同宿主环境又有可能不同。想把字符串转成时间，自己可以写一套规范代码，然后跨平台的时候使用也会很方便。</p>\n</blockquote>\n<blockquote>\n<p>注意：输出的总是<code>UTC</code>标准时间距离<code>1970-01-01</code>的时间戳。</p>\n<ol>\n<li>如果只传入年月日，比如<code>1970-01-01</code>、<code>Thu, 01 Jan 1970</code>，那么可以看成传入的就是标准时间（虽然没有带时区标志，比如<code>GMT + 0800</code>，或者<code>+0800，或者</code>z`）</li>\n<li>如果传入了时分秒，不带时区标志，默认就是本地时间</li>\n<li>只要带时区标志，全部先转换为UTC标准时间，然后再计算时间戳</li>\n</ol>\n</blockquote>\n<pre><code class=\"language-js\">// 只传年月日，不带时区标志，默认为UTC标准时区\nlet timestamp1 = Date.parse(\'1970-01-01\')\nconsole.log(timestamp1); // 0\nconsole.log(Date.parse(\'1970-01-01Z\')); // 0\n\n// 传了时分秒，不带时区标志，默认为本地时间\nlet timestamp1_1 = Date.parse(\'1970-01-01 00:00:00\')\nconsole.log(timestamp1_1, \'timestamp1_1\'); // -28800000 timestamp1_1\n\nlet timestamp1_2 = Date.parse(\'1970-01-01 00:00:00+08:00\')\nconsole.log(timestamp1_2, \'timestamp1_2\'); // -28800000 timestamp1_2\n\n// 带了UTC标准时区\nlet timestamp2 = Date.parse(\'1970-01-01T00:00:00.000Z\')\nconsole.log(timestamp2); // 0\n\n// 如果是东八区的时间，会先转换为标准时间，输出的总是标准时间距1970-01-01的时间戳\nlet timestamp2_1 = Date.parse(\'1970-01-01T00:00:00.000+08:00\')\nconsole.log(timestamp2_1); // -28800000\n\n// 标准时区1970-01-01 过了1s\nlet timestamp3 = Date.parse(\'1970-01-01T00:00:01.000Z\')\nconsole.log(timestamp3); // 1000\n\n// 不加时区标志，传了时分秒，默认为本地时间 1970-01-01 过了1s\nlet timestamp3_1 = Date.parse(\'1970-01-01T00:00:01\')\nconsole.log(timestamp3_1, \'timestamp3_1\'); // -28799000 timestamp3_1\nlet timestamp3_2 = Date.parse(\'1970-01-01T00:00:01+08:00\')\nconsole.log(timestamp3_2, \'timestamp3_2\'); // -28799000 timestamp3_2\n\n// 传了GMT表示为标准时间\nlet timestamp4 = Date.parse(\'Thu, 01 Jan 1970 00:00:00 GMT\')\nconsole.log(timestamp4); // 0\n\n// 传了时分秒，东八区的时间会先转换位标准时间，然后输出标准时间距1970-01-01的时间戳\nlet timestamp4_1 = Date.parse(\'Thu, 01 Jan 1970 00:00:00 GMT+0800\')\nconsole.log(timestamp4_1, \'timestamp4_1\'); // -28800000 timestamp4_1\n// 传了时分秒，不带时区标志，默认为本地时区\nlet timestamp4_2 = Date.parse(\'Thu, 01 Jan 1970 00:00:00\')\nconsole.log(timestamp4_2, \'timestamp4_2\'); // -28800000 timestamp4_2\n</code></pre>\n<h3>Date.UTC()</h3>\n<p>接收年月日时分秒，返回从1970-1-1 00:00:00 UTC到指定日期的的毫秒数。</p>\n<pre><code class=\"language-js\">// new Date() 是基于本地时间创建的时间对象，\n// 因为北京是东八区时间，所以创建的1970-01-01 00:00\n// 其实是标准时间的1969-12-31 16:00\nlet date1 = new Date(1970, 00, 01)\nconsole.log(date1); // 1969-12-31T16:00:00.000Z\nconsole.log(date1.getTime()); // -28800000\n\n// Date.UTC() 是基于UTC标准时间创建的时间戳\nlet timestamp2 = Date.UTC(1970, 00, 01)\nconsole.log(timestamp2); // 0\nconsole.log(new Date(timestamp2)); // 1970-07-01T00:00:00.000Z\n</code></pre>\n<h2>原型上的方法</h2>\n<h3>获取本地时间和UTC标准时间的年、月、日、时、分、秒、毫秒、星期几</h3>\n<pre><code class=\"language-js\">// 现在是 星期五 2021年12月10日 下午15点58分10秒259毫秒\nlet date = new Date(\'2021-12-10 15:58:10.259\') // 不带时区标志的字符串，按照本地时间初始化\n\n// 打印输出的UTC标准时间，因为北京属于东八区，比标准时间快了八小时，所以标准时间现在是 15-8=7 上午的07:58:10.259\nconsole.log(date); // 2021-12-10T07:58:10.259Z \n\n// 获取年\nconsole.log(date.getFullYear()); // 2021\nconsole.log(date.getUTCFullYear()); // 2021\n\n// 获取月\nconsole.log(date.getMonth()); // 11 范围是0-11 11代表十二月\nconsole.log(date.getUTCMonth()); // 11\n\n// 获取日\nconsole.log(date.getDate()); // 10 范围是1-31，10日\nconsole.log(date.getUTCDate()); // 10\n\n// 获取时\nconsole.log(date.getHours()); // 15 北京时间下午三点\nconsole.log(date.getUTCHours()); // 7 UTC标准时间 上午7点 15-8=7\n\n// 获取分\nconsole.log(date.getMinutes()); // 58 58分，范围是 0-59\nconsole.log(date.getUTCMinutes()); // 58\n\n// 获取秒\nconsole.log(date.getSeconds()); // 10 10秒，范围是 0-59\nconsole.log(date.getUTCSeconds()); // 10\n\n// 获取毫秒\nconsole.log(date.getMilliseconds()); // 259 259毫秒，范围是 0-999\nconsole.log(date.getUTCMilliseconds()); // 259\n\n// 获取星期几\nconsole.log(date.getDay()); // 5 今天是星期5，范围是0-6\nconsole.log(date.getUTCDay()); // 5\n</code></pre>\n<h4>年：getFullYear/getUTCFullYear</h4>\n<p>获取年份（4位数）</p>\n<h4>月：getMonth/getUTCMonth</h4>\n<p>获取月份，从0到11，0表示一月</p>\n<h4>日：getDate/getUTCDate</h4>\n<p>获取日，一个月的第几天，从1到31</p>\n<h4>时：getHours/getUTCHours</h4>\n<p>获取时，一天的第几小时，从0到23</p>\n<h4>分：getMinutes/getUTCMinutes</h4>\n<p>获取分，第多少分钟，从0到59</p>\n<h4>秒：getSeconds/getUTCSeconds</h4>\n<p>获取秒，从0到59</p>\n<h4>毫秒：getMilliseconds/getUTCMilliseconds</h4>\n<p>获取毫秒数，从0到999</p>\n<h4>星期几：getDay/getUCTDay</h4>\n<p>获取星期几，从0到6，0表示星期日</p>\n<h3>设置本地时间和UTC标准时间的年、月、日、时、分、秒、毫秒</h3>\n<h4>年：setFullYear/setUTCFullYear</h4>\n<p><code>dateObj.setFullYear(yearValue[, monthValue[, dayValue]])</code></p>\n<ol>\n<li>yearValue：四位数</li>\n<li>monthValue：0-11的整数</li>\n<li>dayValue：1-31的整数</li>\n</ol>\n<p>如果没有指定 <code>monthValue</code> 和<code>dayValue</code> 参数，将会使用 <code>getMonth</code> 和<code>getDate</code> 方法的返回值。</p>\n<p>如果有一个参数超出了合理的范围，<code>setFullYear</code> 方法会更新其他参数值，日期对象的日期值也会被相应更新。 例如，为 <code>monthValue </code>指定 15， 则年份会加1，月份值会为3。</p>\n<pre><code class=\"language-js\">let date = new Date(\'2021-12-10 16:18:10.235\')\nconsole.log(date); // 2021-12-10T08:18:10.235Z\n\ndate.setFullYear(2020)\nconsole.log(date); // 2020-12-10T08:18:10.235Z\n\n// 设置的月份 正常为0-11，设置12 超过了一个月，年份就自动+1，月份变为了1月\ndate.setFullYear(2020, 12)\nconsole.log(date); // 2021-01-10T08:18:10.235Z\n\n// 月份设置了-1，所以就变为了2020年1月的上一月，就是 2019年12月\ndate.setFullYear(2020, -1)\nconsole.log(date); // 2019-12-10T08:18:10.235Z\n</code></pre>\n<h4>月：setMonth/setUTCMonth</h4>\n<p><code>dateObj.setMonth(monthValue[, dayValue])</code></p>\n<ol>\n<li>monthValue：0-11的整数</li>\n<li>dayValue：1-31的整数</li>\n</ol>\n<p>如果不指定 <code>dayValue</code> 参数，就会使用 <code>getDate</code>方法的返回值。</p>\n<p>如果有一个指定的参数超出了合理范围，<code>setMonth</code> 会相应地更新日期对象中的日期信息。例如，为 <code>monthValue</code> 指定 15，则年份会加 1，月份将会使用 3。</p>\n<h4>日：setDate/setUTCDate</h4>\n<p><code>dateObj.setDate(dayValue)</code></p>\n<ol>\n<li>dayValue：1-31的整数</li>\n</ol>\n<p>如果 <code>dayValue</code> 超出了月份的合理范围，<code>setDate</code> 将会相应地更新 <code>Date</code> 对象。</p>\n<p>例如，如果为 <code>dayValue</code> 指定0，那么日期就会被设置为上个月的最后一天。</p>\n<p>如果dayValue被设置为负数，日期会设置为上个月最后一天往前数这个负数绝对值天数后的日期。-1会设置为上月最后一天的前一天（译者注：例如当前为4月，如果setDate(-2),则为3月29日）</p>\n<h4>时：setHours/setUTCHours</h4>\n<p><code>dateObj.setHours(hoursValue[, minutesValue[, secondsValue[, msValue]]])</code></p>\n<ol>\n<li>hoursValue：一个 0 到 23 的整数，表示小时。</li>\n<li>minutesValue：一个 0 到 59 的整数，表示分钟。</li>\n<li>secondsValue：一个 0 到 59 的整数，表示秒数。如果指定了 <code>secondsValue</code> 参数，则必须同时指定 <code>minutesValue </code>参数。</li>\n<li>msValue：一个 0 到 999 的数字，表示微秒数，如果指定了 <code>msValue</code> 参数，则必须同时指定 <code>minutesValue</code> 和 <code>secondsValue</code> 参数。</li>\n</ol>\n<p>如果不指定 <code>minutesValue</code>，<code>secondsValue</code> 和 <code>msValue</code> 参数，则会使用<code>getMinutes()</code>、<code>getSeconds()</code>、<code>getMilliseconds()</code>方法的返回值。</p>\n<p>如果有一个参数超出了合理范围，<code>setHours</code> 会相应地更新日期对象中的日期信息。例如，如果为 <code>secondsValue</code> 指定了 100，则分钟会加 1，然后秒数使用 40。</p>\n<h4>分：setMinutes/setUTCMinutes</h4>\n<p><code>dateObj.setMinutes(minutesValue[, secondsValue[, msValue]])</code></p>\n<ol>\n<li>minutesValue：一个 0 到 59 的整数，表示分钟。</li>\n<li>secondsValue：一个 0 到 59 的整数，表示秒数。如果指定了 <code>secondsValue</code> 参数，则必须同时指定 <code>minutesValue </code>参数。</li>\n<li>msValue：一个 0 到 999 的数字，表示微秒数，如果指定了 <code>msValue</code> 参数，则必须同时指定 <code>minutesValue</code> 和 <code>secondsValue</code> 参数。</li>\n</ol>\n<p>如果没有指定 <code>secondsValue</code> 和 <code>msValue</code> 参数，就会使用 <code>getSeconds()</code>和 <code>getmilliseconds()</code> 方法的返回值。</p>\n<p>如果有一个指定的参数超出了合理范围，<code>setMinutes</code> 会相应地更新日期对象中的时间信息。例如，为 <code>secondsValue</code> 指定 100，分钟数将会加 1，而秒数会为 40。</p>\n<h4>秒：setSeconds/setUTCSeconds</h4>\n<p><code>dateObj.setSeconds(secondsValue[, msValue])</code></p>\n<ol>\n<li>secondsValue：一个 0 到 59 的整数，表示秒数。</li>\n<li>msValue：一个 0 到 999 的数字，表示微秒数。</li>\n</ol>\n<p>如果没有指定 <code>msValue</code> 参数，就会使用 <code>getMilliseconds()</code>方法的返回值。</p>\n<p>如果一个参数超出了合理范围， <code>setSeconds</code> 方法会相应地更新日期对象的时间信息。例如，为 <code>secondsValue</code> 指定 100，则日期对象的分钟数会相应地加 1，秒数将会使用 40。</p>\n<h4>毫秒：setMilliseconds/setUTCMilliseconds</h4>\n<p><code>dateObj.setMilliseconds(millisecondsValue)</code></p>\n<p>millisecondsValue：一个 0 到 999 的数字，表示豪秒数。</p>\n<p>如果指定的数字超出了合理范围，则日期对象的时间信息会被相应地更新。例如，如果指定了 1005，则秒数加 1，豪秒数为 5。</p>\n<h3>getTime 获取时间戳</h3>\n<p><code>getTime</code> 方法的返回值一个数值，表示从1970年1月1日0时0分0秒（UTC，即协调世界时）距离该日期对象所代表时间的毫秒数。</p>\n<pre><code class=\"language-js\">// 传了时分秒 不带时区的话 默认会以本地时间创建日期对象\n// 北京在东八区，比UTC标准时间快了八小时\n// 所以北京时间的 1970-01-01 00:00:00+08:00\n// 实际是UTC标准时间 1969-12-31T16:00:00.000Z\n// 所以这里打印的毫秒数是负值\nlet date = new Date(\'1970-01-01 00:00:00\')\nconsole.log(date); // 1969-12-31T16:00:00.000Z\nconsole.log(date.getTime()); // -28800000\n\n// 标准的传参，带了时区，说明这是UTC标准时区的时间\nlet date2 = new Date(\'1970-01-01T00:00:00.000Z\')\nconsole.log(date2); // 1970-01-01T00:00:00.000Z\nconsole.log(date2.getTime()); // 0\n</code></pre>\n<h3>setTime 根据时间戳设置时间</h3>\n<p><code>dateObj.setTime(timeValue)</code></p>\n<p>timeValue：一个整数，表示从1970-1-1 00:00:00 UTC开始计时的毫秒数。</p>\n<pre><code class=\"language-js\">let date = new Date(\'1970-01-01 00:00:00z\')\nconsole.log(date); // 1970-01-01T00:00:00.000Z\n\n// 可以使用setTime复制一个日期对象\nlet date2 = new Date(date.getTime())\nconsole.log(date2); // 1970-01-01T00:00:00.000Z\n</code></pre>\n<h3>toString、toLocaleString、toISOString、toUTCString</h3>\n<ol>\n<li>\n<p>toString：<code>Fri Dec 10 2021 17:20:41 GMT+0800 (中国标准时间)</code></p>\n</li>\n<li>\n<p>toLocaleString：<code>2021/12/10 下午5:20:41</code></p>\n<p>方法返回该日期对象的字符串，该字符串格式因不同语言而不同。新增的参数 <code>locales</code> 和 <code>options</code> 使程序能够指定使用哪种语言格式化规则，允许定制该方法的表现（behavior）。</p>\n<p><code>dateObj.toLocaleString([locales [, options]])</code></p>\n<pre><code class=\"language-js\">let date = new Date(\'2021-12-10 19:34+0800\')\nconsole.log(date.toISOString()); // 2021-12-10T11:34:00.000Z\nconsole.log(date.toString()); // Fri Dec 10 2021 19:34:00 GMT+0800 (中国标准时间)\n\n// 没有指定语言环境（locale）时，返回一个使用默认语言环境和格式设置（options）的格式化字符串。\nconsole.log(date.toLocaleString()); // 2021/12/10 下午7:34:00\n// 中国\nconsole.log(date.toLocaleString(\'zh\')); // 2021/12/10 下午7:34:00\nconsole.log(date.toLocaleString(\'zh\', { hour12: true })) // 2021/12/10 下午7:34:00\nconsole.log(date.toLocaleString(\'zh\', { hour12: false })) // 2021/12/10 19:34:00\n// en-GB(不列颠英语)\nconsole.log(date.toLocaleString(\'en-GB\')); // 10/12/2021, 11:34:00\n// 韩国\nconsole.log(date.toLocaleString(\'ko-KR\')); // 2021. 12. 10. 오전 11:34:00\n</code></pre>\n</li>\n<li>\n<p>toISOString：<code>2021-12-10T09:20:41.081Z</code></p>\n</li>\n<li>\n<p>toUTCString：<code>Fri, 10 Dec 2021 09:20:41 GMT</code></p>\n</li>\n</ol>\n<h3>toDateString、toLocaleDateString</h3>\n<ol>\n<li>toDateString：<code>Fri Dec 10 2021</code></li>\n<li>toLocalDateString：<code>2021/12/10</code></li>\n</ol>\n<h3>toTimeString、toLocaleTimeString</h3>\n<ol>\n<li>toTimeString：<code>17:20:41 GMT+0800 (中国标准时间)</code></li>\n<li>toLocalTimeString：<code>下午5:20:41</code></li>\n</ol>\n<h3>valueOf</h3>\n<p>功能和<code>getTime</code>一样，返回从1970年1月1日0时0分0秒（UTC，即协调世界时）到该日期的毫秒数。</p>\n<pre><code class=\"language-js\">let date = new Date()\n\nconsole.log(date.toString()); // Fri Dec 10 2021 17:20:41 GMT+0800 (中国标准时间)\nconsole.log(date.toLocaleString()); // 2021/12/10 下午5:20:41\n\nconsole.log(date.toDateString()); // Fri Dec 10 2021\nconsole.log(date.toLocaleDateString()); // 2021/12/10\n\nconsole.log(date.toTimeString()); // 17:20:41 GMT+0800 (中国标准时间)\nconsole.log(date.toLocaleTimeString()); // 下午5:20:41\n\nconsole.log(date.toISOString()); // 2021-12-10T09:20:41.081Z\nconsole.log(date); // 2021-12-10T09:20:41.081Z\n\nconsole.log(date.toUTCString()); // Fri, 10 Dec 2021 09:20:41 GMT\n\nconsole.log(date.valueOf()); // 1639128041081\nconsole.log(date.getTime()); // 1639128041081\n</code></pre>\n<h3>toJSON</h3>\n<p>返回日期的字符串形式，用来序列化的时候使用，默认使用<code>toISOString()</code>输出结果。</p>\n<pre><code class=\"language-js\">let date = new Date()\nconsole.log(date.toJSON()) // 2021-12-10T11:10:25.832Z\n</code></pre>\n<h3>getTimezoneOffset</h3>\n<p>返回协调世界时（UTC）相对于当前时区的时间差值，单位为分钟。</p>\n<pre><code class=\"language-js\">// 北京在东八区，与UTC标准时间正好差了八小时\nconsole.log(new Date().getTimezoneOffset()) // -480\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>\n<p>Date构造方法的参数可以有四种形式</p>\n<ol>\n<li>\n<p><code>new Date()</code>：啥也不填，会返回一个本地的时间对象</p>\n</li>\n<li>\n<p><code>new Date(0)</code>：填一个时间戳，从<code>1970-01-01 00:00:00</code>UTC标准的时间开始的时间戳，如果填负数，就是之前的时间</p>\n</li>\n<li>\n<p><code>new Date(\'dateString\')</code>：填一个日期格式的字符串，会被解析成一个时间对象，如果不填写时区后缀时，会默认以本地时间解析。</p>\n<pre><code class=\"language-js\">let date = new Date(\'2021-12-10 18:19\') // 没有带时间后缀，默认以本地时间创建\n// UTC标准时间就是上午10点\nconsole.log(date.toUTCString()); // Fri, 10 Dec 2021 10:19:00 GMT\nconsole.log(date.toISOString()); // 2021-12-10T10:19:00.000Z\n</code></pre>\n<blockquote>\n<p>UTC时间、GMT时间、和北京时间，这三者的区别参考另一篇文章：<a href=\"http://www.bnbiye.cn/#/articleDetail/a8f45760-58f5-11ec-96d5-7933aca11ca0\">GMT、UTC和北京时间的关系</a></p>\n<p>这里简单的总结一下，</p>\n<p>UTC时间和GMT都可以视为标准时间。在早期是以GMT时间为标准时间。根据经度的不同，将地球划分为24个时区，本初子午线（0°经线）所在的区是中时区，本初子午线向东位东时区，向西为西时区，北京正好位于东八区，比标准时间快了八小时。</p>\n<p>所以在传字符串的时候，如果想传的更标准，可以这么传</p>\n<pre><code class=\"language-js\">/*\nIS0的形式（UTC标准时区、中时区、伦敦在这个时区）：\n	2021-12-10T10:19:00.000Z\n如果是北京的东八区，可以这么传\n	2021-12-10T18:19:00.000+0800\n如果是华盛顿的西五区，可以这么传\n	2021-12-10T18:05:00.000-0500\n*/\n/*\nGMT的格式（GMT标准时区、中时区、伦敦在这个时区）\n	Fri, 10 Dec 2021 10:19:00 GMT\n如果是北京的东八区，可以这么传\n	Fri, 10 Dec 2021 18:19:00 GMT+0800\n如果是华盛顿的西五区，可以这么传\n	Fri, 10 Dec 2021 05:19:00 GMT-0500\n*/\n</code></pre>\n<p>上面的例子描述一下就是：</p>\n<p>当伦敦（中时区）上午10的时候，北京（东八区）是下午6点，比伦敦时间快了八小时。而美国的华盛顿（西五区）刚刚早上5点。看一个手机的截图：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112101841113.png\" alt=\"image-20211210184104061\" /></p>\n</blockquote>\n</li>\n<li>\n<p><code>new Date(年、月、日、时、分、秒、毫秒)</code>：在对应位置处填写对应的数值，根据本地时间创建的日期对象</p>\n</li>\n</ol>\n</li>\n<li>\n<p>静态方法</p>\n<ol>\n<li>\n<p><code>Date.now()</code>：获取当前时间的时间戳，相当于<code>new Date().getTime()</code></p>\n</li>\n<li>\n<p><code>Date.parse()</code>：可以将一个字符串格式的时间转换为一个解析为一个时间戳，如果解析不成功，返回<code>NaN</code></p>\n<ol>\n<li>字符串的格式跟<code>new Date()</code>时传入的字符串格式一样。</li>\n</ol>\n</li>\n<li>\n<p><code>Date.UTC()</code>：在使用<code>new Date(年、月、日...)</code>创建日期对象时，默认是以本地时间创建，如果想创建一个UTC标准时间，就可以使用这个静态方法，会返回一个标准时间的时间戳。</p>\n<pre><code class=\"language-js\">let localTime = new Date(年，月，日，时，分，秒，毫秒) // 默认以本地时间创建\nlet utcTime = new Date(Date.UTC(年，月，日，时，分，秒，毫秒)) // Date.UTC() 会返回一个标准时间的时间戳\n</code></pre>\n</li>\n</ol>\n</li>\n<li>\n<p>get：一些获取年、月、日、时、分、秒、毫秒、星期、的get方法（对应的增加UTC就是获取到UTC的时间）</p>\n<ol>\n<li>年 getFullYear/getUTCFulllYear：返回一个四位数，比如<code>2021</code></li>\n<li>月 getMonth/getUTCMonth：返回一个 <code>0-11</code>的数，<code>0</code>表示一月，<code>11</code>表示十二月</li>\n<li>日 getDate/getUTCDate：返回一个<code>1-31</code>的数，<code>1</code>表示<code>1</code>号，<code>31</code>表示<code>31</code>号</li>\n<li>时 getHours/getUTCHours：返回一个<code>0-23</code>的数，<code>0</code>表示整点（<code>0</code>点），<code>23</code>表示<code>23</code>点</li>\n<li>分 getMinutes/getUTCMinutes：返回一个0-59的数，<code>0</code>表示整分（<code>0</code>分），<code>59</code>表示<code>59</code>分</li>\n<li>秒 getSeconds/getUTCSeconds：返回一个<code>0-59</code>的数，<code>0</code>表示整秒，<code>59</code>表示<code>59</code>秒</li>\n<li>毫秒 getMilliseconds/getUTCMilliseconds：返回一个<code>0-999</code>的数，<code>1</code>秒等于<code>1000</code>毫秒</li>\n<li>星期 getDay/getUTCDay：返回一个<code>0-6</code>的数，<code>0</code>表示星期日，<code>6</code>表示星期六</li>\n</ol>\n</li>\n<li>\n<p>set：一些设置年、月、日、时、分、秒、毫秒的set方法</p>\n<ol>\n<li>\n<p>年 setFullYear/setUTCFulllYear：</p>\n<p>同时还可以设置月、日，如果设置超了，会自动往前面进1，如果设置少了，就会向前面借位，方法内部实现好了日期的加减法。</p>\n</li>\n<li>\n<p>月 setMonth/setUTCMonth：</p>\n<p>同时还可以设置日。</p>\n</li>\n<li>\n<p>日 setDate/setUTCDate：</p>\n<p>设置日。</p>\n</li>\n<li>\n<p>时 setHours/setUTCHours：</p>\n<p>同时还可以设置分、秒、毫秒，如果设置超了，会自动往前面进1，如果设置少了，就会向前面借位，方法内部实现好了日期的加减法。</p>\n</li>\n<li>\n<p>分 setMinutes/setUTCMinutes：</p>\n<p>同时还可以设置 秒、毫秒</p>\n</li>\n<li>\n<p>秒 setSeconds/setUTCSeconds：</p>\n<p>同时还可以设置 毫秒</p>\n</li>\n<li>\n<p>毫秒 setMilliseconds/setUTCMilliseconds：</p>\n<p>设置毫秒。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>把日期转为可读的字符串1----字符串包括日期和时间（全量）：</p>\n<ol>\n<li>\n<p>toString：返回一个美式英语日期格式的字符串。</p>\n<pre><code class=\"language-js\">// Fri Dec 10 2021 17:20:41 GMT+0800 (中国标准时间)\n</code></pre>\n</li>\n<li>\n<p>toLocaleString：返回该日期对象的字符串，可以配置不同地区，或者输出的样式。</p>\n<pre><code class=\"language-js\">let date = new Date(\'2021-12-10 19:34+0800\')\n// 没有指定语言环境（locale）时，返回一个使用默认语言环境和格式设置（options）的格式化字符串。\nconsole.log(date.toLocaleString()); // 2021/12/10 下午7:34:00\n// 中国\nconsole.log(date.toLocaleString(\'zh\')); // 2021/12/10 下午7:34:00\nconsole.log(date.toLocaleString(\'zh\', { hour12: true })) // 2021/12/10 下午7:34:00\nconsole.log(date.toLocaleString(\'zh\', { hour12: false })) // 2021/12/10 19:34:00\n</code></pre>\n</li>\n<li>\n<p>toISOString：返回一个ISO格式的字符串</p>\n<pre><code class=\"language-js\">// 2021-12-10T09:20:41.081Z\n</code></pre>\n</li>\n<li>\n<p>toUTCString：使用UTC时区的字符串</p>\n<pre><code class=\"language-js\">// Fri, 10 Dec 2021 09:20:41 GMT\n</code></pre>\n</li>\n<li>\n<p>toJSON：序列化的时候会调用，默认返回<code>ISO</code>格式的字符串。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>把日期转为可读的字符串2----字符串包括日期或者时间（部分）：</p>\n<ol>\n<li>toDateString：返回日期这部分的字符串</li>\n<li>toLocaleDateString：类似于toLocaleString，可以传参数，返回相应的日期格式的字符串</li>\n<li>toTimeString：返回时间这部分的字符串</li>\n<li>toLocaleTimeString：类似于toLocaleString，可以传参数，返回相应的时间这部分的字符串</li>\n</ol>\n</li>\n<li>\n<p>getTime：获取时间戳</p>\n<pre><code class=\"language-js\">// 传了时分秒 不带时区的话 默认会以本地时间创建日期对象\n// 北京在东八区，比UTC标准时间快了八小时\n// 所以北京时间的 1970-01-01 00:00:00+08:00\n// 实际是UTC标准时间 1969-12-31T16:00:00.000Z\n// 所以这里打印的毫秒数是负值\nlet date = new Date(\'1970-01-01 00:00:00\')\nconsole.log(date); // 1969-12-31T16:00:00.000Z\nconsole.log(date.getTime()); // -28800000\n\n// 标准的传参，带了时区，说明这是UTC标准时区的时间\nlet date2 = new Date(\'1970-01-01T00:00:00.000Z\')\nconsole.log(date2); // 1970-01-01T00:00:00.000Z\nconsole.log(date2.getTime()); // 0\n</code></pre>\n</li>\n<li>\n<p>setTime：根据时间戳设置时间，可以用来拷贝日期</p>\n<pre><code class=\"language-js\">let date = new Date(\'1970-01-01 00:00:00z\')\nconsole.log(date); // 1970-01-01T00:00:00.000Z\n\n// 可以使用setTime复制一个日期对象\nlet date2 = new Date(date.getTime())\nconsole.log(date2); // 1970-01-01T00:00:00.000Z\n</code></pre>\n</li>\n<li>\n<p>valueOf：功能和<code>getTime</code>一样，返回从1970年1月1日0时0分0秒（UTC，即协调世界时）到该日期的毫秒数。</p>\n<pre><code class=\"language-js\">let date = new Date(\'1970-01-01 00:00:00z\')\nconsole.log(date.getTime()); // 0\nconsole.log(date.valueOf()); // 0\n</code></pre>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Date</a></p>\n<p><a href=\"https://zh.javascript.info/date\">https://zh.javascript.info/date</a></p>\n', '2021-12-10 20:26:08', '2021-12-10 20:26:08');
INSERT INTO `t_blog` VALUES ('5cb12ae0-397e-11ec-8015-f554da021b2a', 'pupublog介绍', '一直想拥有一个属于自己的博客网站，用来总结自己的学习心得，因为发现自己记性不好，知识学完就忘，并且学到的知识不成体系，东一块西一块，这样就导致了，当每次间隔一段时间不用某个技术时，都需要重学一遍（其实学习就是个重复的过程，这种现象也很正常）...', '-1', 1, '', '25d5ff80-2cbf-11ec-86ae-0da8227970f6', 2, 46, 1, 1, 2, 1, 'http://api.bnbiye.cn/upload/png/2021-10-30/03424520-397e-11ec-8015-f554da021b2a.png', '<h2>前言</h2>\n<p>一直想拥有一个属于自己的博客网站，用来总结自己的学习心得，因为发现自己记性不好，知识学完就忘，并且学到的知识不成体系，东一块西一块，这样就导致了，当每次间隔一段时间不用某个技术时，都需要重学一遍（其实学习就是个重复的过程，这种现象也很正常）。</p>\n<p>但是肯定会有很多人有疑问了，为什么要自己去搭博客网站，直接用现成网站记笔记（比如，<a href=\"https://juejin.cn/\">掘金</a>、<a href=\"https://www.zhihu.com/\">知乎</a>、<a href=\"https://segmentfault.com/\">思否</a>、<a href=\"https://www.jianshu.com/\">简书</a>、<a href=\"https://www.csdn.net/\">CSDN</a>、<a href=\"https://www.cnblogs.com/\">博客园</a> 等等），再不然直接用一些现成的技术搭网站（比如，<a href=\"https://docsify.js.org/#/\">docsify</a>、<a href=\"https://vuepress.vuejs.org/zh/\">vuepress</a>、<a href=\"https://cn.wordpress.org/\">WordPress</a> 等等），它不香吗？</p>\n<p>怎么说呢，很香，确实香，但是当了解过这些方式，并尝试过其中的一些后，最终决定还是自己开发一个，究其原因，是出于下面几点考虑的（存是个人想法）</p>\n<ol>\n<li>\n<p>直接在现成的网站上记笔记，是有必要的，并且是需要长期坚持的，但是总感觉写完的笔记知识点太散，没有成系统，虽然可以加标签，加专题，进行一个归类，但是我个人感觉操作起来还是不方便，差点意思，我想要归的更细（比较喜欢这个网站的风格，主要喜欢这种归类，<a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a>）</p>\n</li>\n<li>\n<p>如果直接用现成的技术搭博客，总觉得没有灵魂。既然是自己的网站了，写代码还得遵循别人的风格，就很别扭。所以我更建议用上面提到的技术（<a href=\"https://docsify.js.org/#/\">docsify</a>、<a href=\"https://vuepress.vuejs.org/zh/\">vuepress</a>等）去写一些手册、说明书之类的。并且，既然搭博客网站的初衷是为了学习，而学习的方法是一个技术一个技术去尝试、去复现、去思考。如果直接用现成的技术很快的搭建起了自己的网站，虽然节省了很多时间，但是这其中少了很多学习技术的机会。比如，网页怎么布局的，前后端怎么交互的，浏览器怎么加载的，代码怎么打包的，网站怎么部署的，等等等等。</p>\n<blockquote>\n<p>tip：其实选择怎样的学习方式，全都取决于自己。只要坚持下来就一定会有收获。经验都是在不断的尝试之后总结出来的，最重要的就是行动起来。</p>\n</blockquote>\n</li>\n</ol>\n<p>所以，结合上面的几点考虑，确定了下面几个大目标</p>\n<ol>\n<li>自己从零开发一个博客网站，用来记录日后的学习笔记，不管开发需要花费多少时间，坚持下来。</li>\n<li>功能设计方面，遵循自己的想法来，除了博客应有的功能外，需要有一个专题功能，可以将日后学习到的知识详细归类，形成体系。</li>\n<li>别人看网站的时候可以和我有交互，有反馈。</li>\n<li>把项目开源出来。</li>\n</ol>\n<p>于是针对于上面的几点大目标，我开始在<code>github</code>和<code>gitee</code>里搜索相关的项目，当我看到 <a href=\"http://www.moguit.cn/#/\">蘑菇博客</a> 的时候，顿时眼前一亮，发现所有的想法，都在这个项目上不谋而合了。不过项目的后台陌溪大佬（蘑菇博客的作者）是用java写的，这对于我一个小前端来说学习成本太大，所以就想着能不能把后台改成<code>node</code>版本的。心动不如行动，于是就开始了我的重写之路，最终历经小半年，终于把大概功能重写完成，还有很多功能日后有时间慢慢完善。</p>\n<p>在这期间我一共做了下面几件事</p>\n<ol>\n<li>重写蘑菇博客的前台和后台静态页面</li>\n<li>重写留言和评论组件（<a href=\"https://gitee.com/hrbust_cheny/pupu_blog\">仿Gitee</a>）</li>\n<li>重写专题组件（专题列表仿照 <a href=\"https://www.kuangstudy.com/course\">KuangStudy</a>，专题详情仿照  <a href=\"https://zh.javascript.info/\">现代JavaScript 教程</a> ）</li>\n<li>重写文章目录组件 （仿<a href=\"https://gitee.com/hrbust_cheny/pupu_blog\">Gitee的Readme目录</a>）</li>\n<li>重写登录组件 （仿 <a href=\"https://juejin.cn/\">掘金登录</a> ）</li>\n<li>重写个人中心 （仿 <a href=\"https://juejin.cn/\">掘金个人中心</a>）</li>\n<li>重写后台服务 （结合自己业务模块，自己搭了一套koa2后台架子）</li>\n<li>为了提高接口和后台页面开发效率，自定义代码生成器 （基于导出的<code>sql</code>文件，根据对应字段和字段注释，一键生成接口和后台代码）</li>\n</ol>\n<h2>我是如何仿写的</h2>\n<p>可能会有很多人（也包括之前的我┑(￣Д ￣)┍），总是会将想法只停留在想法上，一直拖着，不付诸于行动。就拿开发博客来说，早在上大学的时候就有这种想法，但是一直拖着就是不做，这都工作一年了才刚刚开始，想想自己虚度的那些光阴，真是太可惜了，不过学习什么时候都不算晚，坚持下来就会有收获。种一棵树最好的时间是十年前，其次就是现在嘛😄</p>\n<p>关于如何仿写，诀窍就是一句话：耐下心，沉住气，一点点推进自己的计划（后来发现做任何事都是这样子的~）。比如决定仿写蘑菇博客时，首先就是将这个项目拉下来，在本地运行起来，把项目跑跑看（好的项目文档也不会差，蘑菇博客太nice了，再次致敬陌溪大佬）。按照博客的文档步骤，一步一步将环境都安装下来，遇到问题的时候也不要慌，先定位问题，然后尝试自己解决问题，先百度或者Google去搜索看看，还是没有就去issure里找找，如果还是没有就去作者往期的文档里找找，应该也会有，所有的都尝试一个遍时，还是没有解决，这时候就可以去交流群里问一下大佬。描述问题的时候应该注意一点，把问题的场景，代码、报错、以及自己尝试的解决方式最好都描述一下，再带上清晰完整的截图，基本上懂得人都会帮你解答了（发现搞技术的人都很存粹，越厉害的大佬越有耐心，如果不给你解答，多半是问问题的方式不对，或者大佬确实太忙😂）。</p>\n<p>剩下做的就是见招拆招，面向百度编程、面向文档编程，把功能一步一步的实现，只要坚持下来，你会发现自己竟然也能这么厉害🤭</p>\n<p>不过当你回顾自己做出来的东西时，会有一个大大的疑惑——这玩意我是怎么做出来的？😳</p>\n<p>这就是我为什么一直想要做一个自己的博客网站的原因，我太容易忘了！而当我有自己的网站时，我可以每次把自己学到的知识记录下来，每次再回过头想要了解自己的知识体系时，可以有一个对应的文章可循。博客网站可以把自己学的知识量化，可以把它们分成体系，技术类的、生活类的、娱乐类的、工具类的、常识类的等等等。相信日后如果能一直坚持下来，定会惊叹自己的知识量吧😄，加油加油💪</p>\n<h2>相较于蘑菇博客我改写了哪些地方</h2>\n<p>在重写蘑菇博客时，我也根据自己的喜好做了一些调整，下面做一个简单的汇总。</p>\n<h3>布局上做了细微调整</h3>\n<p>设计页面时，我设计了一个宽<code>1200px</code>的版心，所有的内容都在版心里，目前并没有做移动端适配，以后可能会单独写一套移动端的页面。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291610853.png\" alt=\"image-20211029161038716\" /></p>\n<h3>将时间、分类、标签 三种归档方式移动至一个页面中</h3>\n<p>当时觉得这三种归档方式都算是归档，索性就移动到了一起。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291611594.png\" alt=\"image-20211029161128948\" /></p>\n<h3>重写了专题详情的样式</h3>\n<p>蘑菇博客采用的是侧边栏弹窗的方式，每一个专题下面的文章以列表的形式展示。因为我想要分的更细，所以就单独写了一个专题详情页面，页面UI参考的是 <a href=\"https://zh.javascript.info/\">现代 JavaScript 教程</a>。比较喜欢这个网站的布局风格，所以就仿写了一下，效果如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291551289.png\" alt=\"image-20211029155133691\" /></p>\n<h3>重写专题列表样式</h3>\n<p>设计博客最初的想法是以后可以把方方面面学到的知识都记录下来（总感觉自己记性不好，那以后就干脆都记下来吧，┑(￣Д ￣)┍）。所以我希望专题的分类可以有多种类型，不限于技术类的，也可能是生活类的、摄影类的等等等等。毕竟活到老学到老嘛。所以就借鉴了 <a href=\"https://www.kuangstudy.com/course\">KuangStudy</a> 课程分类的UI，效果如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291601395.png\" alt=\"image-20211029160106313\" /></p>\n<h3>重写了评论组件</h3>\n<p>自己今年访问最多的网站应属<a href=\"https://gitee.com/hrbust_cheny/pupu_blog\">Gitee</a>了，毕竟几乎大部分时间都在上面提交代码（Gihub国内访问太揪心了( ╯□╰ )）。看了很多网站的评论模块，感觉都没有Gitee的评论做的清晰（单独指的PC端），就比如刷微博、逛知乎的时候，有时候我就看不太懂是谁回复的谁，还得稍微思考一下，可能自己习惯Gitee这种直接罗列出来的风格，然后也比较喜欢Gitee评论的留言相互点赞功能，所以就高仿Gitee的评论模块，自己也单独实现了一下，效果如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291608965.png\" alt=\"image-20211029160822872\" /></p>\n<h3>重写了文章贡献度模块</h3>\n<p>（功能尚未完成，只有静态页面）</p>\n<p>蘑菇博客使用Echarts实现的文章贡献度展示，根据每天发布文章的多少来显示对应的小点，每天更新越多小点覆盖面积就越大。我也挺喜欢这个功能的，毕竟这个功能也能激励自己持续学习嘛。每当看到一页绿油油的小点时，都会有一种成就感，原来自己不知不觉坚持了那么久呢。将仿写进行到底，因为习惯了gitee，所以继续仿写gitee。gitee这块实现的比较巧妙，所有的方格实际都是一个个小块<code>div</code>，使用flex布局和定位实现的。相较于github用的canvas简单不少，并且也符合我的审美，实现效果如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291623362.png\" alt=\"image-20211029162305287\" /></p>\n<h3>重写了登录弹窗组件，支持QQ登录、Gitee登录</h3>\n<p>登录直接采用的第三方登录，当前只支持Gitee和QQ登录，如果想了解这个第三方登录是怎么实现的，初次最好接入Gitee的第三方登录。Gitee限制是最少的，直接可以在本地申请应用，并且回调接口直接可以填写本地localhost，非常方便。而QQ和微博是很麻烦的，接入他们的功能必须有一个备案好的域名，并且需要审核，很麻烦（微博到现在都没有审核通过( ╯□╰ )）。接入第三方登录整体流程大概如下（交互方式仿掘金）：</p>\n<ol>\n<li>点击登录后会弹出一个请求第三方应用<code>code</code>的新窗口</li>\n<li>然后第三方会用这个<code>code</code>去调用你申请应用时填写的回调接口</li>\n<li>在自己回调接口这儿，通过拿到的code和申请的密钥，向第三方服务器发送请求，拿到access_code</li>\n<li>通过access_code和密钥再去请求第三方接口，去拿到对应平台的用户信息</li>\n<li>把用户信息存储到自己数据库中，返回给前台一个token</li>\n<li>弹出的窗口会接收到这个token，通过跨窗口通信的方式将token传递给自己的主页</li>\n<li>前台保存token，刷新页面，通过token向后台拿到用户信息，这样就完成了第三方登录功能</li>\n</ol>\n<blockquote>\n<p>tip：整体的流程大致是上面几步，略微会有些差异，不过影响不大。</p>\n<p>登录模块的UI风格模仿的<a href=\"https://juejin.cn/\">掘金</a>登录框，只不过把手机登录给去掉了，没办法，要钱( ╯□╰ )。</p>\n</blockquote>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291644335.png\" alt=\"image-20211029164403245\" /></p>\n<h3>重写个人中心</h3>\n<p>（功能尚未完成，当前只是静态页面）</p>\n<p>整体页面UI也是仿照的<a href=\"https://juejin.cn/\">掘金</a>的个人中心，不过感觉现在没人会用，就先放一放了，效果如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291646738.png\" alt=\"image-20211029164635669\" /></p>\n<h3>后台管理端重写专题分组样式</h3>\n<p>因为专题的逻辑更改，所以后台重写一了专题的添加方式，效果如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291629897.png\" alt=\"image-20211029162911791\" /></p>\n<h3>后台管理端重写图片管理样式</h3>\n<p>上传图片按照时间呈列表状排列，效果如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291634468.png\" alt=\"image-20211029163425364\" /></p>\n<h3>评论增加了后台审核</h3>\n<p>因为有交互，所以最好还是将留言审核一下再发布出来，未审核的留言只能发布人自己看到。目前审核的方式是人工审核，比较麻烦。后期有时间会改为自动审核，并且留言现在没有增加邮件通知，都是自己随缘上去看，很不方便，邮件通知后期有时间也会加上。整体效果如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291637303.png\" alt=\"image-20211029163745169\" /></p>\n<h3>博客推荐拖拽组件改为了可以跨级别推荐</h3>\n<p>在蘑菇博客的设计中，总共设计了四个推荐板块：一级推荐（首页轮播图）、二级推荐（轮播图的右侧的两篇文章）、三级推荐（主页右侧的特别推荐专栏）、四级推荐（主页右侧的推荐文章专栏）。在改变推荐等级排列顺序的功能里，对原本的功能做了一个简单的优化。博客原本的交互方式就特别好，使用拖拽组件<a href=\"https://github.com/SortableJS/Vue.Draggable\">vuedraggable</a>包裹的，同一级别的博客可以拖动着修改排列顺序，但是目前不支持跨级别拖动。然后我研究了一下这个拖拽组件，改为了可以跨级别拖动，实现效果如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291659757.png\" alt=\"image-20211029165908654\" /></p>\n<h2>开发中遇到了哪些困难，有没有想过放弃</h2>\n<p>不知不觉，小半年已经过去了，想想整体的开发流程还是比较顺利的，但是也有一些困难（可能有挺多困难，我给忘了😂），有一回也差点放弃了，这里简单回顾一下。</p>\n<p>说起最艰难的岁月，莫过于刚开始（果然是万事开头难😫）。因为自己也是在学习阶段，很多都是摸黑瞎弄，想完全重构蘑菇博客，谈何容易。那么就不想那么多，一个功能一个功能去实现，该写页面写页面，该写接口写接口，逢山开路、见招拆招，闷着头干就完事。</p>\n<p>从零开始写，首先就需要构建项目脚手架，蘑菇博客用的是vue2带webpack目录版本的脚手架（其实我想学的就是这版本，顺带还能学学webpack），所以就去<a href=\"https://cn.vuejs.org/\">官网</a>看了一下怎么构建老版本的脚手架，果然找到了<img src=\"http://cdn.qiniu.bnbiye.cn/img/202110291714190.png\" alt=\"image-20211029171452125\" /></p>\n<p>全局安装个桥接工具<code>@vue/cli-init</code>，然后使用<code>vue init xxx</code>就可以初始化一个带webpack目录的脚手架，但是下载下来的项目webpack的版本是3，而蘑菇博客的版本是4，然后就网上各种找帖子，升级webpack，最后好在是成功了。</p>\n<p>然后就是写页面，这个过程就比较顺手，因为有了蘑菇博客做参照，不用纠结颜色布局之类的，特意修改的布局也是参照别的网站，剩下的就是写页面、封组件，不会的语法查<a href=\"https://cn.vuejs.org/v2/guide/\">vue官网文档</a>，<a href=\"https://element.eleme.cn/#/zh-CN/component/installation\">element-ui</a>上能复用的组件直接拿来用。但是仿写的评论组件、贡献度组件，前前后后也花了很多时间。</p>\n<p>最想放弃的时候是写业务接口，增删改查逻辑。代码都是重复的，每建一个新表，都需要写一套增删改查逻辑，并在后台管理端写一套对应的页面，配一遍路由，很是麻烦。这里面除了重复性的粘贴工作外，最头疼的是替换变量参数。数据库里的字段我使用的是下划线的格式，比如表名使用<code>t_blog</code>，里面的字段为<code>blog_title</code>等等这样的形式。然后写接口时，参数我是以小驼峰的格式接收的，比如<code>blogTitle</code>。然后还有接口的命名方式<code>saveBlog</code>、<code>queryBlog</code>、<code>updateBlog</code>、<code>deleteBlog</code>，等等这些需要替换的地方真是太多了，稍微不注意就少了那块多了那块。当我写完两个模块的时候，就想放弃了，简直是不要太麻烦了┑(￣Д ￣)┍</p>\n<p>后来想了一想，其实重复性的工作，是完全可以用代码解决的。</p>\n<p>所有的业务接口都是在操作数据库表，业务代码实则都是对数据库表中字段执行增删改查操作。那么我只要在建表时，遵循一定规范，然后根据规范去生成代码不就好了嘛，别的就是文件读取正则替换的事了，所以难点就是制定规则和解析sql文件。后来观察了一下导出的sql文件，其实也是有规律的，只要有规律，那么就都不复杂，说干就干，首先制定建表规则：</p>\n<ol>\n<li>所有表都需要有<code>uid</code>，<code>oreder</code>、<code>create_time</code>、<code>update_time</code>字段，即主键、排列方式、创建时间、修改时间</li>\n<li>所有需要后端接口校验的字段，都设置为必填</li>\n<li>所有有默认值的字段，都可以作为条件查询时的筛选条件</li>\n<li>所有字段都必须有注释，并且注释的方式以<code>xxx：xxxxx</code>的格式，冒号是中文冒号，注释里只有一个中文冒号，冒号前注释就是字段的中文注释，这样在生成后台管理端代码时，也可以直接把中文注释给生成出来，比如，input框里的placeholder，直接可以生成<code>请输入xxx</code></li>\n</ol>\n<p>基于上面的建表规则，每次只需将表创建好，把导出的sql文件逐行解析成json对象，提前定义好代码模板和占位符，最后读取模板，替换占位符为相应的字段名，最后将替换后的文件写入对应的目录下，这不就成了嘛，分析好思路后其实也不难。执行起来大概分为下面几步：</p>\n<ol>\n<li>\n<p>按照自定义的规则建立数据表</p>\n</li>\n<li>\n<p>导出数据库为sql文件</p>\n</li>\n<li>\n<p>解析sql文件，将建表语句转换为json对象，如</p>\n<pre><code class=\"language-js\">[\n   {\n       name: \'t_blog\',\n       comment: \'string\',\n       columns: [\n           {\n               label: \'string\',\n               comment: \'string\',\n               type: \'string\',\n               isRequire: true|false,\n               defaultValue: \'\',\n           },\n       ],\n   },\n]\n</code></pre>\n</li>\n<li>\n<p>定义模板代码，需要替换的地方提前定义好占位符，如</p>\n</li>\n<li>\n<p>读取模板代码，通过解析好的数据表的json对象，逐个替换占位符为对应结果，如（$VAR_SMALL_HUMP$）</p>\n<pre><code class=\"language-js\">//小驼峰格式占位符\nconst smallHumpPlaceholder = /\\$VAR_SMALL_HUMP\\$/g\n//大驼峰格式占位符\nconst bigHumpPlaceholder = /\\$VAR_BIG_HUMP\\$/g\n//连字符格式占位符\nconst hyphenPlaceholder = /\\$VAR_HYPHEN\\$/g\n//常量格式占位符\nconst constantPlaceholder = /\\$VAR_CONSTANT\\$/g\n//表名占位符\nconst sqlTableNamePlaceholder = /\\$MY_SQL_TABLE_NAME\\$/g\n//类名占位符\nconst classNamePlaceholder = /\\$VAR_CLASS_NAME\\$/g\n</code></pre>\n</li>\n<li>\n<p>将替换好的代码写入对应目录下</p>\n</li>\n</ol>\n<p>当实现了自定义的代码生成器后，第一次生成一个模块的代码时，满满的都是成就感😊</p>\n<h2>最后</h2>\n<p>前几天在蘑菇博客交流群里给大家看了一下实现的效果，得到了陌溪大佬的肯定，还是很开心的。</p>\n<p>生活还在继续，短暂的停歇一下，继续向着自己的目标迈进吧，加油加油💪</p>\n<p>本人是一年开发经验的小前端，项目是在空闲时间完成的，后期还会慢慢完善，目前先暂停一阵，备战面试~</p>\n<p>另外附上项目地址，感兴趣的小伙伴可以帮忙点个star关注一下🙏，也欢迎大家提issure和留言，如哪里有错误的地方，欢迎指正，让我们共同进步💪</p>\n<p>项目线上地址：http://bnbiye.cn</p>\n<p>项目仓库地址：https://gitee.com/hrbust_cheny/pupu_blog</p>\n', '2021-10-30 20:39:02', '2021-11-11 15:49:59');
INSERT INTO `t_blog` VALUES ('5d170b20-5fea-11ec-b395-6d1b1a7579ec', '二叉树的下一个结点', 'JZ8 二叉树的下一个结点', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 1, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p>给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。下图为一棵有9个节点的二叉树。树中从父节点指向子节点的指针用实线表示，从子节点指向父节点的用虚线表示</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112181634820.png\" alt=\"image-20211218163434734\" /></p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112181635841.png\" alt=\"image-20211218163532791\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112181635544.png\" alt=\"image-20211218163548499\" /></p>\n<h2>代码</h2>\n<h3>代码1 先找到二叉树的根，然后中序遍历，将结果保存到数组中，然后在数组中找到下一节点</h3>\n<pre><code class=\"language-js\">/*\n这个题一定要认真读题，给的是二叉树的其中一个节点，但是略微不同，节点记录了父节点的引用\n所以我们可以根据这个引用找到树的根节点，然后中序遍历根节点，找到给出节点中序遍历后的下一节点\n1. 找到树的根节点\n2. 中序遍历根节点，将结果保存到一个数组中\n3. 从数组中比对，找到传入节点的下一节点\n*/\nfunction GetNext(pNode)\n{\n    // 找到根节点\n    let vRoot = pNode\n    while(vRoot.next){\n        vRoot = vRoot.next\n    } // 找到了\n    \n    let tempArr = [] // 存储中序遍历结果\n    \n    // 中序遍历，将结果保存到数组中\n    inOrder(vRoot)\n    \n    // 开始从数组中找\n    let i = 0\n    for(; i &lt; tempArr.length; i++){\n        if(tempArr[i] === pNode) { // 找到了\n            break\n        }\n    }\n    \n    // 如果找到的是最后一个节点，或者直接遍历完事都没有找到，返回null\n    if(i === tempArr.length-1 || i === tempArr.length ) return null\n    return tempArr[i+1] // 返回下一节点\n    \n    function inOrder(vRoot){\n        if(!vRoot) return\n        \n        inOrder(vRoot.left)\n        tempArr.push(vRoot)\n        inOrder(vRoot.right)\n    }\n}\n</code></pre>\n<p>时间复杂度O(n)：递归的节点数<br />\n空间复杂度O(n)：数组保存的节点数</p>\n<h3>代码2  分情况直接找</h3>\n<pre><code class=\"language-js\">/*\n直接找\n1. 如果有右子树，下一节点是右子树的最左节点，如果找不到最左节点，那就是右子树这个节点\n2. 没有右子树时，\n    2.1 在某一父节点的左子树上，那下一节点就是这个父节点\n    2.2 在某一父节点的右子树上，就一直顺着这个父节点往上找，直到找到某个节点是父节点的左子树，如果存在，这个节点就是下一节点\n    \n剩余情况就返回null\n    \n*/\nfunction GetNext(pNode)\n{\n    // 1. 有右子树，下一节点就是右子树的最左节点\n    if(pNode.right){\n        let node = pNode.right\n        // 找它的最左节点\n        while(node.left){ // 如果没有左节点，那这个节点就是下一节点，如果有，就找最左节点\n            node = node.left\n        }\n        return node\n    }\n    \n    // 2.1 没有右子树，为某一父节点的左子树\n    if(!pNode.right &amp;&amp; pNode.next &amp;&amp; pNode.next.left === pNode){\n        // 那么这个父节点就是下一节点\n        return pNode.next\n    }\n    \n    // 2.2 没有右子树，为某一父节点的右子树\n    if(!pNode.right  &amp;&amp; pNode.next &amp;&amp; pNode.next.right === pNode){\n        // 沿着父节点一直往上找，直到找到某一个节点是他父节点的左子树时，下一节点就是结果\n        let node = pNode.next\n        \n        while(node.next &amp;&amp; node.next.right === node ){\n            node = node.next\n        }\n        \n        return node.next\n    }\n    \n    return null // 其他情况，返回null\n}\n</code></pre>\n<p>时间复杂度O(n)：最坏的情况是一条链表，直接往上会找n次</p>\n<p>空间复杂度O(1)：并未有任何的其他开销，全部在原来的链表上操作的。</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e?tpId=13&amp;tqId=23451&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\">JZ8 二叉树的下一个结点</a></p>\n', '2021-12-18 18:07:53', '2021-12-18 18:07:53');
INSERT INTO `t_blog` VALUES ('64a45de0-574b-11ec-96d5-7933aca11ca0', '前瞻断言与后瞻断言', '当我们想排除掉左边，然后再排除右边，取中间的一部分字符串时，我们可以使用前瞻断言或者后瞻断言，会很方便。', '-1', 2, 'https://zh.javascript.info/regexp-lookahead-lookbehind', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 3, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>有时候我们需要匹配后面跟着特定模式的一段模式。比如，我们要从 <code>1 turkey costs 30€</code> 这段字符中匹配价格数值。</p>\n<p>我们需要获取 <code>€</code> 符号前面的数值（假设价格是整数）。</p>\n<p>那就是前瞻断言要做的事情。</p>\n<h2>前瞻断言</h2>\n<p>语法为：<code>x(?=y)</code>，它表示 “匹配 <code>x</code>, 仅在后面是 <code>y</code> 的情况&quot;”</p>\n<p>那么对于一个后面跟着 <code>€</code> 的整数金额，它的正则表达式应该为：<code>\\d+(?=€)</code>。</p>\n<pre><code class=\"language-js\">let str = &quot;1 turkey costs 30€&quot;;\n\n// 前瞻断言\nconsole.log(str.match(/\\d+(?=€)/)); // 30 （正确地跳过了单个的数字 1）\n// [ \'30\', index: 15, input: \'1 turkey costs 30€\', groups: undefined ]\n</code></pre>\n<p>让我们来看另一种情况：这次我们想要一个数量，它是一个不被 <code>€</code> 跟着的数值。</p>\n<p>这里就要用到前瞻否定断言了。</p>\n<p>语法为：<code>x(?!y)</code>，意思是 “查找 <code>x</code>, 但是仅在不被 <code>y</code> 跟随的情况下匹配成功”。</p>\n<pre><code class=\"language-js\">let str = &quot;2 turkeys cost 60€&quot;;\n\n// 前瞻否定断言\nconsole.log(str.match(/\\d+(?!€)/)); // 2（正确地跳过了价格）\n// [ \'2\', index: 0, input: \'2 turkeys cost 60€\', groups: undefined ]\n</code></pre>\n<h2>后瞻断言</h2>\n<p>前瞻断言允许添加一个“后面要跟着什么”的条件判断。</p>\n<p>后瞻断言也是类似的，只不过它是在相反的方向上进行条件判断。也就是说，它只允许匹配前面有特定字符串的模式。</p>\n<p>语法为:</p>\n<ul>\n<li>后瞻肯定断言：<code>(?&lt;=y)x</code>, 匹配 <code>x</code>, 仅在前面是 <code>y</code> 的情况。</li>\n<li>后瞻否定断言：<code>(?&lt;!y)x</code>, 匹配 <code>x</code>, 仅在前面不是 <code>y</code> 的情况。</li>\n</ul>\n<p>举个例子，让我们把价格换成美元。美元符号通常在数字之前，所以要查找 <code>$30</code> 我们将使用 <code>(?&lt;=\\$)\\d+</code> —— 一个前面带 <code>$</code> 的数值：</p>\n<pre><code class=\"language-js\">let str = &quot;1 turkey costs $30&quot;;\n\n// 后瞻断言\nconsole.log(str.match(/(?&lt;=\\$)\\d+/)); // 30 （跳过了单个的数字 1）\n// [ \'30\', index: 16, input: \'1 turkey costs $30\', groups: undefined ]\n</code></pre>\n<p>另外，为了找到数量 —— 一个前面不带 <code>$</code> 的数字，我们可以使用否定后瞻断言：<code>(?&lt;!\\$)\\d+</code></p>\n<pre><code class=\"language-js\">let str = &quot;2 turkeys cost $60&quot;;\n\n// 后瞻否定断言\nconsole.log(str.match(/(?&lt;!\\$)\\d+/)); // 2 (跳过了价格)\n// [ \'2\', index: 0, input: \'2 turkeys cost $60\', groups: undefined ]\n</code></pre>\n<h2>捕获组</h2>\n<p>一般来说，环视断言括号中（前瞻和后瞻的通用名称）的内容不会成为匹配到的一部分结果。</p>\n<p>例如：在模式 <code>\\d+(?!€)</code> 中，<code>€</code> 符号就不会出现在匹配结果中。</p>\n<p>但是如果我们想要捕捉整个环视表达式或其中的一部分，那也是有可能的。只需要将其包裹在另加的括号中。</p>\n<p>例如，这里货币符号 <code>(€|kr)</code> 和金额一起被捕获了：</p>\n<pre><code class=\"language-js\">let str = &quot;1 turkey costs 30€&quot;;\nlet reg = /\\d+(?=(€|kr))/; // €|kr 两边有额外的括号\n\nconsole.log(str.match(reg)); // 30, €\n/*\n[\n  \'30\',\n  \'€\',\n  index: 15,\n  input: \'1 turkey costs 30€\',\n  groups: undefined\n]\n*/\n</code></pre>\n<p>后瞻断言也一样：</p>\n<pre><code class=\"language-js\">let str = &quot;1 turkey costs $30&quot;;\nlet reg = /(?&lt;=(\\$|£))\\d+/;\n\nconsole.log(str.match(reg)); // 30, $\n/*\n[\n  \'30\',\n  \'$\',\n  index: 16,\n  input: \'1 turkey costs $30\',\n  groups: undefined\n]\n*/\n</code></pre>\n<p>请注意，对于后瞻断言，顺序保持不变，尽管前瞻括号在主模式之前。</p>\n<p>通常括号是从左到右编号，但是后瞻断言是一个例外，它总是在主模式之后被捕获。所以 <code>\\d+</code> 的匹配会首先进入结果数组，然后是 <code>(\\$|£)</code>。</p>\n<h2>总结</h2>\n<p>当我们想排除掉左边，然后再排除右边，取中间的一部分字符串时，使用前瞻断言或者后瞻断言（通常被称为“环视断言”）就很方便了。比如：</p>\n<pre><code class=\"language-js\">let str = `CREATE TABLE \\`t_role\\`  (`\n/*\n有一个建表的sql语句，想匹配它的表名\n前面是固定的 CREATE TABLE `\n后面也是固定的 `  (\n我们只想取中间的表名\n就可以使用前瞻和后瞻断言\n*/\n\nlet reg = /(?&lt;=CREATE TABLE `)\\w+(?=`  \\()/\nconsole.log(str.match(reg)); // t_role\n/*\n[\n  \'t_role\',\n  index: 14,\n  input: \'CREATE TABLE `t_role`  (\',\n  groups: undefined\n]\n*/\n</code></pre>\n<ol>\n<li>前瞻肯定断言<code>x(?=y)</code>：表示我只想得到前边的<code>x</code>，且<code>x</code>的后面需要紧跟着<code>y</code></li>\n<li>前瞻否定断言<code>x(?!y)</code>：表示我只想得到前边的<code>x</code>，且后面不能是<code>y</code></li>\n<li>后瞻肯定断言<code>(?&lt;=y)x</code>：表示我只想得到后边的<code>x</code>，且x的前面必须是<code>y</code></li>\n<li>后瞻否定断言<code>(?&lt;!y)x</code>：表示我只想得到后边的<code>x</code>，且x的前面不能是<code>y</code></li>\n</ol>\n<p>虽然前瞻和后瞻断言也是用括号包裹的，但是他们不会记作为捕获组，如果想获取到它们匹配到的值，可以使用括号把需要匹配的结果再包裹一下，比如：</p>\n<ol>\n<li><code>x(?=(y|z))</code></li>\n<li><code>x(?!(y|z))</code></li>\n<li><code>(?&lt;=(y|z))x</code></li>\n<li><code>(?!=(y|z))x</code></li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-lookahead-lookbehind\">https://zh.javascript.info/regexp-lookahead-lookbehind</a></p>\n', '2021-12-07 18:49:46', '2021-12-07 18:49:46');
INSERT INTO `t_blog` VALUES ('6d0bd440-49db-11ec-96d5-7933aca11ca0', 'js中数组Array的常用方法', '本章来总结一下js中数组`Array`的常用方法，都是基础，测试一下自己的掌握情况。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 11, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>本章来总结一下js中数组<code>Array</code>的常用方法，都是基础，测试一下自己的掌握情况。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>length</td>\n<td>返回或设置一个数组中的元素个数。</td>\n</tr>\n<tr>\n<td>concat()</td>\n<td>合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</td>\n</tr>\n<tr>\n<td>copyWithin()</td>\n<td>浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</td>\n</tr>\n<tr>\n<td>entries()</td>\n<td>返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对。</td>\n</tr>\n<tr>\n<td>every()</td>\n<td>测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。</td>\n</tr>\n<tr>\n<td>fill()</td>\n<td>用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。</td>\n</tr>\n<tr>\n<td>filter()</td>\n<td>创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</td>\n</tr>\n<tr>\n<td>find()</td>\n<td>返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</td>\n</tr>\n<tr>\n<td>findIndex()</td>\n<td>返回数组中满足提供的测试函数的第一个元素的<strong>索引</strong>。若没有找到对应元素则返回-1。</td>\n</tr>\n<tr>\n<td>flat()</td>\n<td>按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</td>\n</tr>\n<tr>\n<td>forEach()</td>\n<td>对数组的每个元素执行一次给定的函数。</td>\n</tr>\n<tr>\n<td>from()</td>\n<td>对一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</td>\n</tr>\n<tr>\n<td>includes()</td>\n<td>判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 <code>true</code>，否则返回 <code>false</code>。</td>\n</tr>\n<tr>\n<td>indexOf()</td>\n<td>返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</td>\n</tr>\n<tr>\n<td>isArray()</td>\n<td>用于确定传递的值是否是一个 Array，如果是返回true，否则返回false。</td>\n</tr>\n<tr>\n<td>join()</td>\n<td>将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</td>\n</tr>\n<tr>\n<td>keys()</td>\n<td>返回一个包含数组中每个索引键的Array Iterator对象。</td>\n</tr>\n<tr>\n<td>lastIndexOf()</td>\n<td>返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。</td>\n</tr>\n<tr>\n<td>map()</td>\n<td>创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</td>\n</tr>\n<tr>\n<td>of()</td>\n<td>创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</td>\n</tr>\n<tr>\n<td>pop()</td>\n<td>从数组中删除最后一个元素，并返回该元素的值。此方法更改数组的长度。</td>\n</tr>\n<tr>\n<td>push()</td>\n<td>将一个或多个元素添加到数组的末尾，并返回该数组的新长度。</td>\n</tr>\n<tr>\n<td>reduce()</td>\n<td>对数组中的每个元素执行一个由您提供的<strong>reducer</strong>函数(升序执行)，将其结果汇总为单个返回值。</td>\n</tr>\n<tr>\n<td>reverse()</td>\n<td>将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。</td>\n</tr>\n<tr>\n<td>shift()</td>\n<td>从数组中删除<strong>第一个</strong>元素，并返回该元素的值。此方法更改数组的长度。</td>\n</tr>\n<tr>\n<td>slice()</td>\n<td>返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。原始数组不会被改变。</td>\n</tr>\n<tr>\n<td>some()</td>\n<td>测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。</td>\n</tr>\n<tr>\n<td>sort()</td>\n<td>对数组的元素进行排序，并返回数组。</td>\n</tr>\n<tr>\n<td>splice()</td>\n<td>删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。</td>\n</tr>\n<tr>\n<td>toString()</td>\n<td>返回一个字符串，表示指定的数组及其元素。</td>\n</tr>\n<tr>\n<td>unshift()</td>\n<td>将一个或多个元素添加到数组的<strong>开头</strong>，并返回该数组的<strong>新长度</strong>(该方法修改原有数组)。</td>\n</tr>\n<tr>\n<td>values()</td>\n<td>返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值。</td>\n</tr>\n</tbody>\n</table>\n<p>为了便于记忆，我们做一个归类，一个一个的学习一下。</p>\n<h2>Array类的属性和方法</h2>\n<h3><code>Array.length</code></h3>\n<ol>\n<li>\n<p>获取数组长度</p>\n<pre><code class=\"language-js\">let a = [1, 2, 3]\nconsole.log(a.length); // 3\n</code></pre>\n</li>\n<li>\n<p>遍历数组</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3]\nfor (let i = 0; i &lt; arr.length; i++) {\n    console.log(arr[i]);\n}\n// 1 2 3\n</code></pre>\n</li>\n<li>\n<p>截断数组</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3]\narr.length = 1\nconsole.log(arr); // [1]\n</code></pre>\n</li>\n</ol>\n<h3><code>Array.Of()</code></h3>\n<ol>\n<li>\n<p>创建一个具有可变数量参数的新数组实例，而不考虑参数的数量或类型。</p>\n<pre><code class=\"language-js\">let arr1 = Array.of(7)\nconsole.log(arr1); // [7]\nlet arr2 = Array.of(7, 8, 9)\nconsole.log(arr2); // [ 7, 8, 9 ]\n</code></pre>\n</li>\n<li>\n<p><code>Array(7)</code>与<code>Array.of(7)</code>的区别</p>\n<pre><code class=\"language-js\">let arr1 = Array.of(7)\nconsole.log(arr1); // [7]\nlet arr3 = Array(7)\nconsole.log(arr3); // [ &lt;7 empty items&gt; ] [undefined,...,undefined]\n</code></pre>\n</li>\n</ol>\n<h3><code>Array.from()</code></h3>\n<p>将一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</p>\n<ol>\n<li>从 <code>String</code> 生成数组</li>\n<li>从 <code>Set</code> 生成数组</li>\n<li>从 <code>Map</code> 生成数组</li>\n<li>从 类数组对象<code>arguments</code> 生成数组</li>\n</ol>\n<pre><code class=\"language-js\">let str = \'foo\'\nlet set = new Set([\'aa\', \'bb\', \'cc\', \'aa\'])\nlet map = new Map([[1, \'aa\'], [2, \'bb\'], [3, \'cc\']])\n\nconsole.log(Array.from(str)); // [ \'f\', \'o\', \'o\' ]\nconsole.log(Array.from(set)); // [ \'aa\', \'bb\', \'cc\' ]\nconsole.log(Array.from(map)); // [ [ 1, \'aa\' ], [ 2, \'bb\' ], [ 3, \'cc\' ] ]\n\nfunction fn() {\n    console.log(Array.from(arguments)); // [ 1, 2, 3, 4, 5 ]\n}\nfn(1, 2, 3, 4, 5)\n</code></pre>\n<h3><code>Array.isArray()</code></h3>\n<p>确定传递的值是否是一个<code>Array</code></p>\n<pre><code class=\"language-js\">Array.isArray([1, 2, 3]); // true\nArray.isArray({foo: 123}); // false\nArray.isArray(&quot;foobar&quot;); // false\nArray.isArray(undefined); // false\n</code></pre>\n<h2>Array原型上的方法</h2>\n<h3>数组元素添加和删除</h3>\n<h4>push、pop</h4>\n<ol>\n<li>\n<p>push() 在数组末尾添加元素，并返回该数组的新长度。</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3]\nconsole.log(arr.length); // 3\nconsole.log(arr.push(\'aa\')); // 4\nconsole.log(arr); // [ 1, 2, 3, \'aa\' ]\n</code></pre>\n</li>\n<li>\n<p>pop() 删除数组最后一个元素，返回该元素的值。此方法更改数组的长度。</p>\n<pre><code class=\"language-js\">let arr = [1, 2, \'aa\']\nconsole.log(arr.length); // 3\nconsole.log(arr.pop()); // aa\nconsole.log(arr); // [ 1, 2 ]\n</code></pre>\n</li>\n</ol>\n<h4>unshift、shift</h4>\n<ol>\n<li>\n<p>unshift() 在数组开头添加元素，返回新长度。此方法更改原数组。</p>\n<pre><code class=\"language-js\">let arr = [1, 2, \'aa\']\nconsole.log(arr.unshift(\'bb\')); // 4\nconsole.log(arr); // [ \'bb\', 1, 2, \'aa\' ]\n</code></pre>\n</li>\n<li>\n<p>shift() 删除数组第一个元素，返回该元素的值。此方法更改原数组。</p>\n<pre><code class=\"language-js\">let arr = [1, 2, \'aa\']\nconsole.log(arr.shift()); // 1\nconsole.log(arr); // [ 2, \'aa\' ]\n</code></pre>\n</li>\n</ol>\n<h4>splice</h4>\n<p>很强大的一个方法，可以删除数组中的元素，还可以添加元素，会改变原数组。</p>\n<p><code>array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</code>，表示从索引<code>deleteCount</code>表示删除多少个元素</p>\n<ol>\n<li>\n<p>删除元素</p>\n<pre><code class=\"language-js\">let arr1 = [\'aa\', \'bb\', \'cc\', \'dd\']\nconsole.log(arr1.splice(1)); // [ \'bb\', \'cc\', \'dd\' ]，表示索引1开始，包括索引1，后面的全给删除\nconsole.log(arr1); // [ \'aa\' ]\n\nlet arr2 = [\'aa\', \'bb\', \'cc\', \'dd\']\nconsole.log(arr2.splice(1, 2)); // [ \'bb\', \'cc\' ]，表示索引1开始，包括索引1，删除2个\nconsole.log(arr2); // [ \'aa\', \'dd\' ]\n</code></pre>\n</li>\n<li>\n<p>添加元素</p>\n<pre><code class=\"language-js\">let arr3 = [\'aa\', \'bb\', \'cc\', \'dd\']\nconsole.log(arr3.splice(1, 2, \'item1\', \'item2\')); // [ \'bb\', \'cc\' ]，表示索引1开始，包括索引1，删除2个，然后从删除的地方新添加 item1，item2\nconsole.log(arr3); // [ \'aa\', \'item1\', \'item2\', \'dd\' ]\n\nlet arr4 = [\'aa\', \'bb\', \'cc\', \'dd\']\nconsole.log(arr4.splice(1, 0, \'item1\', \'item2\')); // []，表示索引1开始，包括索引1，删除0个，然后从删除的地方新添加 item1，item2\nconsole.log(arr4); // [ \'aa\', \'item1\', \'item2\', \'bb\', \'cc\', \'dd\' ]\n</code></pre>\n</li>\n</ol>\n<h4>fill</h4>\n<p>用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。一般用来初始化数组，该方法会改变原数组，返回值就是改变后的原数组。</p>\n<ol>\n<li>\n<p>初始化数组</p>\n<pre><code class=\"language-js\">let arr = new Array(3)\nconsole.log(arr); // [ &lt;3 empty items&gt; ]\narr.fill(\'aa\')\nconsole.log(arr); // [ \'aa\', \'aa\', \'aa\' ]\n</code></pre>\n</li>\n<li>\n<p>填充一部分值</p>\n<pre><code class=\"language-js\">let arr = [\'aa\', \'bb\', \'cc\', \'dd\', \'ee\']\nconsole.log(arr.fill(1, 0, 2)); // [ 1, 1, \'cc\', \'dd\', \'ee\' ]，从索引0填充到索引2，不包括2\nconsole.log(arr); // [ 1, 1, \'cc\', \'dd\', \'ee\' ]\n</code></pre>\n</li>\n</ol>\n<h4>copyWithin</h4>\n<p>浅复制数组的一部分到同一数组中的另一个位置，并返回它，不会改变原数组的长度。</p>\n<pre><code class=\"language-js\">let arr1 = [\'aa\', \'bb\', \'cc\', \'dd\', \'ee\']\nconsole.log(arr1.copyWithin(0, 3)); // [ \'dd\', \'ee\', \'cc\', \'dd\', \'ee\' ]，表示，从索引3往后的值，按顺序从索引0开始复制，原数组长度不变\nconsole.log(arr1); // [ \'dd\', \'ee\', \'cc\', \'dd\', \'ee\' ] 原数组长度不变，但数组被改变了\n\nlet arr2 = [\'aa\', \'bb\', \'cc\', \'dd\', \'ee\']\nconsole.log(arr2.copyWithin(0, 1, 3)); // [\'bb\', \'cc\', \'cc\', \'dd\', \'ee\']，表示，从索引1，到索引3（不包含索引3）的值，按顺序从索引0开始复制\n</code></pre>\n<h3>数组遍历</h3>\n<h4>forEach、map、filter</h4>\n<ol>\n<li>\n<p>forEach() 对数组的每个元素执行一次给定的函数。</p>\n<pre><code class=\"language-js\">let arr1 = [1, 2, 3, 4, 5]\narr1.forEach((item, index, array) =&gt; {\n    console.log(`${item}--${index}`);\n});\n// 1--0\n// 2--1\n// 3--2\n// 4--3\n// 5--4\n//参数 array是原数组\n</code></pre>\n</li>\n<li>\n<p>map() 创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3, 4, 5]\nlet newArr = arr.map((item, index, array) =&gt; {\n    return item &gt; 2\n});\nconsole.log(newArr); // [ false, false, true, true, true ]\nconsole.log(arr); // [ 1, 2, 3, 4, 5 ]\n</code></pre>\n</li>\n<li>\n<p>filter() 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3, 4, 5]\nlet newArr = arr.filter((item, index, array) =&gt; {\n    return item &gt; 2\n});\nconsole.log(newArr); // [ 3, 4, 5 ]\nconsole.log(arr); // [ 1, 2, 3, 4, 5 ]\n</code></pre>\n</li>\n</ol>\n<h4>some、every</h4>\n<ol>\n<li>\n<p>some() 测试数组中是不是至少有1个元素通过了被提供的函数测试。返回true或false</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3, 4, 5]\nconsole.log(arr.some(item =&gt; item &gt; 4)); // true\nconsole.log(arr.some(item =&gt; item &gt; 5)); // false\nconsole.log([].some(item =&gt; item &gt; 4)); // false 空数组任何情况都会返回false\n</code></pre>\n</li>\n<li>\n<p>every() 测试一个数组内的所有元素是否都能通过某个指定函数的测试。返回true或false</p>\n<pre><code class=\"language-js\">let arr = [1, 2, 3, 4, 5]\nconsole.log(arr.every(item =&gt; item &gt; 4)); // false\nconsole.log(arr.every(item =&gt; item &gt; 0)); // true\nconsole.log([].every(item =&gt; item &gt; 4)); // true 空数组任何情况都会返回 true\n</code></pre>\n</li>\n</ol>\n<h4>find、findIndex、indexOf、lastIndexOf、includes</h4>\n<ol>\n<li>find() 返回数组中满足提供的测试函数的第一个元素的值，没有的话就返回<code>undefined</code></li>\n<li>findIndex() 返回数组中满足提供的测试函数的第一个元素的索引，没有就返回<code>-1</code></li>\n<li>indexOf() 返回在数组中可以找到一个<strong>给定元素</strong>的第一个索引，没有的话就返回<code>-1</code></li>\n<li>lastIndexOf() 从后往前找，返回第一个找到的索引，没有就返回<code>-1</code></li>\n<li>includes() 判断一个数组是否包含一个指定的值，返回<code>true</code>或<code>false</code></li>\n</ol>\n<pre><code class=\"language-js\">console.log([1, 2, 3, 4].find(item =&gt; item === \'a\')); // undefined 没有就返回undefined\nconsole.log([1, 2, 3, 4].find(item =&gt; item &gt; 1)); // 2 返回第一个匹配的值\n\nconsole.log([1, 2, 3, 4].findIndex(item =&gt; item === \'a\')); // -1 没有就返回 -1\nconsole.log([1, 2, 3, 4].findIndex(item =&gt; item &gt; 1)); // 1 返回第一个匹配值的索引\n\nconsole.log([1, 2, 3, 4].indexOf(5)); // -1 没有就返回 -1\nconsole.log([1, 2, 3, 4].indexOf(4)); // 3 返回第一个匹配值的索引\n\nconsole.log([1, 2, 3, 4].lastIndexOf(5)); // -1 没有就返回 -1\nconsole.log([1, 2, 3, 4].lastIndexOf(4)); // 3 返回第一个匹配值的索引\n\nconsole.log([1, 2, 3, 4].includes(5)); // false\nconsole.log([1, 2, 3, 4].includes(4)); // true\n</code></pre>\n<h4>keys、values、entries</h4>\n<ol>\n<li>\n<p>keys() 返回一个包含数组中每个索引键的<code>Array Iterator</code>对象。</p>\n<pre><code class=\"language-js\">let arr = [\'aa\', , \'cc\']\nconsole.log(arr); // [ \'aa\', &lt;1 empty item&gt;, \'cc\' ]，实际就是[ \'aa\', undefined, \'cc\' ] \n\nlet iterator = arr.keys() // 返回一个迭代器\nfor (const key of iterator) {\n    console.log(key);\n}\n// 0\n// 1\n// 2\n\n/* Object.keys() 与 Array.keys()的 区别 */\nlet keys1 = Object.keys(arr)\nconsole.log(keys1); // [ \'0\', \'2\' ]\nlet keys2 = [...arr.keys()]\nconsole.log(keys2); // [ 0, 1, 2 ]\n/* 索引迭代器会包含那些没有对应元素的索引 */\n</code></pre>\n</li>\n<li>\n<p>values() 返回一个新的 <code>Array Iterator</code> 对象，该对象包含数组每一项的值。</p>\n<pre><code class=\"language-js\">let arr1 = [\'aa\', \'bb\', \'cc\']\nlet iterator = arr1.values()\n\nfor (const value of iterator) {\n    console.log(value);\n}\n// aa\n// bb\n// cc\n</code></pre>\n</li>\n<li>\n<p>entries() 返回一个新的<code>Array Iterator</code>对象，该对象包含数组中每个索引的键/值对。</p>\n<pre><code class=\"language-js\">let arr1 = [\'aa\', \'bb\', \'cc\']\nlet iterator1 = arr1.entries()\n\nconsole.log(iterator1.next()); // { value: [ 0, \'aa\' ], done: false }\nconsole.log(iterator1.next()); // { value: [ 1, \'bb\' ], done: false }\nconsole.log(iterator1.next()); // { value: [ 2, \'cc\' ], done: false }\nconsole.log(iterator1.next()); // { value: undefined, done: true }\n\nlet arr2 = [\'aa\', \'bb\', \'cc\']\nlet iterator2 = arr2.entries()\nfor (const value of iterator2) {\n    console.log(value);\n}\n// [ 0, \'aa\' ]\n// [ 1, \'bb\' ]\n// [ 2, \'cc\' ]\n</code></pre>\n</li>\n</ol>\n<h4>reduce、reduceRight</h4>\n<ol>\n<li>\n<p>reduce() 比较厉害的一个方法，对数组中的每个元素执行一个由您提供的<code>reducer</code>函数(升序执行)，将其结果汇总为单个返回值。</p>\n<pre><code class=\"language-js\">/* 数组求和 start */\nlet arr1 = [5, 6, 7, 8]\nlet result1 = arr1.reduce((prev, next, index) =&gt; {\n    console.log(`${prev} ${next} ${index}`);\n    // 0 5 0\n    // 5 6 1\n    // 11 7 2\n    // 18 8 3\n    return prev + next\n}, 0)\nconsole.log(result1); // 26\n/* 数组求和 end */\n\n\n/* 将二维数组转换为一维数组 start */\nlet arr2 = [[0, 1], [2, 3], [4, 5]]\nlet result2 = arr2.reduce((prev, next, index) =&gt; {\n    console.log(`${prev} ${next} ${index}`);\n    //     0,1      0\n    // 0,1 2,3      1\n    // 0,1,2,3 4,5  2\n    return [...prev, ...next]\n}, [])\nconsole.log(result2); // [ 0, 1, 2, 3, 4, 5 ]\n/* 将二维数组转换为一维数组 end */\n</code></pre>\n</li>\n<li>\n<p>reduceRight() 从右到左执行，与reduce()一样，只不过反着来。</p>\n<pre><code class=\"language-js\">const array1 = [[0, 1], [2, 3], [4, 5]].reduceRight(\n    (accumulator, currentValue) =&gt; accumulator.concat(currentValue)\n);\nconsole.log(array1); // [ 4, 5, 2, 3, 0, 1 ]\n</code></pre>\n</li>\n</ol>\n<h3>功能性方法</h3>\n<h4>concat、slice</h4>\n<ol>\n<li>\n<p>concat() 合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</p>\n<pre><code class=\"language-js\">let arr1 = [\'aa\', \'bb\', \'cc\',]\nlet arr2 = [\'dd\', \'ee\']\nconsole.log(arr1.concat(arr2)); // [ \'aa\', \'bb\', \'cc\', \'dd\', \'ee\' ]\nconsole.log(arr1.concat(arr2, [1, 2])); // [ \'aa\', \'bb\', \'cc\', \'dd\', \'ee\', 1, 2 ]\n</code></pre>\n</li>\n<li>\n<p>slice() 浅拷贝数组中的一段值出来到新数组中，原数组不会改变。</p>\n<pre><code class=\"language-js\">let arr1 = [\'aa\', \'bb\', \'cc\', \'dd\']\nconsole.log(arr1.slice(1)); // [ \'bb\', \'cc\', \'dd\' ]，表示从索引 1开始，一直拷贝到最后\nconsole.log(arr1.slice(1, 2)); // [ \'bb\']，表示从索引 1开始，拷贝到索引2（不包含索引2）\nconsole.log(arr1.slice(-2)); // [ \'cc\', \'dd\' ]，表示从数组的倒数第二个，一直拷贝到数组的最后\nconsole.log(arr1.slice(-2, -1)); // [ \'cc\' ]，表示从数组的倒数第二个，一直拷贝到数组的倒数第一个（不包含倒数第一个）\nconsole.log(arr1.slice(1, -1)); // [ \'bb\', \'cc\' ]，表示从索引1开始，一直拷贝到数组的倒数第一个（不包含倒数第一个）\n</code></pre>\n</li>\n</ol>\n<h4>reverse</h4>\n<p>将数组中元素的位置颠倒，并返回该数组。会改变原数组。</p>\n<pre><code class=\"language-js\">let arr1 = [\'aa\', \'bb\', \'cc\', \'dd\']\nconsole.log(arr1.reverse()); // [ \'dd\', \'cc\', \'bb\', \'aa\' ]\nconsole.log(arr1); // [ \'dd\', \'cc\', \'bb\', \'aa\' ]\n</code></pre>\n<h4>join</h4>\n<p>将一个数组（或一个<code>类数组对象</code>）的所有元素连接成一个字符串并返回这个字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。</p>\n<pre><code class=\"language-js\">let arr1 = [\'aa\', \'bb\', \'cc\', \'dd\']\nconsole.log(arr1.join()); // aa,bb,cc,dd\nconsole.log(arr1.join(\'-\')); // aa-bb-cc-dd\nconsole.log(arr1.join(\'\')); // aabbccdd\nconsole.log(arr1); // [ \'aa\', \'bb\', \'cc\', \'dd\' ]\n</code></pre>\n<h4>flat、flatMap</h4>\n<ol>\n<li>\n<p>flat() 按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。扁平化数组</p>\n<pre><code class=\"language-js\">let arr1 = [1, 2, [3, 4]]\nconsole.log(arr1.flat()); // [ 1, 2, 3, 4 ] 默认是1层\nconsole.log(arr1.flat(1)); // [ 1, 2, 3, 4 ] \nconsole.log(arr1); // [ 1, 2, [ 3, 4 ] ] 不会改变原数组\n\nlet arr2 = [1, 2, [3, 4], [5, [6, 7]]]\nconsole.log(arr2.flat(1)); // [ 1, 2, 3, 4, 5, [ 6, 7 ] ]\nconsole.log(arr2.flat(2)); // [ 1, 2, 3, 4, 5, 6, 7 ]\n</code></pre>\n</li>\n<li>\n<p>flatMap() 与flat(1)基本相同，不过它可以传个函数，类似于执行了一次map操作。</p>\n<pre><code class=\"language-js\">let arr1 = [1, 2, 3, 4]\n\nlet arr2 = arr1.map(x =&gt; [x * 2])\nconsole.log(arr2); // [ [ 2 ], [ 4 ], [ 6 ], [ 8 ] ]\n\nlet arr3 = arr1.flatMap(x =&gt; [x * 2])\nconsole.log(arr3); // [ 2, 4, 6, 8 ]\n\n// flatMap只会flat(1)\nlet arr4 = arr1.flatMap(x =&gt; [[x * 2]])\nconsole.log(arr4); // [ [ 2 ], [ 4 ], [ 6 ], [ 8 ] ]\n</code></pre>\n</li>\n</ol>\n<h2>总结</h2>\n<ol>\n<li>\n<p>数组类的属性和方法</p>\n<p><code>Array.length</code>、<code>Array.of()</code>、<code>Array.from()</code>、<code>Array.isArray()</code></p>\n</li>\n<li>\n<p>数组原型上的方法</p>\n<ol>\n<li>\n<p>元素的添加和删除</p>\n<p><code>push()</code>、<code> pop()</code></p>\n<p><code>unshift()</code> 、<code>shift()</code></p>\n<p><code>splice()</code> 、<code>fill()</code></p>\n<p><code>copyWithin()</code></p>\n</li>\n<li>\n<p>数组遍历</p>\n<p><code>forEach()</code> 、<code>map()</code> 、<code>filter() </code></p>\n<p><code>some()</code> 、<code>every()</code></p>\n<p><code>find()</code>、 <code>findIndex()</code>、 <code>indexOf()</code>、 <code>lastIndexOf()</code>、 <code>includes()</code></p>\n<p><code>keys()</code>、 <code>values()</code>、 <code>entries()</code></p>\n<p><code>reduce()</code>、 <code>reduceRight()</code></p>\n</li>\n<li>\n<p>功能性方法</p>\n<p><code>concat()</code>、 <code>slice()</code></p>\n<p><code>reverse()</code></p>\n<p><code>join()</code></p>\n<p><code>flat()</code> 、<code>flatMap()</code></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></p>\n', '2021-11-20 16:25:31', '2021-11-20 16:25:31');
INSERT INTO `t_blog` VALUES ('6e23f3c0-5e4f-11ec-b395-6d1b1a7579ec', '时间和空间复杂度', '评估一个算法的好坏可以通过它的时间复杂度和空间复杂度来分析出来。', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 2, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>评估一个算法的好坏可以通过它的时间复杂度和空间复杂度来分析出来。</p>\n<ol>\n<li>时间复杂度：表示算法执行的耗时。</li>\n<li>空间复杂度：表示算法执行过程中临时的存储空间占用的内存大小。</li>\n</ol>\n<p>它们都可以用大O表示法来表示：</p>\n<p>时间复杂度一般有：<code>O(1)、O(logN)、O(n)、O(nlogN)、O(n^2)、O(n^3)、O(2^n)</code></p>\n<p>空间复杂度一般有：<code>O(1)、O(n)、O(n^2)</code></p>\n<blockquote>\n<p>时间复杂度的通用公式为<code>T(n) = O(f(n))</code>，</p>\n<ol>\n<li>T(n)表示代码的执行时间。</li>\n<li>n表示数据规模的大小。</li>\n<li>f(n)表示每行代码执行的次数总和，因为是一个公式，所以用f(n)表示。</li>\n<li>公式中的O，表示代码的执行时间T(n)与f(n)表达式成正比。</li>\n</ol>\n</blockquote>\n<h3>效率图比较</h3>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112161538084.png\" alt=\"image-20211216153857980\" /></p>\n<p>图像来自：<a href=\"https://zh.numberempire.com/graphingcalculator.php?functions=1%2Clog(n)%2Cn%2Cn*log(n)%2Cn%5E2%2Cn%5E3%2C2%5En&amp;xmin=0&amp;xmax=1000&amp;ymin=0&amp;ymax=10000&amp;var=n\">函数图像绘制</a></p>\n<h2>时间复杂度</h2>\n<h3>O(1)：常数阶</h3>\n<pre><code class=\"language-js\">function fn1(grade) {\n    // 只会执行一次\n    if (grade &gt; 90) {\n        console.log(\'优秀\');\n    } else if (grade &gt; 80) {\n        console.log(\'良好\');\n    } else if (grade &gt; 60) {\n        console.log(\'及格\');\n    } else {\n        console.log(\'不及格\');\n    }\n}\n/* \n    无论怎样，只会执行一次\n    所以时间复杂度为 O(1)\n*/\n</code></pre>\n<h3>O(logN)：对数阶</h3>\n<pre><code class=\"language-js\">function fn(n) {\n    let i = 1\n    while (i &lt; n) {\n        i = i * 2\n    }\n}\n/* \n分析：假设执行了 x 次，i就大于n跳出了循环\n也就是说 2^x = n\n所以 x = log2(n)\n\n所以用大O表示法，O(logN)\n*/\n</code></pre>\n<h3>O(n)：线性阶</h3>\n<pre><code class=\"language-js\">function fn2(n) {\n    let sum = 0 // 执行一次 1\n    /* \n        for循环中的 \n        let i = 1，执行一次 1\n        i&lt;=n 执行n次 n\n        i++ 执行n次 n\n        sum = sum +i 执行n次 n\n    */\n    for (let i = 1; i &lt;= n; i++) {\n        sum = sum + i\n    }\n    return sum // 执行一次  1\n}\n/* \n    所以上面的程序最终执行次数为\n    1+1+3n+1 = 3+3n\n    所以使用大O表示法为 O(n)\n*/\n</code></pre>\n<h3>O(nlogN)：线性对数阶</h3>\n<pre><code class=\"language-js\">function fn(n) {\n    // i+=i相当于 i=i+i=2i 每次都乘以2，看乘了多少次2会大于n，所以执行了 log2(n)次后就大于n\n    // 所以外城循环执行了 1+2log2(n)次，内层循环执行了log2(n)*(1+3n)次\n    // 最终共执行了，1+2log2(n) + log2(n)*(1+3n) = 1+3log2(n)+3nlog2(n)\n    for (let i = 1; i &lt; n; i += i) {\n        for (let j = 0; j &lt; n; j++) {\n            console.log(\'aaa\');\n        }\n    }\n}\n/* \n    所以上面的使用大O表示，为O(nlog(N))\n*/\n</code></pre>\n<h3>O(n^2)：平方阶</h3>\n<pre><code class=\"language-js\">function fn(n) {\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            console.log(\'aaa\');\n        }\n    }\n}\n/* \n    外层循环 1+2n\n    内层循环 n*(1+3n)\n    所以最终执行 1+2n+n*(1+3n) = 1+3n+3n^2\n    使用大O表示法，最终为 O(n^2)\n*/\n</code></pre>\n<h3>O(n^3)：立方阶</h3>\n<pre><code class=\"language-js\">function fn(n) {\n    for (let i = 0; i &lt; n; i++) {\n        for (let j = 0; j &lt; n; j++) {\n            for (let m = 0; m &lt; n; m++) {\n                console.log(\'aaa\');\n            }\n        }\n    }\n}\n/* \n    外层循环 1+2n\n    第二层循环 n*(1+2n)\n    第三层循环 n^2(1+3n)\n    所以最终执行 加起来，只看最内层执行的次数 就是三次幂了\n    使用大O表示法，最终为 O(n^3)\n*/\n</code></pre>\n<h3>O(2^n)：指数阶</h3>\n<pre><code class=\"language-js\">/* \n菲波那切数列的递归解法\nf(0) = 0\nf(1) = 1\nf(n) = f(n-1) + f(n-2)\n\n下标 0 1 2 3 4 5 6  7  8  9 \n值   0 1 1 2 3 5 8 13 21  34\n*/\n\nfunction fn(n) {\n    // 出口\n    if (n &lt;= 1) return n\n    return fn(n - 1) + fn(n - 2)\n}\n\nconsole.log(fn(3)); // 2\nconsole.log(fn(4)); // 3\nconsole.log(fn(9)); // 34\n</code></pre>\n<p>时间复杂度为 O(2^n)</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112161603096.png\" alt=\"image-20211216160308014\" /></p>\n<h2>空间复杂度</h2>\n<ol>\n<li>\n<p>空间复杂度 O(1)</p>\n<p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)</p>\n<pre><code class=\"language-js\">let i = 1;\nlet j = 2;\n++i;\nj++;\nlet m = i + j;\n</code></pre>\n<p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p>\n</li>\n<li>\n<p>空间复杂度 O(n)</p>\n<pre><code class=\"language-js\">let arr = []\nfor(let i = 0; i&lt;n; i++){\n    arr.push(i)\n}\n</code></pre>\n<p>数组刚开始初始化时，长度为零，当随着循环的执行，数组的长度变为了n，申请的临时空间也变为了n，所以空间复杂度就为O(n)</p>\n</li>\n</ol>\n<p>所以，如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为 O(1)；反之，如果有关，则需要进一步判断它们之间的关系：</p>\n<ul>\n<li>如果随着输入值 n 的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 O(n) 表示;</li>\n<li>如果随着输入值 n 的增大，程序申请的临时空间成 n2 关系增长，则程序的空间复杂度用 O(n2) 表示；</li>\n<li>如果随着输入值 n 的增大，程序申请的临时空间成 n3 关系增长，则程序的空间复杂度用 O(n3) 表示；</li>\n<li>等等。</li>\n</ul>\n<blockquote>\n<p>在多数场景中，一个好的算法往往更注重的是时间复杂度的比较，而空间复杂度只要在一个合理的范围内就可以。</p>\n</blockquote>\n<h2>例子1 菲波那切数列</h2>\n<ol>\n<li>\n<p>for循环的解法</p>\n<pre><code class=\"language-js\">/* \n菲波那切数列\nf(0) = 0\nf(1) = 1\nf(n) = f(n-1) + f(n-2)\n\n下标 0 1 2 3 4 5 6  7  8  9 \n值   0 1 1 2 3 5 8 13 21  34\n*/\n\nfunction fn(n) {\n    if (n &lt;= 1) return n\n\n    let first = 0\n    let second = 1\n\n    // 如果求下标2 需要加1次 0+1=1\n    // 如果求下标3 需要加2次 0+1=1 1+1=2\n    // 所以如果求下标n 需要加 n-1次\n    for (let i = 0; i &lt; n - 1; i++) {\n        let sum = first + second\n        first = second\n        second = sum\n    }\n\n    return second\n}\n\nconsole.log(fn(3)); // 2\nconsole.log(fn(4)); // 3\nconsole.log(fn(9)); // 34\n</code></pre>\n<p>它的时间复杂度为O(n)。空间复杂度也为O(n)。</p>\n</li>\n<li>\n<p>递归的解法</p>\n<pre><code class=\"language-js\">/* \n菲波那切数列\nf(0) = 0\nf(1) = 1\nf(n) = f(n-1) + f(n-2)\n\n下标 0 1 2 3 4 5 6  7  8  9 \n值   0 1 1 2 3 5 8 13 21  34\n*/\n\nfunction fn(n) {\n    // 出口\n    if (n &lt;= 1) return n\n    return fn(n - 1) + fn(n - 2)\n}\n\nconsole.log(fn(3)); // 2\nconsole.log(fn(4)); // 3\nconsole.log(fn(9)); // 34\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112161603096.png\" alt=\"image-20211216160308014\" /></p>\n<p>图片来自：<a href=\"https://www.bilibili.com/video/BV1sX4y1G7oM?p=9&amp;spm_id_from=pageDriver\">https://www.bilibili.com/video/BV1sX4y1G7oM?p=9&amp;spm_id_from=pageDriver</a></p>\n<p>所以最终的时间复杂度为：O(2^n)，空间复杂度为O(1)</p>\n</li>\n</ol>\n<h2>例子2 推导时间复杂度</h2>\n<p>设某算法时间表示为递推关系<code>T(n) = T(n-1) +n</code>，<code>n</code>为整数，及<code>T(0)=1</code>，计算该算法的时间复杂度。</p>\n<pre><code class=\"language-js\">T(n) = T(n-1) +n\n	= T(n-2) + (n-1) +n\n	= T(n-3) + (n-2) + (n-1) + n\n	...\n    = T(1) + 2 + 3 + ... + (n-2) + (n-1) + n\n	=  T(0) + 1 + 2 + 3 + ... + (n-2) + (n-1) + n\n	= 1 + 1 + 2 + 3 + ... + (n-2) + (n-1) + n\n	= 1 + (1 + n)*n / 2\n	= O(n^2)\n</code></pre>\n<h2>总结</h2>\n<p>时间复杂度的大小：</p>\n<p><code>O(1)常数阶 &lt; O(logn)对数阶 &lt; O(n)线性阶 &lt; O(nlog(n))&lt; O(n^2)平方阶 &lt; O(n^3)(立方阶) &lt; O(2^n) (指数阶)</code></p>\n<blockquote>\n<p>注意，这里仅介绍了以最坏情况下的频度作为时间复杂度，而在某些实际场景中，还可以用最好情况下的频度和最坏情况下的频度的平均值来作为算法的平均时间复杂度。</p>\n</blockquote>\n<h2>参考</h2>\n<p><a href=\"https://www.bilibili.com/video/BV1sX4y1G7oM?p=9&amp;spm_id_from=pageDriver\">https://www.bilibili.com/video/BV1sX4y1G7oM?p=9&amp;spm_id_from=pageDriver</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/50479555\">https://zhuanlan.zhihu.com/p/50479555</a></p>\n<p><a href=\"http://c.biancheng.net/view/8081.html\">http://c.biancheng.net/view/8081.html</a></p>\n', '2021-12-16 17:06:18', '2021-12-16 17:06:18');
INSERT INTO `t_blog` VALUES ('6ee9a830-5711-11ec-96d5-7933aca11ca0', '捕获组', '模式的一部分可以用括号括起来 `(...)`。这称为“捕获组（capturing group）”。\n\n这有两个影响：\n\n1. 它允许将匹配的一部分作为结果数组中的单独项。\n2. 如果我们将量词放在括号后，则它将括号视为一个整体。', '-1', 2, 'https://zh.javascript.info/regexp-groups', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 8, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>模式的一部分可以用括号括起来 <code>(...)</code>。这称为“捕获组（capturing group）”。</p>\n<p>这有两个影响：</p>\n<ol>\n<li>它允许将匹配的一部分作为结果数组中的单独项。</li>\n<li>如果我们将量词放在括号后，则它将括号视为一个整体。</li>\n</ol>\n<h3>一些小例子</h3>\n<h4>示例1：匹配括号内重复的字符gogogo</h4>\n<p>不带括号，模式 <code>go+</code> 表示 <code>g</code> 字符，其后 <code>o</code> 重复一次或多次。例如 <code>goooo</code> 或 <code>gooooooooo</code>。</p>\n<p>括号将字符组合，所以 <code>(go)+</code> 匹配 <code>go</code>，<code>gogo</code>，<code>gogogo</code>等。</p>\n<pre><code class=\"language-js\">console.log(\'Gogogo now!\'.match(/go+/i)); // [ \'Go\', index: 0, input: \'Gogogo now!\', groups: undefined ]\nconsole.log(\'Gogogo now!\'.match(/(go)+/i)); // [ \'Gogogo\', \'go\', index: 0, input: \'Gogogo now!\', groups: undefined ]\n</code></pre>\n<h4>示例2：匹配域名</h4>\n<p>让我们做些更复杂的事 —— 搜索域名的正则表达式。</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">mail.com\nusers.mail.com\nsmith.users.mail.com\n</code></pre>\n<p>正如我们所看到的，一个域名由重复的单词组成，每个单词后面有一个点，除了最后一个单词。</p>\n<p>在正则表达式中是 <code>(\\w+\\.)+\\w+</code>：</p>\n<pre><code class=\"language-js\">let regexp = /(\\w+\\.)+\\w+/g;\n\nconsole.log(&quot;site.com my.site.com&quot;.match(regexp)); // [ \'site.com\', \'my.site.com\' ]\n</code></pre>\n<p>搜索有效，但是该模式无法匹配带有连字符的域名，例如 my-site.com，因为连字符不属于 <code>\\w</code> 类。</p>\n<p>我们可以通过用 <code>[\\w-]</code> 替换 <code>\\w</code> 来匹配除最后一个的每个单词：<code>([\\w-]+\\.)+\\w+</code>。</p>\n<h4>示例3：email</h4>\n<p>前面的示例可以扩展。我们可以基于它为电子邮件创建一个正则表达式。</p>\n<p>email 格式为：<code>name@domain</code>。名称可以是任何单词，可以使用连字符和点。在正则表达式中为 <code>[-.\\w]+</code>。</p>\n<p>模式：</p>\n<pre><code class=\"language-js\">let regexp = /[-.\\w]+@([\\w-]+\\.)+[\\w-]+/g;\n\nconsole.log(&quot;my@mail.com @ his@site.com.uk&quot;.match(regexp)); // [ \'my@mail.com\', \'his@site.com.uk\' ]\n</code></pre>\n<p>该正则表达式并不完美的，但多数情况下都可以工作，并且有助于修复意外的错误类型。唯一真正可靠的 email 检查只能通过发送 email 来完成。</p>\n<h2>匹配括号中的内容</h2>\n<p>括号从左到右编号。正则引擎会记住它们各自匹配的内容，并允许在结果中获得它。</p>\n<p>方法 <code>str.match(regexp)</code>，如果 <code>regexp</code> 没有 <code>g</code> 标志，将查找第一个匹配并将它作为一个数组返回：</p>\n<ol>\n<li>在索引 <code>0</code> 处：完全匹配。</li>\n<li>在索引 <code>1</code> 处：第一个括号的内容。</li>\n<li>在索引 <code>2</code> 处：第二个括号的内容。</li>\n<li>…等等…</li>\n</ol>\n<p>例如，我们想找到 HTML 标记 <code>&lt;.*?&gt;</code> 并进行处理。这将很方便的把标签内容（尖括号内的内容）放在单独的变量中。</p>\n<p>让我们将内部内容包装在括号中，像这样：<code>&lt;(.*?)&gt;</code>。</p>\n<p>现在，我们能在结果数组中获取标签的整体 <code>&lt;h1&gt;</code> 及其内容 <code>h1</code>：</p>\n<pre><code class=\"language-js\">let str = \'&lt;h1&gt;Hello, world!&lt;/h1&gt;\';\n\nlet tag = str.match(/&lt;(.*?)&gt;/);\n\nconsole.log(tag);\n/* \n[\n  \'&lt;h1&gt;\',\n  \'h1\',\n  index: 0,\n  input: \'&lt;h1&gt;Hello, world!&lt;/h1&gt;\',\n  groups: undefined\n]\n*/\n\nconsole.log(tag[0]); // &lt;h1&gt;\nconsole.log(tag[1]); // h1\n</code></pre>\n<h2>嵌套组</h2>\n<p>括号可以嵌套。在这种情况下，编号也从左到右。</p>\n<p>例如，在搜索标签 <code>&lt;span class=&quot;my&quot;&gt;</code> 时我们可能会对以下内容感兴趣：</p>\n<ol>\n<li>整个标签内容：<code>span class=&quot;my&quot;</code>。</li>\n<li>标签名称：<code>span</code>。</li>\n<li>标签属性：<code>class=&quot;my&quot;</code>。</li>\n</ol>\n<p>让我们为它们添加括号：<code>&lt;(([a-z]+)\\s*([^&gt;]*))&gt;</code>。</p>\n<p>这是它们的编号方式（从左到右，由左括号开始）：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112070951548.png\" alt=\"image-20211207095104444\" /></p>\n<p>比如：</p>\n<pre><code class=\"language-js\">let str = \'&lt;span class=&quot;my&quot;&gt;\';\n\nlet regexp = /&lt;(([a-z]+)\\s*([^&gt;]*))&gt;/;\n\nlet result = str.match(regexp);\nconsole.log(result[0]); // &lt;span class=&quot;my&quot;&gt;\nconsole.log(result[1]); // span class=&quot;my&quot;\nconsole.log(result[2]); // span\nconsole.log(result[3]); // class=&quot;my&quot;\n</code></pre>\n<p><code>result</code> 的零索引始终保持完全匹配。</p>\n<p>然后按左括号将组从左到右编号。第一组返回为 <code>result[1]</code>。它包含了整个标签内容。</p>\n<p>然后 <code>result[2]</code> 从第二个开始的括号中进入该组 <code>([a-z]+)</code> —— 标签名称，然后在 <code>result[3]</code> 标签中：<code>([^&gt;]*)</code>。</p>\n<p>字符串中每个组的内容：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112071002802.png\" alt=\"image-20211207100237754\" /></p>\n<h2>可选组</h2>\n<p>即使组是可选的并且在匹配项中不存在（例如，具有数量词 <code>(...)?</code>），也存在相应的 <code>result</code> 数组项，并且等于 <code>undefined</code>。</p>\n<p>例如，让我们考虑正则 <code>a(z)?(c)?</code>。它寻找 <code>&quot;a&quot;</code> ，然后是可选的 <code>&quot;z&quot;</code>，然后是可选的 <code>&quot;c&quot;</code>。</p>\n<p>如果我们在单个字母的字符串上运行 <code>a</code>，则结果为：</p>\n<pre><code class=\"language-js\">let match = \'a\'.match(/a(z)?(c)?/);\n\nconsole.log(match.length); // 3\n// 即使可选组没有匹配到，match的结果中也会有，会有个undefined\nconsole.log(match);\n/* \n[ \'a\', undefined, undefined, index: 0, input: \'a\', groups: undefined ]\n*/\nconsole.log(match[0]); // a（完全匹配）\nconsole.log(match[1]); // undefined\nconsole.log(match[2]); // undefined\n</code></pre>\n<p>数组的长度为 <code>3</code>，但所有组均为空。</p>\n<p>这是字符串的一个更复杂的匹配 <code>ac</code>：</p>\n<pre><code class=\"language-js\">let match = \'ac\'.match(/a(z)?(c)?/)\n\nconsole.log(match.length); // 3\nconsole.log(match);\n/* \n[ \'ac\', undefined, \'c\', index: 0, input: \'ac\', groups: undefined ]\n*/\nconsole.log(match[0]); // ac（完全匹配）\nconsole.log(match[1]); // undefined，因为 (z)? 没匹配项\nconsole.log(match[2]); // c\n</code></pre>\n<p>数组长度是恒定的：<code>3</code>。但是对于组 <code>(z)?</code> 而言，什么都没有，所以结果是 <code>[&quot;ac&quot;, undefined, &quot;c&quot;]</code>。</p>\n<h2>搜索所有具有组的匹配项：matchAll</h2>\n<blockquote>\n<p><strong><code>matchAll</code> 是一个新方法，可能需要使用 polyfill</strong></p>\n<p>旧的浏览器不支持 <code>matchAll</code>。</p>\n<p>可能需要一个 polyfill，例如 https://github.com/ljharb/String.prototype.matchAll.</p>\n</blockquote>\n<p>当我们搜索所有匹配项（标志 <code>g</code>）时，<code>match</code> 方法不会返回组的内容。</p>\n<p>例如，让我们查找字符串中的所有标签：</p>\n<pre><code class=\"language-js\">let str = \'&lt;h1&gt; &lt;h2&gt;\';\n\nlet tags = str.match(/&lt;(.*?)&gt;/g);\n\nconsole.log(tags); // [ \'&lt;h1&gt;\', \'&lt;h2&gt;\' ]\n</code></pre>\n<p>结果是一个匹配数组，但没有每个匹配项的详细信息。但是实际上，我们通常需要在结果中获取捕获组的内容。</p>\n<p>要获取它们，我们应该使用方法 <code>str.matchAll(regexp)</code> 进行搜索。</p>\n<p>在使用 <code>match</code> 很长一段时间后，它作为“新的改进版本”被加入到 JavaScript 中。</p>\n<p>就像 <code>match</code> 一样，它寻找匹配项，但有 3 个区别：</p>\n<ol>\n<li>它返回的不是数组，而是一个可迭代的对象。</li>\n<li>当标志 <code>g</code> 存在时，它将每个匹配组作为一个数组返回。</li>\n<li>如果没有匹配项，则不返回 <code>null</code>，而是返回一个空的可迭代对象。</li>\n</ol>\n<p>例如：</p>\n<pre><code class=\"language-js\">let results = \'&lt;h1&gt; &lt;h2&gt;\'.matchAll(/&lt;(.*?)&gt;/gi);\n\n// results - is not an array, but an iterable object\nconsole.log(results); // [object RegExp String Iterator]\n\nconsole.log(results[0]); // undefined (*)\n\nresults = Array.from(results); // let\'s turn it into array\n\n// matchAll 把每一项的匹配组，赛到了一个数组中返回了出来\nconsole.log(results[0]); // [ \'&lt;h1&gt;\', \'h1\', index: 0, input: \'&lt;h1&gt; &lt;h2&gt;\', groups: undefined ]\nconsole.log(results[1]); // [ \'&lt;h2&gt;\', \'h2\', index: 5, input: \'&lt;h1&gt; &lt;h2&gt;\', groups: undefined ]\n</code></pre>\n<p>我们可以看到，第一个区别非常重要，如 <code>(*)</code> 行所示。我们无法获得 <code>results[0]</code> 的匹配内容，因为该对象是可迭代对象，并不是一个数组。我们可以使用 <code>Array.from</code> 把它变成一个真正的 <code>Array</code>。在<a href=\"http://www.bnbiye.cn/#/articleDetail/7af13780-4b48-11ec-96d5-7933aca11ca0\">可迭代与类数组</a>一文中有关于类数组和可迭代对象的更多详细信息。</p>\n<p>如果我们不需要遍历结果，则 <code>Array.from</code> 没有必要：</p>\n<pre><code class=\"language-js\">let results = \'&lt;h1&gt; &lt;h2&gt;\'.matchAll(/&lt;(.*?)&gt;/gi);\n\nfor (let result of results) {\n    console.log(result);\n    // 第一个结果: [ \'&lt;h1&gt;\', \'h1\', index: 0, input: \'&lt;h1&gt; &lt;h2&gt;\', groups: undefined ]\n    // 第二个结果: [ \'&lt;h2&gt;\', \'h2\', index: 5, input: \'&lt;h1&gt; &lt;h2&gt;\', groups: undefined ]\n}\n</code></pre>\n<p>……或使用解构：</p>\n<pre><code class=\"language-js\">let [tag1, tag2] = \'&lt;h1&gt; &lt;h2&gt;\'.matchAll(/&lt;(.*?)&gt;/gi);\nconsole.log(tag1); // [ \'&lt;h1&gt;\', \'h1\', index: 0, input: \'&lt;h1&gt; &lt;h2&gt;\', groups: undefined ]\nconsole.log(tag2); // [ \'&lt;h2&gt;\', \'h2\', index: 5, input: \'&lt;h1&gt; &lt;h2&gt;\', groups: undefined ]\n</code></pre>\n<p>由 <code>matchAll</code> 所返回的每个匹配，其格式与不带标志 <code>g</code> 的 <code>match</code> 所返回的格式相同：它是一个具有额外的 <code>index</code>（字符串中的匹配索引）属性和 <code>input</code>（源字符串）的数组：</p>\n<pre><code class=\"language-js\">let results = \'&lt;h1&gt; &lt;h2&gt;\'.matchAll(/&lt;(.*?)&gt;/gi);\n\nlet [tag1, tag2] = results;\nconsole.log(tag1); // [ \'&lt;h1&gt;\', \'h1\', index: 0, input: \'&lt;h1&gt; &lt;h2&gt;\', groups: undefined ]\nconsole.log(tag2); // [ \'&lt;h2&gt;\', \'h2\', index: 5, input: \'&lt;h1&gt; &lt;h2&gt;\', groups: undefined ]\n\nconsole.log( tag1[0] ); // &lt;h1&gt;\nconsole.log( tag1[1] ); // h1\nconsole.log( tag1.index ); // 0\nconsole.log( tag1.input ); // &lt;h1&gt; &lt;h2&gt;\n</code></pre>\n<blockquote>\n<p><strong>为什么 <code>matchAll</code> 的结果是可迭代对象而不是数组？</strong></p>\n<p>为什么这个方法这样设计？原因很简单 — 为了优化。</p>\n<p>调用 <code>matchAll</code> 不会执行搜索。相反，它返回一个可迭代的对象，最初没有结果。每当我们对它进行迭代时才会执行搜索，例如在循环中。</p>\n<p>因此，这将根据需要找到尽可能多的结果，而不是全部。</p>\n<p>例如，文本中可能有 100 个匹配项，但是在一个 <code>for..of</code> 循环中，我们已经找到了 5 个匹配项，然后觉得足够了并做出一个 <code>break</code>。这时引擎就不会花时间查找其他 95 个匹配。</p>\n</blockquote>\n<p>注意：matchAll在匹配正则时，正则必须带有g标志，否则会报错</p>\n<pre><code class=\"language-js\">let result = \'&lt;h1&gt; &lt;h2&gt;\'.matchAll(/&lt;(.*?)&gt;/i);\n// TypeError: String.prototype.matchAll called with a non-global RegExp argument\n</code></pre>\n<h2>命名组</h2>\n<p>用数字记录组很困难。对于简单模式，它是可行的，但对于更复杂的模式，计算括号很不方便。我们有一个更好的选择：给括号起个名字。</p>\n<p>这是通过在开始括号之后立即放置 <code>?&lt;name&gt;</code> 来完成的。</p>\n<p>例如，让我们查找 “year-month-day” 格式的日期：</p>\n<pre><code class=\"language-js\">let dateRegexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/;\nlet str = &quot;2019-04-30&quot;;\n\nconsole.log(str.match(dateRegexp));\n/* \n[\n  \'2019-04-30\',\n  \'2019\',\n  \'04\',\n  \'30\',\n  index: 0,\n  input: \'2019-04-30\',\n  groups: [Object: null prototype] { year: \'2019\', month: \'04\', day: \'30\' }\n]\n*/\n\nlet groups = str.match(dateRegexp).groups;\nconsole.log(groups); // [Object: null prototype] { year: \'2019\', month: \'04\', day: \'30\' }\nconsole.log(groups.year); // 2019\nconsole.log(groups.month); // 04\nconsole.log(groups.day); // 30\n</code></pre>\n<p>如您所见，匹配的组在 <code>.groups</code> 属性中。</p>\n<p>要查找所有日期，我们可以添加标志 <code>g</code>。</p>\n<p>我们还需要 <code>matchAll</code> 获取完整的组匹配：</p>\n<pre><code class=\"language-js\">let dateRegexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/g;\n\nlet str = &quot;2019-10-30 2020-01-01&quot;;\n\nlet results = str.matchAll(dateRegexp);\n\nconsole.log(results); // Object [RegExp String Iterator] {}\n\nfor (let result of results) {\n    let { year, month, day } = result.groups;\n\n    console.log(`${day}.${month}.${year}`);\n    // 第一个 30.10.2019\n    // 第二个：01.01.2020\n}\n</code></pre>\n<h2>替换捕获组</h2>\n<p>方法 <code>str.replace(regexp, replacement)</code> 用 <code>replacement</code> 替换 <code>str</code> 中匹配 <code>regexp</code> 的所有捕获组。这使用 <code>$n</code> 来完成，其中 <code>n</code> 是组号。</p>\n<p>例如，</p>\n<pre><code class=\"language-js\">let str = &quot;John Bull&quot;;\nlet regexp = /(\\w+) (\\w+)/;\n\nconsole.log(str.replace(regexp, \'$2, $1\')); // Bull, John\n</code></pre>\n<p>对于命名括号，引用为 <code>$&lt;name&gt;</code>。</p>\n<p>例如，让我们将日期格式从 “year-month-day” 更改为 “day.month.year”：</p>\n<pre><code class=\"language-js\">let regexp = /(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/g;\n\nlet str = &quot;2019-10-30, 2020-01-01&quot;;\n\nconsole.log(str.replace(regexp, \'$&lt;day&gt;.$&lt;month&gt;.$&lt;year&gt;\'));\n// 30.10.2019, 01.01.2020\n</code></pre>\n<blockquote>\n<p>本章主要是为了讲解正则表达式中捕获组的概念，对于涉及到的几个字符串方法，match、matchAll，replace，讲解的并不是很细致，会另写一篇文章介绍这几个方法，<a href=\"http://www.bnbiye.cn/#/articleDetail/02832040-583d-11ec-96d5-7933aca11ca0\">正则表达式（RegExp）和字符串（String）的方法</a></p>\n</blockquote>\n<h2>非捕获组<code>?:</code></h2>\n<p>有时我们需要括号才能正确应用量词，但我们不希望它们的内容出现在结果中。</p>\n<p>可以通过在开头添加 <code>?:</code> 来排除组。</p>\n<p>例如，如果我们要查找 <code>(go)+</code>，但不希望括号内容（<code>go</code>）作为一个单独的数组项，则可以编写：<code>(?:go)+</code>。</p>\n<p>在下面的示例中，我们仅将名称 <code>John</code> 作为匹配项的单独成员：</p>\n<pre><code class=\"language-js\">let str = &quot;Gogogo John!&quot;;\n\n// ?: 从捕获组中排除 \'go\'\nlet regexp = /(?:go)+ (\\w+)/i;\n\nlet result = str.match(regexp);\nconsole.log(result);\n/* \n// 结果中只有 捕获组 (\\w+) 的结果 John  (?:go) 被排除掉了\n[\n  \'Gogogo John\',\n  \'John\',\n  index: 0,\n  input: \'Gogogo John!\',\n  groups: undefined\n]\n*/\n\nconsole.log(result[0]); // Gogogo John（完全匹配）\nconsole.log(result[1]); // John\nconsole.log(result.length); // 2（数组中没有更多项）\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>\n<p>正则表达式中的括号<code>()</code>有两个作用：</p>\n<ol>\n<li>如果括号后面紧跟一个量词，比如<code>(xyz)+</code>，则括号里的内容会视作为一个整体。</li>\n<li>括号里的内容其实就是一个<strong>捕获组</strong>，当在进行正则匹配时，捕获组中匹配到的结果会作为返回数组的单独一项，也就是说，我们可以获取到括号中（每一个捕获组中）匹配到的结果。</li>\n</ol>\n</li>\n<li>\n<p>使用<code>match</code>方法匹配正则时</p>\n<ol>\n<li>\n<p>表达式不带<code>g</code>标志</p>\n<ol>\n<li>会返回一个数组</li>\n<li>数组的第一项是正则表达式全匹配的结果</li>\n<li>数组的第二项是捕获组1的结果</li>\n<li>第三项是捕获组2的结果（假如有的话）</li>\n<li>...</li>\n<li>然后是匹配到全匹配结果第一个字符的索引</li>\n<li>然后是输入的字符串</li>\n<li>最后是所有命名捕获组匹配到的结果（就相当于给捕获组起的别名，把对应别名的匹配结果在此处存储一遍，方便获取值）</li>\n</ol>\n</li>\n<li>\n<p>带<code>g</code>标志</p>\n<ol>\n<li>\n<p>会返回一个数组</p>\n</li>\n<li>\n<p>数组中是每一项全匹配的结果（捕获组中的信息就没有了，只有匹配结果）</p>\n<p>所以，为了补充这个不足，就出现了<code>matchAll</code>方法</p>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n<li>\n<p>使用<code>matchAll</code>方法匹配</p>\n<ol>\n<li>返回的是一个可迭代对象</li>\n<li>使用<code>for of</code>输出时，每一项是带有捕获组格式的数组，与不带<code>g</code>标志的<code>match</code>方法返回的结果一致。</li>\n<li><code>matchAll</code>方法匹配正则时必须得带有<code>g</code>标识，否则会报错</li>\n</ol>\n</li>\n<li>\n<p>嵌套组：捕获组是可以嵌套的，比如：<code>((xxx)_(yyy))</code>，嵌套的捕获组在标记组号时，会按照括号的先后进行标记，由外向里一个一个的标记，最外层就是捕获组1，然后里面的是捕获组2、然后捕获组3等等。</p>\n</li>\n<li>\n<p>可选组：在捕获组后面加个<code>?</code>，比如<code>(xxx)?</code>，那这个捕获组就变为了可选的，可有可没有（这其实就是量词<code>?</code>的特性，<code>?</code>表示<code>{0, 1}</code>，可有可没有），不过在使用<code>match</code>匹配时，对应的捕获组如果没有会赛进返回数组对应位置处一个<code>undefined</code></p>\n</li>\n<li>\n<p>命名组：当对复杂的正则使用捕获组时，自己人为的去查捕获组的编号是很复杂的（虽然有规律，由外向里，由左向右，但是特别多的时候也很复杂，眼容易瞅花），这时候就可以对捕获组进行命名，命名方式就是在左括号<code>(</code>后面紧跟一个名称<code>?&lt;name&gt;</code>，比如<code>(?&lt;xxx&gt;)</code>。</p>\n<p>命名捕获组的匹配结果可以在<code>match</code>方法返回的<code>groups</code>中获取到，返回结果格式为：</p>\n<pre><code class=\"language-js\">[\n  \'2019-04-30\',\n  \'2019\',\n  \'04\',\n  \'30\',\n  index: 0,\n  input: \'2019-04-30\',\n  groups: [Object: null prototype] { year: \'2019\', month: \'04\', day: \'30\' }\n]\n</code></pre>\n</li>\n<li>\n<p>非捕获组：如果不想让括号中的匹配结果出现在<code>match</code>方法返回的数组项中，假如这个括号只是为了量词使用，我们可以将它定义为一个非捕获组，定义方式为，在左括号<code>(</code>后面紧跟一个<code>?:</code>，比如<code>(?:xxx)</code>，这样这个括号里面的正则匹配到的内容就不会出现在<code>match</code>的匹配结果中（这样也是非常方便的，万一有一个捕获组匹配到了特别多的内容，我们还不想要它，耽误我们看别的捕获组的内容时，就可以把这个干扰项排除掉）。</p>\n</li>\n<li>\n<p>替换捕获组：有一个强大的替换方法，<code>replace</code>，结合正则的捕获组可用各种方法去替换字符串，非常灵活，方法的详解放到单独一篇文章讲解，<a href=\"http://www.bnbiye.cn/#/articleDetail/02832040-583d-11ec-96d5-7933aca11ca0\">正则表达式（RegExp）和字符串（String）的方法</a>。</p>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-groups\">https://zh.javascript.info/regexp-groups</a></p>\n', '2021-12-07 11:54:52', '2021-12-09 10:40:05');
INSERT INTO `t_blog` VALUES ('6f8f8d30-3d8b-11ec-97a5-ef78eceb5d73', '分析关键渲染路径性能', '优化关键渲染路径能够让浏览器尽可能快地绘制网页: 更快的网页渲染速度可以提高吸引力、增加网页浏览量以及提高转化率。为了最大程度减少访客看到空白屏幕的时间，我们需要优化加载的资源及其加载顺序。', '-1', 2, 'https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 7, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>发现和解决关键渲染路径性能瓶颈需要充分了解常见的陷阱。 让我们踏上实践之旅，找出常见的性能模式，从而帮助您优化网页。</p>\n<p>优化关键渲染路径能够让浏览器尽可能快地绘制网页: 更快的网页渲染速度可以提高吸引力、增加网页浏览量以及<a href=\"https://www.google.com/think/multiscreen/success.html\">提高转化率</a>。为了最大程度减少访客看到空白屏幕的时间，我们需要优化加载的资源及其加载顺序。</p>\n<p>为帮助说明这一流程，让我们先从可能的最简单情况入手，逐步构建我们的网页，使其包含更多资源、样式和应用逻辑。在此过程中，我们还会对每一种情况进行优化，以及了解可能出错的环节。</p>\n<p>到目前为止，我们只关注了资源（CSS、JS 或 HTML 文件）可供处理后浏览器中会发生的情况，而忽略了从缓存或从网络获取资源所需的时间。我们作以下假设:</p>\n<ul>\n<li>到服务器的网络往返（传播延迟时间）需要 100 毫秒。</li>\n<li>HTML 文档的服务器响应时间为 100 毫秒，所有其他文件的服务器响应时间均为 10 毫秒。</li>\n</ul>\n<h2>Hello World 体验</h2>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;title&gt;Critical Path: No Style&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>我们将从基本 HTML 标记和单个图像（无 CSS 或 JavaScript）开始。让我们在 Chrome DevTools 中打开 Network 时间线并检查生成的资源瀑布:</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041908091.png\" alt=\"image-20211104190815035\" /></p>\n<blockquote>\n<p><strong>Note:</strong> 尽管本文档使用 DevTools 说明 CRP 概念，DevTools 当前并不非常适合 CRP 分析。 如需了解详细信息，请参阅 <a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp#devtools\">DevTools 如何？</a>。</p>\n</blockquote>\n<p>正如预期的一样，HTML 文件下载花费了大约 200 毫秒。请注意，蓝线的透明部分表示浏览器在网络上等待（即尚未收到任何响应字节）的时间，而不透明部分表示的是收到第一批响应字节后完成下载的时间。HTML 下载量很小 (&lt;4K)，我们只需单次往返便可获取整个文件。因此，获取 HTML 文档大约需要 200 毫秒，其中一半的时间花费在网络等待上，另一半花费在等待服务器响应上。</p>\n<p>当 HTML 内容可用后，浏览器会解析字节，将它们转换成令牌，然后构建 DOM 树。请注意，为方便起见，DevTools 会在底部报告 DOMContentLoaded 事件的时间（216 毫秒），该时间同样与蓝色垂直线相符。HTML 下载结束与蓝色垂直线 (DOMContentLoaded) 之间的间隔是浏览器构建 DOM 树所花费的时间 — 在本例中仅为几毫秒（216-205=11ms）。</p>\n<p>请注意，我们的“趣照”并未阻止 <code>domContentLoaded</code> 事件。这证明，我们构建渲染树甚至绘制网页时无需等待页面上的每个资产: <strong>并非所有资源都对快速提供首次绘制具有关键作用</strong> 。事实上，当我们谈论关键渲染路径时，通常谈论的是 HTML 标记、CSS 和 JavaScript。图像不会阻止页面的首次渲染，不过，我们当然也应该尽力确保系统尽快绘制图像！</p>\n<p>即便如此，系统还是会阻止图像上的 <code>load</code> 事件（也称为 <code>onload</code>）: DevTools 会在 335 毫秒时报告 <code>onload</code> 事件。回想一下，<code>onload</code> 事件标记的点是网页所需的<strong>所有资源</strong> 均已下载并经过处理的点，这是加载微调框可以在浏览器中停止微调的点（由瀑布中的红色垂直线标记）。</p>\n<h2>结合使用 JavaScript 和 CSS</h2>\n<p>我们的“Hello World 体验”页面虽然看起来简单，但背后却需要做很多工作。在实践中，我们还需要 HTML 之外的其他资源: 我们可能需要 CSS 样式表以及一个或多个用于为网页增加一定交互性的脚本。让我们将两者结合使用，看看效果如何:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Critical Path: Measure Script&lt;/title&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body onload=&quot;measureCRP()&quot;&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;timing.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>_添加 JavaScript 和 CSS 之前: _</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041908091.png\" alt=\"image-20211104190815035\" /></p>\n<p>_添加 JavaScript 和 CSS 之后: _</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041916649.png\" alt=\"image-20211104191650599\" /></p>\n<p>添加外部 CSS 和 JavaScript 文件将额外增加两个瀑布请求，浏览器差不多会同时发出这两个请求。不过，<strong>请注意，现在 <code>domContentLoaded</code> 事件与 <code>onload</code> 事件之间的时间差小多了。</strong></p>\n<p>这是怎么回事？</p>\n<ul>\n<li>与纯 HTML 示例不同，我们还需要获取并解析 CSS 文件才能构建 CSSOM，要想构建渲染树，DOM 和 CSSOM 缺一不可。</li>\n<li>由于网页上还有一个阻止 JavaScript 文件的解析器，系统会在下载并解析 CSS 文件之前阻止<code>domContentLoaded</code> 事件: 因为 JavaScript 可能会查询 CSSOM，我们必须在下载 CSS 文件之前将其阻止，然后才能执行 JavaScript。</li>\n</ul>\n<p>**如果我们用内联脚本替换外部脚本会怎样？**即使直接将脚本内联到网页中，浏览器仍然无法在构建 CSSOM 之前执行脚本。简言之，内联 JavaScript 也会阻止解析器。</p>\n<p>不过，尽管内联脚本会阻止 CSS，但这样做是否能加快页面渲染速度呢？让我们尝试一下，看看会发生什么。</p>\n<p>_外部 JavaScript: _</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041916649.png\" alt=\"image-20211104191650599\" /></p>\n<p>_内联 JavaScript: _</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041931468.png\" alt=\"image-20211104193101416\" /></p>\n<p>我们减少了一个请求，但 <code>onload</code> 和 <code>domContentLoaded</code> 时间实际上没有变化。为什么呢？怎么说呢，我们知道，这与 JavaScript 是内联的还是外部的并无关系，因为只要浏览器遇到 script 标记，就会进行阻止，并等到 CSSOM 构建完毕。此外，在我们的第一个示例中，浏览器是并行下载 CSS 和 JavaScript，并且差不多是同时完成。在此实例中，内联 JavaScript 代码并无多大意义。但是，我们可以通过多种策略加快网页的渲染速度。</p>\n<p>首先回想一下，所有内联脚本都会阻止解析器，但对于外部脚本，我们可以添加“async”关键字来解除对解析器的阻止。让我们撤消内联，尝试一下这种方法:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Critical Path: Measure Async&lt;/title&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body onload=&quot;measureCRP()&quot;&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script async src=&quot;timing.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>_阻止解析器的（外部）JavaScript: _</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041916649.png\" alt=\"image-20211104191650599\" /></p>\n<p>_异步（外部）JavaScript: _</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041933419.png\" alt=\"image-20211104193330371\" /></p>\n<p>效果好多了！解析 HTML 之后不久即会触发 <code>domContentLoaded</code> 事件；浏览器已得知不要阻止 JavaScript，并且由于没有其他阻止解析器的脚本，CSSOM 构建也可同步进行了。</p>\n<p>或者，我们也可以同时内联 CSS 和 JavaScript:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Critical Path: Measure Inlined&lt;/title&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;style&gt;\n      p { font-weight: bold }\n      span { color: red }\n      p span { display: none }\n      img { float: right }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n      var span = document.getElementsByTagName(\'span\')[0];\n      span.textContent = \'interactive\'; // change DOM text content\n      span.style.display = \'inline\';  // change CSSOM property\n      // create a new element, style it, and append it to the DOM\n      var loadTime = document.createElement(\'div\');\n      loadTime.textContent = \'You loaded this page on: \' + new Date();\n      loadTime.style.color = \'blue\';\n      document.body.appendChild(loadTime);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041935286.png\" alt=\"image-20211104193523241\" /></p>\n<p>请注意，<code>domContentLoaded</code> 时间与前一示例中的时间实际上相同；只不过没有将 JavaScript 标记为异步，而是同时将 CSS 和 JS 内联到网页本身。这会使 HTML 页面显著增大，但好处是浏览器无需等待获取任何外部资源，网页已经内置了所有资源。</p>\n<p>如您所见，即便是非常简单的网页，优化关键渲染路径也并非轻而易举: 我们需要了解不同资源之间的依赖关系图，我们需要确定哪些资源是“关键资源”，我们还必须在不同策略中做出选择，找到在网页上加入这些资源的恰当方式。这一问题不是一个解决方案能够解决的，每个页面都不尽相同。您需要遵循相似的流程，自行找到最佳策略。</p>\n<p>不过，我们可以回过头来，看看能否找出某些常规性能模式。</p>\n<h2>性能模式</h2>\n<p>最简单的网页只包括 HTML 标记；没有 CSS，没有 JavaScript，也没有其他类型的资源。要渲染此类网页，浏览器需要发起请求，等待 HTML 文档到达，对其进行解析，构建 DOM，最后将其渲染在屏幕上:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;title&gt;Critical Path: No Style&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041940582.png\" alt=\"image-20211104194021526\" /></p>\n<p><strong>T0 与 T1</strong> 之间的时间捕获的是网络和服务器处理时间。<strong>在最理想的情况下（如果 HTML 文件较小），我们只需一次网络往返便可获取整个文档</strong>。由于 TCP 传输协议工作方式的缘故，较大文件可能需要更多次的往返。<strong>因此，在最理想的情况下，上述网页具有单次往返（最少）关键渲染路径。</strong></p>\n<p>现在，我们还以同一网页为例，但这次使用外部 CSS 文件:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041941402.png\" alt=\"image-20211104194102353\" /></p>\n<p>我们同样需要一次网络往返来获取 HTML 文档，然后检索到的标记告诉我们还需要 CSS 文件；这意味着，浏览器需要返回服务器并获取 CSS，然后才能在屏幕上渲染网页。因此，这个页面至少需要两次往返才能显示出来。CSS 文件同样可能需要多次往返，因此重点在于“最少”。</p>\n<p>让我们定义一下用来描述关键渲染路径的词汇:</p>\n<ul>\n<li><strong>关键资源:</strong> 可能阻止网页首次渲染的资源。</li>\n<li><strong>关键路径长度:</strong> 获取所有关键资源所需的往返次数或总时间。</li>\n<li><strong>关键字节:</strong> 实现网页首次渲染所需的总字节数，它是所有关键资源传送文件大小的总和。我们包含单个 HTML 页面的第一个示例包含一项关键资源（HTML 文档）；关键路径长度也与 1 次网络往返相等（假设文件较小），而总关键字节数正好是 HTML 文档本身的传送大小。</li>\n</ul>\n<p>现在，让我们将其与上面 HTML + CSS 示例的关键路径特性对比一下:</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041941402.png\" alt=\"image-20211104194102353\" /></p>\n<ul>\n<li><strong>2</strong> 项关键资源</li>\n<li><strong>2</strong> 次或更多次往返的最短关键路径长度</li>\n<li><strong>9</strong> KB 的关键字节</li>\n</ul>\n<p>我们同时需要 HTML 和 CSS 来构建渲染树。所以，HTML 和 CSS 都是关键资源: CSS 仅在浏览器获取 HTML 文档后才会获取，因此关键路径长度至少为两次往返。两项资源相加共计 9KB 的关键字节。</p>\n<p>现在，让我们向组合内额外添加一个 JavaScript 文件。</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>我们添加了 <code>app.js</code>，它既是网页上的外部 JavaScript 资产，又是一种解析器阻止（即关键）资源。更糟糕的是，为了执行 JavaScript 文件，我们还需要进行阻止并等待 CSSOM；回想一下，JavaScript 可以查询 CSSOM，因此在下载 <code>style.css</code> 并构建 CSSOM 之前，浏览器将会暂停。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041947764.png\" alt=\"image-20211104194732708\" /></p>\n<p>即便如此，如果我们实际查看一下该网页的“网络瀑布”，就会注意到 CSS 和 JavaScript 请求差不多是同时发起的；浏览器获取 HTML，发现两项资源并发起两个请求。因此，上述网页具有以下关键路径特性:</p>\n<ul>\n<li><strong>3</strong> 项关键资源</li>\n<li><strong>2</strong> 次或更多次往返的最短关键路径长度</li>\n<li><strong>11</strong> KB 的关键字节</li>\n</ul>\n<p>现在，我们拥有了三项关键资源，关键字节总计达 11 KB，但我们的关键路径长度仍是两次往返，因为我们可以同时传送 CSS 和 JavaScript。**了解关键渲染路径的特性意味着能够确定哪些是关键资源，此外还能了解浏览器如何安排资源的获取时间。**让我们继续探讨示例。</p>\n<p>在与网站开发者交流后，我们意识到我们在网页上加入的 JavaScript 不必具有阻止作用: 网页中的一些分析代码和其他代码不需要阻止网页的渲染。了解了这一点，我们就可以向 script 标记添加“async”属性来解除对解析器的阻止:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041950685.png\" alt=\"image-20211104195044632\" /></p>\n<p>异步脚本具有以下几个优点:</p>\n<ul>\n<li>脚本不再阻止解析器，也不再是关键渲染路径的组成部分。</li>\n<li>由于没有其他关键脚本，CSS 也不需要阻止<code>domContentLoaded</code> 事件。</li>\n<li><code>domContentLoaded</code> 事件触发得越早，其他应用逻辑开始执行的时间就越早。</li>\n</ul>\n<p>因此，我们优化过的网页现在恢复到了具有两项关键资源（HTML 和 CSS），最短关键路径长度为两次往返，总关键字节数为 9 KB。</p>\n<p>最后，如果 CSS 样式表只需用于打印，那会如何呢？</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041952528.png\" alt=\"image-20211104195216472\" /></p>\n<p>因为 style.css 资源只用于打印，浏览器不必阻止它便可渲染网页。所以，只要 DOM 构建完毕，浏览器便具有了渲染网页所需的足够信息。因此，该网页只有一项关键资源（HTML 文档），并且最短关键渲染路径长度为一次往返。</p>\n<p>下一节：<a href=\"http://www.bnbiye.cn/#/articleDetail/b384b510-3d8b-11ec-97a5-ef78eceb5d73\">优化关键渲染路径</a></p>\n', '2021-11-05 00:22:42', '2021-11-05 09:05:27');
INSERT INTO `t_blog` VALUES ('70387930-55ba-11ec-96d5-7933aca11ca0', '转义，特殊字符', '正如我们所看到的，一个反斜杠 `\"\\\"` 是用来表示匹配字符类的。所以它是一个特殊字符。\n\n还存在其它的特殊字符，这些字符在正则表达式中有特殊的含义。它们可以被用来做更加强大的搜索。\n\n这里是包含所有特殊字符的列表：`[ \\ ^ $ . | ? * + ( )`。\n\n现在并不需要尝试去记住它们 —— 当我们分别处理其中的每一个时，你自然而然就会记住它们。', '-1', 2, 'https://zh.javascript.info/regexp-escaping', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 5, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>正如我们所看到的，一个反斜杠 <code>&quot;\\&quot;</code> 是用来表示匹配字符类的。所以它是一个特殊字符。</p>\n<p>还存在其它的特殊字符，这些字符在正则表达式中有特殊的含义。它们可以被用来做更加强大的搜索。</p>\n<p>这里是包含所有特殊字符的列表：<code>[ \\ ^ $ . | ? * + ( )</code>。</p>\n<p>现在并不需要尝试去记住它们 —— 当我们分别处理其中的每一个时，你自然而然就会记住它们。</p>\n<h2>转义</h2>\n<p>如果要把特殊字符作为常规字符来使用，只需要在它前面加个反斜杠。</p>\n<p>这种方式也被叫做“转义一个字符”。</p>\n<p>比如说，我们需要找到一个点号 <code>\'.\'</code>。在一个正则表达式中一个点号意味着“除了换行符以外的任意字符”，所以如果我们想真正表示对“一个点号”查询的时候，可以在点号前加一个反斜杠。</p>\n<pre><code class=\"language-js\">console.log(&quot;Chapter 5.1&quot;.match(/\\d\\.\\d/)); // [ \'5.1\', index: 8, input: \'Chapter 5.1\', groups: undefined ]\n</code></pre>\n<p>括号也是特殊字符，所以如果我们想要在正则中查找它们，我们应该使用 <code>\\(</code>。下面的例子会查找一个字符串 <code>&quot;g()&quot;</code>：</p>\n<pre><code class=\"language-js\">console.log(&quot;function g()&quot;.match(/g\\(\\)/)); // [ \'g()\', index: 9, input: \'function g()\', groups: undefined ]\n</code></pre>\n<p>如果我们想查找反斜杠 <code>\\</code>，我们就应该使用两个反斜杠来查找：</p>\n<pre><code class=\"language-js\">console.log(&quot;1\\\\2&quot;.match(/\\\\/)); // [ \'\\\\\', index: 1, input: \'1\\\\2\', groups: undefined ]\n</code></pre>\n<h2>一个斜杠</h2>\n<p>斜杠符号 <code>\'/\'</code> 并不是一个特殊符号，但是它被用于在 Javascript 中开启和关闭正则匹配：<code>/...pattern.../</code>，所以我们也应该转义它。</p>\n<p>下面是查询斜杠 <code>\'/\'</code> 的表达式：</p>\n<pre><code class=\"language-js\">console.log(&quot;/&quot;.match(/\\//)); // [ \'/\', index: 0, input: \'/\', groups: undefined ]\n</code></pre>\n<p>从另一个方面看，如果使用另一种 <code>new RegExp</code> 方式就不需要转义斜杠：</p>\n<pre><code class=\"language-js\">console.log(&quot;/&quot;.match(new RegExp(&quot;/&quot;))); // [ \'/\', index: 0, input: \'/\', groups: undefined ]\n</code></pre>\n<h2>使用new RegExp 创建正则实例</h2>\n<p>如果我们使用 <code>new RegExp</code> 来创建一个正则表达式实例，那么我们需要对其做一些额外的转义。</p>\n<p>比如说，考虑下面的示例：</p>\n<pre><code class=\"language-js\">let reg = new RegExp(&quot;\\d\\.\\d&quot;);\n\nconsole.log( &quot;Chapter 5.1&quot;.match(reg) ); // null\n</code></pre>\n<p>它并没有正常发挥作用，但是为什么呢？</p>\n<p>原因就在于字符串转义规则。看下面的例子：</p>\n<pre><code class=\"language-js\">console.log(&quot;\\d\\.\\d&quot;); // d.d\n</code></pre>\n<p>在字符串中的反斜杠表示转义或者类似 <code>\\n</code> 这种只能在字符串中使用的特殊字符。这个引用会“消费”并且解释这些字符，比如说：</p>\n<ul>\n<li><code>\\n</code> —— 变成一个换行字符，</li>\n<li><code>\\u1234</code> —— 变成包含该码位的 Unicode 字符，</li>\n<li>。。。其它有些并没有特殊的含义，就像 <code>\\d</code> 或者 <code>\\z</code>，碰到这种情况的话会把反斜杠移除。</li>\n</ul>\n<p>如果要修复这个问题，我们需要双斜杠，因为引用会把 <code>\\\\</code> 变为 <code>\\</code>：</p>\n<pre><code class=\"language-js\">let regStr = &quot;\\\\d\\\\.\\\\d&quot;;\nconsole.log(regStr); // \\d\\.\\d (correct now)\n\nlet regexp = new RegExp(regStr);\n\nconsole.log(&quot;Chapter 5.1&quot;.match(regexp)); // [ \'5.1\', index: 8, input: \'Chapter 5.1\', groups: undefined ]\n</code></pre>\n<h2>总结</h2>\n<ul>\n<li>要在字面（意义）上搜索特殊字符 <code>[ \\ ^ $ . | ? * + ( )</code>，我们需要在它们前面加上反斜杠 <code>\\</code>（“转义它们”）。</li>\n<li>如果我们在 <code>/.../</code> 内部（但不在 <code>new RegExp</code> 内部），还需要转义 <code>/</code>。</li>\n<li>传递一个字符串（参数）给 <code>new RegExp</code> 时，我们需要双倍反斜杠 <code>\\\\</code>，因为字符串引号会消费其中的一个。</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-escaping\">https://zh.javascript.info/regexp-escaping</a></p>\n', '2021-12-05 18:59:37', '2021-12-05 18:59:37');
INSERT INTO `t_blog` VALUES ('7484ff10-5d51-11ec-96d5-7933aca11ca0', '合并两个排好序的链表', 'JZ25 合并两个排序的链表', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 2, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<p>数据范围： <code>0≤n≤1000</code>，<code>-1000≤ 节点值 ≤ 1000</code><br />\n要求：空间复杂度 O(1)，时间复杂度 O(n)</p>\n<p>如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}，所以对应的输出为{1,2,3,4,5,6}，转换过程如下图所示：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112150929714.png\" alt=\"image-20211215092909637\" /></p>\n<p>或输入{-1,2,4},{1,3,4}时，合并后的链表为{-1,1,2,3,4,4}，所以对应的输出为{-1,1,2,3,4,4}，转换过程如下图所示：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112150929461.png\" alt=\"image-20211215092927412\" /></p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入： {1,3,5},{2,4,6}\n返回值：{1,2,3,4,5,6}\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入： {},{}\n返回值：{}\n</code></pre>\n<p>示例3</p>\n<pre><code class=\"language-js\">输入： {-1,2,4},{1,3,4}\n返回值：{-1,1,2,3,4,4}\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 正常方法，遍历改变指向</h3>\n<ol>\n<li>从两个链表最小的头结点开始遍历</li>\n<li>比较当前链表上<code>L1</code>的下一个节点<code>current.next</code>与另外一条链表<code>L2</code>等待比较的节点<code>nextWaitNode</code>的大小\n<ol>\n<li>如果当前链表的下一个节点比<code>nextWaitNode</code>大，就改变指向</li>\n<li>如果不大，就继续在当前链表上遍历</li>\n</ol>\n</li>\n</ol>\n<p>（自己写的代码）</p>\n<pre><code class=\"language-js\">function Merge(pHead1, pHead2){\n    // 1. 若果两个链表有一个为空，返回另一个，如果都为空，返回空\n    if(pHead1===null || pHead2 ===null) {\n        return pHead1 || pHead2\n    }\n    \n    let nextWaitNode = null // 下一个等待比较的节点\n    let newHead = null // 当前最小的节点\n    \n    // 找到小的那个开始遍历\n    if(pHead1.val &lt;= pHead2.val){\n        newHead = pHead1\n        nextWaitNode = pHead2\n    }else {\n        newHead = pHead2\n        nextWaitNode = pHead1\n    }\n    \n    let current = newHead\n    \n    while(current){\n        // 如果current有next\n        if(current.next){\n            // 如果比另外一个链上等待比较的节点大，就切换\n            if(current.next.val &gt; nextWaitNode.val){\n                let tempNode = current.next\n                current.next = nextWaitNode // 切换\n                nextWaitNode = tempNode\n            }\n            current = current.next\n        }else { // 如果current没有next\n            current.next = nextWaitNode \n            // 剩下的就不用比较了，因为是有序的，直接break\n            break\n        }\n    }\n    \n    return newHead\n}\n</code></pre>\n<p>（参考代码）</p>\n<pre><code class=\"language-js\">function Merge(pHead1, pHead2){\n    // 虚拟节点\n    let vHead = new ListNode(-1)\n    // 当前指针\n    let current = vHead\n    \n    while(pHead1 &amp;&amp; pHead2){\n        // 一个一个比较\n        // 把current指向小的节点\n        if(pHead1.val &lt;= pHead2.val){\n            current.next = pHead1 // 每条链表比较完一个就后移一位\n            pHead1 = pHead1.next\n        }else {\n            current.next = pHead2 // 每条链表比较完一个就后移一位\n            pHead2 = pHead2.next\n        }\n        \n        current = current.next // current也后移一位，等待下次循环\n    }\n    // while循环会在某一条链表为空时结束\n    // 将当前的current指向不为空的那一条\n    current.next = pHead1 ? pHead1 : pHead2\n    \n    return vHead.next\n}\n</code></pre>\n<h3>代码2 递归</h3>\n<pre><code class=\"language-js\">/*\n1. 递归函数结束的条件是什么？\n2. 递归函数一定是缩小递归区间的，那么下一步的递归区间是什么？\n    对于问题1.对于链表就是，如果为空，返回什么\n    对于问题2，跟迭代方法中的一样，如果PHead1的所指节点值小于等于pHead2所指的结点值，\n    那么phead1后续节点和pHead节点继续递归\n*/\nfunction Merge(pHead1, pHead2){\n    if(!pHead1) return pHead2\n    if(!pHead2) return pHead1\n    \n    if(pHead1.val &lt;= pHead2.val){\n        pHead1.next = Merge(pHead1.next, pHead2)\n        return pHead1\n    }else {\n        pHead2.next = Merge(pHead1, pHead2.next)\n        return pHead2\n    }\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=23267&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\"><strong>JZ25</strong> <strong>合并两个排序的链表</strong></a></p>\n', '2021-12-15 10:48:17', '2021-12-15 10:48:17');
INSERT INTO `t_blog` VALUES ('7a836150-2d8a-11ec-ba0f-810bb435395b', 'git提交规范 Commitizen', '标准化Git的Commit Message，查看提交记录时可以更清晰的明白本次提交的任务，安装插件后还可以直接生成最近完成的列表md文件，非常好用，推荐指数★★★★★', '-1', 1, '', 'ed61f0f0-2cbe-11ec-86ae-0da8227970f6', -1, 7, 4, 1, 2, 1, 'http://82.156.76.49:20517/upload/png/2021-10-15/96ca9b80-2d8a-11ec-ba0f-810bb435395b.png', '<p>标准化Git的Commit Message，查看提交记录时可以更清晰的明白本次提交的任务，安装插件后还可以直接生成最近完成的列表md文件，非常好用，推荐指数★★★★★</p>\n<h2>本地库向远程推送方法</h2>\n<ul>\n<li>\n<p>远程gitee上新建一个代码仓库</p>\n</li>\n<li>\n<p>进入到本地项目下</p>\n<pre><code class=\"language-shell\">cd existing_git_repo\ngit init\n\n# 初始化一个package.json文件\n# npm init -y\n\ngit add .\ngit commit -m &quot;初始化项目&quot;\ngit remote add origin git@gitee.com:hrbust_cheny/git-submission-specification.git\ngit push -u origin master\n</code></pre>\n</li>\n</ul>\n<h2>Commit Message 格式</h2>\n<pre><code class=\"language-shell\">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n&lt;空行&gt;\n&lt;body&gt;\n&lt;空行&gt;\n&lt;footer&gt;\n</code></pre>\n<h3>Type（*必填）</h3>\n<ul>\n<li>\n<p>feat：新增一个功能（feature）</p>\n</li>\n<li>\n<p>fix：修复一个bug</p>\n</li>\n<li>\n<p>docs：文档（documentation）</p>\n</li>\n<li>\n<p>style： 代码格式（不影响代码运行的变动，例如空格、分号等格式矫正）</p>\n</li>\n<li>\n<p>refactor：代码重构（即不是新增功能，也不是修改bug的代码变动）</p>\n</li>\n<li>\n<p>perf：改善性能</p>\n</li>\n<li>\n<p>test：增加测试</p>\n</li>\n<li>\n<p>build：变更项目构建或外部依赖（例如webpack、npm等）</p>\n</li>\n<li>\n<p>ci：更改持续集成软件的配置文件和package.json中的script命令</p>\n</li>\n<li>\n<p>chore：构建过程或辅助工具的变动</p>\n</li>\n<li>\n<p>revert：代码回退</p>\n<blockquote>\n<p>如果需要撤销之前的Commit，那么本次Commit Message中必须以<code>revert：</code>开头，后面紧跟前面描述的Header部分，格式不变。并且，Body部分的格式也是固定的，必须要记录撤销前Commit的SHA值。</p>\n</blockquote>\n</li>\n</ul>\n<h3>Scope（选填）</h3>\n<p>用来说明本次Commit影响的范围，即简要说明修改会涉及的部分。例如在业务项目中可以依据菜单或者功能模块划分，如果是组件库开发，则可以依据组件划分。</p>\n<h3>Subject（*必填）</h3>\n<p>用来简要描述本次改动，概述就好了，因为后面还会在Body里给出具体信息，也可以不给。</p>\n<h3>Body（选填）</h3>\n<p><code>commit</code>的详细描述，说明代码提交的详细说明。</p>\n<h3>Footer（选填）</h3>\n<p>footer里的主要放置<strong>不兼容变更</strong>和<strong>Issue关闭</strong>的信息，如果代码的提交是上述两种情况，则<code>Footer</code>必需，否则可以省略。</p>\n<ul>\n<li>\n<p>不兼容变更</p>\n<p>当前代码与上一个版本不兼容，则<code>Footer</code>以<strong>BREAKING CHANGE</strong>开头，后面是对变动的描述、以及变动的理由和迁移方法。例如：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1988a48466e4be691b4630ed69fc355~tplv-k3u1fbpfcp-watermark.image?\" alt=\"1.png\" /></p>\n</li>\n<li>\n<p>Issue关闭</p>\n<p>如果当前提交是针对特定的issue，那么可以在<code>Footer</code>部分填写需要关闭的单个 issue 或一系列issues。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ade14e5fc84d44089be1bfe838786636~tplv-k3u1fbpfcp-watermark.image?\" alt=\"2.png\" /></p>\n</li>\n</ul>\n<h2>Commitizen安装</h2>\n<h3>安装</h3>\n<pre><code class=\"language-shell\"># 安装Commitizen\nnpm install -g commitizen --registry=https://registry.npm.taobao.org\n\n# 安装changelog，是生成changelog的工具\nnpm install -g conventional-changelog --registry=https://registry.npm.taobao.org\nnpm install -g conventional-changelog-cli --registry=https://registry.npm.taobao.org\n</code></pre>\n<p>检测是否安装成功。</p>\n<pre><code class=\"language-shel\">npm ls -g -depth=0\n</code></pre>\n<p>检验上面两个工具是否安装成功，得到结果如下，表示成功：</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c99f9aa43d694763a8d00936e4a189c7~tplv-k3u1fbpfcp-watermark.image?\" alt=\"3.png\" /><br />\n然后，进入到项目目录，运行下面命令，使其支持Angular的Commit message格式。</p>\n<pre><code class=\"language-shell\"># 进入项目目录\ncd git_test\n# 使其支持Angular的Commit message格式\ncommitizen init cz-conventional-changelog --save --save-exact\n</code></pre>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f065b36dfdec4b6d8366641f3e739a0d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"4.png\" /></p>\n<blockquote>\n<p>这个指令一直报 <code>\'commitizen\' 不是内部或外部命令，也不是可运行的程序</code> 的错误</p>\n<p>很迷，是全局安装的commitizen，但是还是找不到，然后我就在环境变量里又配了一个，</p>\n<p>然后用cmd窗口执行还是不好使，但是我换了一个PowerShell就好使了。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d0057f4516647a4a79818f8d1f01df4~tplv-k3u1fbpfcp-watermark.image?\" alt=\"5.png\" /></p>\n<p>很迷的一个bug。</p>\n</blockquote>\n<h3>生成CHANGELOG.md文件</h3>\n<p>然后再项目目录下，执行下面命令生成<code>CHANGELOG.md</code>。</p>\n<pre><code class=\"language-shell\">conventional-changelog -p angular -i CHANGELOG.md -s\n</code></pre>\n<p>此时项目中多了CHANGELOG.md文件，表示生成 Change log成功了。</p>\n<ul>\n<li><code>conventional-changelog -p angular -i CHANGELOG.md -s</code> (该命令不会覆盖以前的 Change log，只会 在CHANGELOG.md的头部加上自从上次发布以来的变动)</li>\n<li><code>conventional-changelog -p angular -i CHANGELOG.md -s -r 0</code> (生成所有发布的 Change log</li>\n</ul>\n<p>为了方便，可以在package.json中配置一下。</p>\n<pre><code class=\"language-json\">{\n     &quot;scripts&quot;: {\n        &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -s -r 0&quot;\n      }\n }\n</code></pre>\n<p>然后只需<code>npm run changelog</code>即可生成文档。</p>\n<h2>git cz</h2>\n<p>以后再代码更改后，提交commit message的时候，不再使用git commit -m方法，而是git cz，将会出现交互式选项，让你选择或者输入信息，给你一个完善的commit message。示例动图：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc5da7e4447a414dbf2cd74b03d0341c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"1.gif\" /></p>\n', '2021-10-15 15:35:32', '2021-12-09 21:54:36');
INSERT INTO `t_blog` VALUES ('7af13780-4b48-11ec-96d5-7933aca11ca0', '可迭代与类数组', '我们在学js时，有两个概念可能会弄混，可迭代对象和类数组对象。本文就彻底弄清楚它们到底是是怎么执行的。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 7, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>我们在学js时，有两个概念可能会弄混，可迭代对象和类数组对象。说某个对象是可迭代的，比如数组<code>let arr = [1,2,3]</code>或者<code>let map = new Map([[1, 2], [3, 4]])</code>，它们可以使用<code>for of</code>进行遍历。然后又说某个对象是类数组，我们可以将它转换为数组，因为它有数值索引和<code>length</code>属性。来看一个小例子：</p>\n<pre><code class=\"language-js\">let o1 = {\n    0: \'aa\',\n    1: \'bb\',\n    length: 2\n}\n\nlet arr1 = Array.from(o1)\nconsole.log(arr1); // [ \'aa\', \'bb\' ]\n\nfor (const item of arr1) {\n    console.log(item);\n}\n// aa\n// bb\n\nlet map = new Map([[1, 2], [3, 4]])\nfor (const item of map) {\n    console.log(item);\n}\n// [ 1, 2 ]\n// [ 3, 4 ]\n</code></pre>\n<p>如上面的例子，有一个类数组对象<code>o1</code>，使用<code>Array.from()</code>显示的将其转换为数组，然后这个对象就可以使用<code>for of</code>进行遍历了，其实上面这个小例子就涉及到了这两个概念：</p>\n<ol>\n<li>类数组对象（array-like object）：有数值索引属性和<code>length</code>属性的对象，称为类数组对象，比如例子中的<code>o1</code></li>\n<li>可迭代对象（iterable object）：可以使用<code>for of</code> 进行遍历的对象，就称为可迭代的，比如例子中的<code>arr1</code>（转换后的数组）和<code>map</code>。</li>\n</ol>\n<p>那么为什么有的对象可以使用<code>for of</code>遍历（也即是可迭代对象），而有的对象却不可以，这是为什么呢？</p>\n<h2>可迭代对象</h2>\n<p>实际上那些可以直接使用for of遍历的对象，是系统内置实现了<code>Symbol.iterator</code>迭代器方法。我们来看下面这个例子。</p>\n<h3>一个小例子</h3>\n<p>如下面的例子所示，有一个普通对象<code>range</code>，显然是不可迭代的（因为它就是一个普通对象，啥也没干），我们使用<code>for of</code>检验一下，果然也报错了，<code>TypeError: range is not iterable</code>。那么如果我们想要让它变为可迭代的，该怎么办呢？比如，我们想实现这样的效果：使<code>range</code>对象可以使用用<code>for of</code>进行遍历，依次从<code>1</code>输出到<code>5</code>。</p>\n<pre><code class=\"language-js\">let range = {\n    from: 1,\n    to: 5\n}\n\nfor (const iterator of range) {\n    console.log(iterator);\n}\n// TypeError: range is not iterable\n</code></pre>\n<p>我们来改写一下，既然想让这个对象变为可迭代的，那么就必须实现<code>Symbol.iterator</code>迭代方法。</p>\n<pre><code class=\"language-js\">let range = {\n    from: 1,\n    to: 5\n}\n\n/* \n1. 迭代器实际就是一个对象，对象上有 next() 方法\n2. 迭代器每次调用一个next()方法后，都会返回一个标识对象\n{\n    value: \'\', // 本次迭代获得的值\n    done: true|false // 标识是否还有下个值\n}\n3. for of 会获取到这个迭代对象，每遍历一次，调用一次迭代器的next方法，输出返回值中的value\n*/\nrange[Symbol.iterator] = function () {\n    // 返回一个迭代器对象\n    return {\n        current: this.from,\n        last: this.to,\n\n        next() {\n            // 结束条件\n            if (this.current &gt; this.last) {\n                return { done: true }\n            } else {\n                return {\n                    value: this.current++, // current++ 第一次调用的时候，取值还是 1，\n                    done: false\n                }\n            }\n        }\n    }\n}\n\nfor (const item of range) {\n    console.log(item);\n}\n// 1 2 3 4 5\n</code></pre>\n<p>我们通过实现<code>range[Symbol.iterator]</code>方法，让<code>range</code>对象也变成了可迭代对象，是不是很简单。我们只需要注意下几点</p>\n<ol>\n<li>\n<p><code>range</code>本身是没有<code>next()</code>方法的，是通过调用<code>range[Symbol.iterator]()</code>方法，返回了一个对象，即所谓的迭代器对象，通过迭代器对象上的<code>next()</code>方法获取到的值。</p>\n</li>\n<li>\n<p><code>next()</code>方法返回的值也是一个对象，对象的格式遵循下面的规范</p>\n<pre><code class=\"language-js\">{\n    value: \'\', // 本次迭代的值\n    done: true|false // 标识是否迭代完成 \n}\n</code></pre>\n</li>\n<li>\n<p><code>for of</code>的工作原理，实际上就是调用了对象的<code>[Symbol.iterator]()</code>方法，生成了一个迭代器对象，然后每次循环就调用一次<code>next()</code>方法，然后获取到返回值上的<code>value</code>，当标识符<code>done === true</code>时，就结束循环。</p>\n</li>\n</ol>\n<h3>显示调用迭代器</h3>\n<p>还用上面的例子举例，其实我们可以显示的调用<code>range</code>的迭代器方法，生成一个迭代器对象，然后模拟出和<code>for of</code>一样的效果，比如：</p>\n<pre><code class=\"language-js\">// 获取迭代器对象\nlet iterator = range[Symbol.iterator]()\nwhile (true) {\n    let result = iterator.next()\n    // 出口\n    if (result.done) {\n        break\n    }\n    console.log(result.value);\n}\n// 1 2 3 4 5\n</code></pre>\n<p>很少需要我们这样做，但是比 <code>for..of</code> 给了我们更多的控制权。例如，我们可以拆分迭代过程：迭代一部分，然后停止，做一些其他处理，然后再恢复迭代。</p>\n<h2>类数组对象</h2>\n<p>通过上面的学习，我们已经认清了可迭代对象的本质，实际上就是对象按照规范实现了<code>Symbol[iterator]</code>方法。那什么是类数组对象呢？我们工作中总能碰到这样的场景，某个对象它是可迭代的，某个对象它是类数组，某个对象即可迭代又是个类数组。可迭代我们已经知道了，类数组的本质其实也很简单，就是那些具有数值索引和<code>length</code>属性的对象。</p>\n<h3>一个小例子</h3>\n<p>如下面的例子，<code>arrayLike</code>对象即是一个类数组对象，它具备了类数组对象的特征，有数值索引、有<code>length</code>。但是类数组对象没有数组上的方法，比如<code>push</code>、<code>pop</code>等等，如果想用，就得使用<code>call</code>或者<code>apply</code>等改变一下<code>this</code>指向，借用一下<code>Array</code>原型上的方法。</p>\n<pre><code class=\"language-js\">let arrayLike = { // 有索引和 length 属性 =&gt; 类数组对象\n    0: &quot;Hello&quot;,\n    1: &quot;World&quot;,\n    sayHi() {\n        console.log(\'hhh\');\n    },\n    length: 2\n};\n[].push.call(arrayLike, \'nn\');\nconsole.log(arrayLike);\n/* \n{\n  \'0\': \'Hello\',\n  \'1\': \'World\',\n  \'2\': \'nn\',\n  sayHi: [Function: sayHi],\n  length: 3\n}\n*/\nlet str = [].join.call(arrayLike, \'-\')\nconsole.log(str); // Hello-World-nn\n</code></pre>\n<blockquote>\n<p>我们发现，<code>arrayLike</code>对象是个类数组对象，但是它是不可迭代的，因为我们没有实现它的<code>Symbol[iterator]</code>迭代器方法。而在可迭代对象中举的例子，<code>range</code>对象，它是可迭代的，但它不是一个类数组，因为它没有类数组对象的特征（没有数值索引和<code>length</code>）。不过在我们实际工作中，有很多对象它即是类数组，又是可迭代的。比如字符串（<code>for..of</code> 对它们有效，并且有数值索引和 <code>length</code> 属性）。</p>\n</blockquote>\n<h2>Array.from</h2>\n<p><code>Array.from</code>我们常用来将一个类数组对象转换为真正的数组。其实它还可以将可迭代对象也转换为数组。</p>\n<h3>类数组转数组</h3>\n<p>先看一下类数组转数组的例子：</p>\n<pre><code class=\"language-js\">let arrayLike = {\n    0: \'hello\',\n    1: \'world\',\n    length: 2\n}\n\nconsole.log(Array.from(arrayLike)); // [ \'hello\', \'world\' ]\n</code></pre>\n<p>实际就是按照数值索引的位置，将对应的值塞到一个新数组中，数组的长度取决于<code>length</code>的长度，长度不够就截断，长度超出就在对应位置补<code>undefined</code>。</p>\n<h3>可迭代转数组</h3>\n<p>再看一个可迭代转数组的例子，还拿我们写的<code>range</code>举例子。</p>\n<pre><code class=\"language-js\">let range = {\n    from: 1,\n    to: 5\n}\n\nrange[Symbol.iterator] = function () {\n    // 返回一个迭代器对象\n    return {\n        current: this.from,\n        last: this.to,\n\n        next() {\n            // 结束条件\n            if (this.current &gt; this.last) {\n                return { done: true }\n            } else {\n                return {\n                    value: this.current++, // current++ 第一次调用的时候，取值还是 1，\n                    done: false\n                }\n            }\n        }\n    }\n}\n\n// 将可迭代对象，转换为了数组\nconsole.log(Array.from(range)); // [ 1, 2, 3, 4, 5 ]\n</code></pre>\n<p>实际就是获取到迭代器的<code>next().value</code>的值，依次塞到新数组中去，然后返回这个新数组。</p>\n<h2>总结</h2>\n<ol>\n<li>\n<p>可迭代对象（iterable object）：可以使用<code>for of</code>遍历的对象就是可迭代对象。</p>\n<p>可迭代的本质是该对象实现了<code>Symbol.iterator</code>迭代器方法。迭代器返回的是一个对象，即是所谓的迭代器对象。</p>\n<p>迭代器对象有<code>next()</code>方法，<code>next()</code>方法的返回值也是一个对象，遵循这样的规范<code>{value: \'xxx\', done: true|false}</code>。</p>\n</li>\n<li>\n<p><code>for of</code>实际就是调用了一下<code>[Symbol.iterator]()</code>方法，获取了迭代器对象，然后每次遍历时调用一次迭代器对象的<code>next()</code>方法，获取到<code>value</code>的值，当标识符<code>done === true</code>时，表示遍历完成，结束<code>for of</code>。</p>\n</li>\n<li>\n<p>类数组对象（array-like object）：具有数值索引和<code>length</code>属性的对象。</p>\n<p>类数组对象没有数组上的<code>push、pop</code>等方法，要想使用的话有两个办法：</p>\n<ul>\n<li>转换为数组，使用<code>Array.from(arrayLike)</code></li>\n<li>使用<code>call、apply、bind</code>改变<code>this</code>的指向，借用<code>Array</code>原型上的方法，比如<code>[].push.call(arrayLike, \'xxx\')</code></li>\n</ul>\n</li>\n<li>\n<p><code>Array.from</code>可以将可迭代对象或者类数组对象转换为一个真正的数组。</p>\n<ul>\n<li>转换类数组对象时，就是把索引值获取到，依次按照索引值塞进一个新数组中（长度由<code>length</code>属性确定，塞入的位置由索引值确定，长度不够就截断，长度超出就在对应位置塞<code>undefined</code>）。</li>\n<li>转换可迭代对象时，就是获取到每次迭代器对象<code>next().value</code>的值，依次塞到一个新数组中。</li>\n</ul>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/iterable#array-like\">https://zh.javascript.info/iterable#array-like</a></p>\n', '2021-11-22 11:58:41', '2021-11-22 11:58:41');
INSERT INTO `t_blog` VALUES ('7e0e3a30-5db8-11ec-b395-6d1b1a7579ec', '删除链表的节点', 'JZ18 删除链表的节点', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 3, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112152303454.png\" alt=\"image-20211215230334382\" /></p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：\n{2,5,1,9},5\n返回值：\n{2,1,9}\n说明：\n给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 1 -&gt; 9\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：\n{2,5,1,9},1\n返回值：\n{2,5,9}\n说明：\n给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 5 -&gt; 9\n</code></pre>\n<h2>代码</h2>\n<pre><code class=\"language-js\">/*\n    前一个节点pre\n    当前节点 current\n    current = current.next\n    pre.next = current\n*/\n\nfunction deleteNode( head ,  val ) {\n    let dummy = new ListNode(-1) // 虚拟头结点\n    dummy.next = head\n    \n    let pre = dummy\n    let current = head\n    \n    while(current){\n        if(current.val === val){\n            current = current.next\n            pre.next = current\n        }else {\n            current = current.next\n            pre = pre.next\n        }\n    }\n    \n    return dummy.next\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/f9f78ca89ad643c99701a7142bd59f5d?tpId=13&amp;tqId=2273171&amp;ru=/practice/fc533c45b73a41b0b44ccba763f866ef&amp;qru=/ta/coding-interviews/question-ranking\">JZ18 删除链表的节点</a></p>\n', '2021-12-15 23:05:51', '2021-12-15 23:05:51');
INSERT INTO `t_blog` VALUES ('7e76a540-3250-11ec-a1da-59f2d55bf031', '行内元素、块级元素和行内块元素', '行内元素、块级元素、行内块元素的特点，行内元素宽高设置无效，外边距只生效左右，上下不生效，占一行，行内元素宽度取决于内容宽度...', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 12, 0, 1, 2, 1, '', '<h2>行内元素</h2>\n<ol>\n<li>相邻的元素不换行</li>\n<li>宽度为内容的宽度</li>\n<li>高度由字体大小决定</li>\n<li>padding四个方向都有效</li>\n<li>margin只水平方向有效</li>\n<li>不可以设置width和height</li>\n</ol>\n<p>比如</p>\n<pre><code>&lt;a&gt;     // 标签可定义锚 \n &lt;abbr&gt;     // 表示一个缩写形式 \n &lt;b&gt;     // 字体加粗 \n &lt;big&gt;     // 大号字体加粗 \n &lt;cite&gt;     // 引用进行定义 \n &lt;code&gt;    // 定义计算机代码文本\n &lt;em&gt;     // 定义为强调的内容\n &lt;i&gt;     // 斜体文本效果\n &lt;q&gt;     // 定义短的引用\n &lt;samp&gt;     // 定义样本文本\n &lt;small&gt;     // 呈现小号字体效果\n &lt;span&gt;     // 组合文档中的行内元素\n &lt;strong&gt; // 加粗\n &lt;sub&gt;     // 定义下标文本\n &lt;sup&gt;     // 定义上标文本\n</code></pre>\n<h2>块级元素</h2>\n<ol start=\"0\">\n<li>块级元素独自占一行，即使设置宽度也独占一行</li>\n<li>宽度高度、内边距外边距都可以控制</li>\n<li>如果不设置宽度的话，默认会撑满父级元素的宽度</li>\n</ol>\n<p>比如</p>\n<pre><code>&lt;address&gt;  // 定义地址 \n &lt;caption&gt;  // 定义表格标题 \n &lt;dd&gt;      // 定义列表中定义条目 \n &lt;div&gt;     // 定义文档中的分区或节 \n &lt;dl&gt;    // 定义列表 \n &lt;dt&gt;     // 定义列表中的项目 \n &lt;fieldset&gt;  // 定义一个框架集 \n &lt;form&gt;  // 创建 HTML 表单 \n &lt;h1&gt;-&lt;h6&gt;    // 定义标题\n &lt;hr&gt;     // 创建一条水平线\n &lt;legend&gt;    // 元素为 fieldset 元素定义标题\n &lt;li&gt;     // 标签定义列表项目\n &lt;ol&gt;     // 定义有序列表\n &lt;ul&gt;    // 定义无序列表\n &lt;p&gt;     // 标签定义段落\n &lt;pre&gt;     // 定义预格式化的文本\n &lt;table&gt;     // 标签定义 HTML 表格\n &lt;tbody&gt;     // 标签表格主体（正文）\n &lt;td&gt;    // 表格中的标准单元格\n &lt;tfoot&gt;     // 定义表格的页脚（脚注或表注）\n &lt;th&gt;    // 定义表头单元格\n &lt;thead&gt;    // 标签定义表格的表头\n &lt;tr&gt;     // 定义表格中的行\n</code></pre>\n<h2>行内块元素</h2>\n<p>既有块级元素的特点，也有行内元素的特点</p>\n<ol>\n<li>相邻元素不换行，但是中间会有缝隙</li>\n<li>宽度默认是本身内容的宽度</li>\n<li>可以控制宽度高度、内边距和外边距</li>\n</ol>\n<p>比如</p>\n<pre><code>&lt;button&gt; \n&lt;input&gt;   \n&lt;textarea&gt; \n&lt;select&gt; \n&lt;img&gt;\n</code></pre>\n<h2>相互转换</h2>\n<pre><code>display：block ，定义元素为块级元素\ndisplay : inline ，定义元素为行内元素\ndisplay：inline-block，定义元素为行内块级元素\n</code></pre>\n', '2021-10-21 17:23:04', '2021-10-21 17:23:04');
INSERT INTO `t_blog` VALUES ('7fa91c70-3a40-11ec-8015-f554da021b2a', '事件冒泡和捕获', '事件先冒泡后捕获，e.target是实际点击的元素，e.currentTarget是绑定事件函数后，因捕获或者冒泡机制而触发的那个元素', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 7, 0, 1, 2, 1, '', '<p>捕获过程：window-&gt;document-&gt;body-&gt;div-&gt;text</p>\n<p>冒泡过程：text-&gt;div-&gt;body-&gt;document-&gt;window</p>\n<h2>addEventListener</h2>\n<p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，共有三个参数：</p>\n<pre><code class=\"language-js\">element.addEventListener(event, function, useCapture)\n</code></pre>\n<ul>\n<li>\n<p>event</p>\n<p>必填项，字符串类型，表示绑定的是哪种事件（注意把所有的on去掉，比如onclick，改为click，其它同理），绑定类型参考 <a href=\"https://www.runoob.com/jsref/dom-obj-event.html\">绑定事件参考手册</a>。</p>\n</li>\n<li>\n<p>function</p>\n<p>可选填，事件处理函数，事件对象会作为第一个参数传入函数。事件对象的类型取决于特定的事件。比如click事件属于MouseEvent（鼠标事件）对象</p>\n</li>\n<li>\n<p>useCapture</p>\n<p>Boolean类型，true或false（默认为false）。</p>\n<p>true表示事件在捕获阶段执行。</p>\n<p>false表示事件在冒泡阶段执行。</p>\n</li>\n</ul>\n<h2>什么是事件冒泡</h2>\n<p>假如有一层嵌套的div，每一层div上都添加了点击事件，事件会从<strong>最里面往外</strong>触发，这就是事件冒泡。</p>\n<p>如下面的代码：<code>outer-&gt;middle-&gt;inner-&gt;button</code>，所有元素添加的都是冒泡事件，<code>useCapture为false</code></p>\n<p>当点击button时，事件触发会从里往外冒，依次打印<code>bubble button-&gt;bubble inner-&gt;bubble middle-&gt;bubble outer</code></p>\n<p>同理点击inner时，依次打印<code>bubble inner-&gt;bubble middle-&gt;bubble outer</code></p>\n<p>点击middle时，依次打印<code>bubble middle-&gt;bubble outer</code></p>\n<p>点击outer时，打印<code>bubble outer</code></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    div {\n        padding: 30px;\n    }\n\n    .outer {\n        background-color: pink;\n    }\n\n    .middle {\n        background-color: green;\n    }\n\n    .inner {\n        background-color: orange;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;outer&quot;&gt;\n        &lt;div class=&quot;middle&quot;&gt;\n            &lt;div class=&quot;inner&quot;&gt;\n                &lt;button&gt;click me&lt;/button&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script type=&quot;module&quot;&gt;\n        const $ = (selector)=&gt;{\n            return document.querySelector(selector)\n        }\n\n        // 冒泡\n        $(\'.outer\').addEventListener(\'click\',function(e){\n            console.log(\'bubble outer\');\n        }, false)\n\n        $(\'.middle\').addEventListener(\'click\',function(e){\n            console.log(\'bubble middle\');\n        }, false)\n        $(\'.inner\').addEventListener(\'click\',function(e){\n            console.log(\'bubble inner\');\n        }, false)\n\n        $(\'button\').addEventListener(\'click\',function(e){\n            console.log(\'bubble button\');\n        }, false)\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h2>什么是事件捕获</h2>\n<p>假如有一层嵌套的div，每一层div上都添加了点击事件，事件会从<strong>最外面往里</strong>触发，这就是事件捕获。</p>\n<p>如下面的代码：<code>outer-&gt;middle-&gt;inner-&gt;button</code>，所有元素添加的都是捕获事件，<code>useCapture为true</code></p>\n<p>当点击outer时，事件触发会从外往里触发，依次打印<code>capture outer-&gt;capture middle-&gt;capture inner-&gt;capture button</code></p>\n<p>同理点击middle时，依次打印<code>capture middle-&gt;capture inner-&gt;capture button</code></p>\n<p>点击inner时，依次打印<code>capture inner-&gt;capture button</code></p>\n<p>点击button时，打印``capture button`</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    div {\n        padding: 30px;\n    }\n\n    .outer {\n        background-color: pink;\n    }\n\n    .middle {\n        background-color: green;\n    }\n\n    .inner {\n        background-color: orange;\n    }\n&lt;/style&gt;\n&lt;div class=&quot;outer&quot;&gt;\n    &lt;div class=&quot;middle&quot;&gt;\n        &lt;div class=&quot;inner&quot;&gt;\n            &lt;button&gt;click me&lt;/button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n\n&lt;script type=&quot;module&quot;&gt;\n    const $ = (selector)=&gt;{\n        return document.querySelector(selector)\n    }\n\n    // 捕获\n    $(\'.outer\').addEventListener(\'click\',function(e){\n        console.log(\'capture outer\');\n    }, true)\n\n    $(\'.middle\').addEventListener(\'click\',function(e){\n        console.log(\'capture middle\');\n    }, true)\n    $(\'.inner\').addEventListener(\'click\',function(e){\n        console.log(\'capture inner\');\n    }, true)\n\n    $(\'button\').addEventListener(\'click\',function(e){\n        console.log(\'capture button\');\n    }, true)\n&lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h2>同时都存在时，先触发哪一个</h2>\n<p>先触发捕获，后触发冒泡</p>\n<h2><code>e.target</code>和<code>e.currentTarget</code>的区别</h2>\n<p><code>e.target</code>：是自己实际点击的那个<code>div</code></p>\n<p><code>e.currentTarget</code>：是绑定事件函数后，因捕获或者冒泡机制而触发的那个<code>div</code></p>\n<p>所以有个很巧妙的判断，<code>e.target===e.currentTarget</code>，表示是自嗨型，自己的事件，点击的自己，触发也是自己的事件函数。当不相等时，说明事件是通过冒泡或者捕获触发的。</p>\n<h2>阻止事件冒泡</h2>\n<p>e.stopPropagation()</p>\n<h2>阻止默认行为</h2>\n<p>e.preventDefault()</p>\n<h2>事件委托</h2>\n<p>假如ul里有100个li，每个li都需要绑定点击事件，常规做法是遍历每个li，然后绑定点击事件。</p>\n<p>这种做法在li非常少的情况下还行，当有非常多的li时，就不可取了。</p>\n<p>所以这时可以将事件绑定到父级ul身上，根据事件冒泡机制，点击li时，仍然可以将点击事件冒泡给ul，触发父级ul的点击事件。然后通过e.target找到实际点击的元素，就可以判断出来是哪一个li。</p>\n', '2021-10-31 19:48:43', '2021-10-31 19:48:53');
INSERT INTO `t_blog` VALUES ('8370a350-5fb1-11ec-b395-6d1b1a7579ec', '判断是不是平衡二叉树', 'JZ79 判断是不是平衡二叉树', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 3, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112181111138.png\" alt=\"image-20211218111124974\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112181111235.png\" alt=\"image-20211218111147195\" /></p>\n<h2>代码</h2>\n<h3>代码1 深度优先遍历，获取每一层的高度，过程中比较左子树右子树的高度差</h3>\n<pre><code class=\"language-js\">/*\n题目要求不用考虑是否是排序的二叉树，只考虑平衡性\n平衡二叉树：左子树与右子树的高度差绝对值小于等于1，同时左子树与右子树都是平衡二叉树。\n其实与求二叉树的深度是一样的，只不过是在求得过程中比较左子树与右子树的高度差绝对值是否&lt;1\n*/\nfunction IsBalanced_Solution(pRoot)\n{\n    let isBalanced = true // 默认是平衡二叉树 true\n    // 判断，在递归的途中判断左子树和右子树的高度差是否相差1以内，大于1就更改 isBalanced 为false\n    dfs(pRoot)\n    \n    return isBalanced // 返回结果\n    \n    // 深度遍历，获取每一层的高度\n    function dfs(root){\n        // 出口\n        if(!root) return 0 // null的高度默认为0\n        \n        let lval = dfs(root.left)\n        let rval = dfs(root.right)\n        \n        if(Math.abs(lval - rval) &gt; 1){\n            isBalanced = false\n        }\n        \n        return Math.max(lval, rval) + 1\n    }\n    \n}\n</code></pre>\n<p>时间复杂度：O(N)。N为树的节点个数。最差情况下需要遍历所有节点。</p>\n<p>空间复杂度：O(N)。若树退化成了链表，则递归深度为节点的个数，需要用到O(N)的栈空间。</p>\n<h3>代码2 优化代码1，如果在某次判断得出已经不属于平衡二叉树了，让递归提前返回，无需再继续比较其它节点</h3>\n<pre><code class=\"language-js\">/*\n题目要求不用考虑是否是排序的二叉树，只考虑平衡性\n平衡二叉树：左子树与右子树的高度差绝对值小于等于1，同时左子树与右子树都是平衡二叉树。\n其实与求二叉树的深度是一样的，只不过是在求得过程中比较左子树与右子树的高度差绝对值是否&lt;1\n*/\nfunction IsBalanced_Solution(pRoot)\n{\n    let isBalanced = true // 默认为true\n    // 判断\n    dfs(pRoot)\n    \n    return isBalanced\n    \n    // 深度遍历，获取每一层的高度\n    function dfs(root){\n        // 出口\n        if(!root) return 0 // null的高度默认为0\n        \n        let lval = dfs(root.left)\n        if(lval === -1) return -1 // 提前返回\n        let rval = dfs(root.right)\n        if(rval === -1) return -1 // 提前返回\n        \n        if(Math.abs(lval - rval) &gt; 1){\n            isBalanced = false // // 不是平衡树\n            // 优化，增加标识 -1 ，已经不满足了，提前返回结果\n            return -1\n        }\n        return Math.max(lval, rval) + 1\n    }\n}\n</code></pre>\n<p>时间复杂度：O(N)。N为树的节点个数。最差情况下需要遍历所有节点。</p>\n<p>空间复杂度：O(N)。若树退化成了链表，则递归深度为节点的个数，需要用到O(N)的栈空间。</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222?tpId=13&amp;tqId=23250&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\">JZ79 判断是不是平衡二叉树</a></p>\n', '2021-12-18 11:20:56', '2021-12-18 11:20:56');
INSERT INTO `t_blog` VALUES ('8399b160-5c8b-11ec-96d5-7933aca11ca0', 'let和const', 'let和const的出现，比相较于远古时期的var出现了下面的几点变化\n\n1. 不允许重复声明\n2. 不存在变量提升\n3. 出现了块级作用域\n4. 暂时性死区', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 3, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>let和const的出现，比相较于远古时期的var出现了下面的几点变化</p>\n<ol>\n<li>不允许重复声明</li>\n<li>不存在变量提升</li>\n<li>出现了块级作用域</li>\n<li>暂时性死区</li>\n</ol>\n<h2>不允许重复声明</h2>\n<pre><code class=\"language-js\">// 早期使用var 允许重复声明\nvar a = 123\nvar a = 456\nconsole.log(a) //456\n</code></pre>\n<pre><code class=\"language-js\">// 使用let后 不允许重复声明，会报错\nlet a = 123\nlet a = 456\nconsole.log(a) //SyntaxError: Identifier \'a\' has already been declared\n</code></pre>\n<h2>不存在变量提升</h2>\n<pre><code class=\"language-js\">// 早期的var 会变量提升\nconsole.log(a) // undefined 即使还没声明 a，就已经可以打印了\nvar a = 10\nconsole.log(a) // 10\n</code></pre>\n<p></p>\n<pre><code class=\"language-js\">// 上面的例子类似于\nvar a // 变量被提升了\nconsole.log(a) // undefined\na= 10\nconsole.log(a) // 10\n</code></pre>\n<p></p>\n<pre><code class=\"language-js\">// 使用let就不会提升了\nconsole.log(a) // 直接报错  ReferenceError: Cannot access \'a\' before initialization\nlet a = 10\n</code></pre>\n<h2>块级作用域</h2>\n<p>在还没出现let和const时，只有全局作用域和函数作用域，没有块级作用域的概念，比如</p>\n<pre><code class=\"language-js\">var a = 10\nif(true) {\n    var a = 20\n}\nconsole.log(a) // 20\n/*\n因为没有块级作用域，a被重新赋值为了20\n*/\n</code></pre>\n<p></p>\n<pre><code class=\"language-js\">// 使用let或者const之后 出现了块级作用域\nlet a = 10\nif(true) {\n    let a = 20\n}\nconsole.log(a) // 10\n/*\n有了块级作用域，只会访问到外部的变量 a\n*/\n</code></pre>\n<h2>暂时性死区</h2>\n<p>在没有let或者const之前，直接不使用任何修饰符赋值一个变量时，会被挂载到全局对象上，比如：</p>\n<pre><code class=\"language-js\">a = 10 // 没有使用任何修饰符，会直接挂载到全局\nconsole.log(a) // 10\nvar a = 20 \nconsole.log(a) // 20 使用var还能重新对它赋值\n</code></pre>\n<p></p>\n<pre><code class=\"language-js\">a = 10 // 会报错\n// 因为在这个区域内使用使用了let a，在声明a之前的部分，a是不可用的，称为a变量的“死区”\nlet a = 20\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>在ES6之前，js只有全局作用域和函数作用域的概念（也称局部作用域），ES6之后，随着<code>let和const</code>的出现，出现了块级作用域的概念。</li>\n<li>使用<code>let</code>和<code>const</code>触发块级作用域后，变量不会提升，不允许重复声明，变量只能在当前的代码块内部使用。</li>\n<li><code>var</code>和<code>let、const</code>的区别\n<ol>\n<li><code>var</code>有变量提升，允许重复声明，可以在声明前调用。（注意，<code>function</code>声明的函数也会提升，如果同时存在<code>var</code>和<code>function</code>，最终提升的效果是<code>var</code>的声明总会在<code>function</code>的上面）</li>\n<li><code>var</code>只有全局作用域和函数作用域的概念，那些花括号包裹的代码块，比如<code>{}</code>、<code>if(){}</code>、<code>for(){}</code>、<code>while(){}</code>，（除了<code>function</code>包裹的函数作用域外），<code>var</code>全都会无视它们，都会将变量的声明提升到花括号外面去</li>\n<li><code>let</code>和<code>const</code>不存在变量提升、不允许重复声明、不允许在声明之前调用。</li>\n<li>使用<code>let</code>和<code>const</code>声明的变量会触发块级作用域，即上面说的那些花括号<code>{}</code>包裹的变量，变量只能在当前块下面访问，外部是访问不到的。</li>\n<li><code>const</code>相较于<code>let</code>还是有点区别的，<code>const</code>一般用于声明常量，且在声明时必须初始化一个值，否则会报错，而一旦初始化值后，就不能再改变。<code>let</code>则可以先声明，等使用的时候再进行赋值，也可以声明时直接赋值。<code>let</code>声明的变量允许改变。</li>\n</ol>\n</li>\n</ol>\n<blockquote>\n<p>可以参考另外一篇文章：<a href=\"http://www.bnbiye.cn/#/articleDetail/544247d0-4b8b-11ec-96d5-7933aca11ca0\">js中的作用域</a></p>\n<p>已经对var、let、const做了更详细讲解</p>\n</blockquote>\n', '2021-12-14 11:11:21', '2021-12-14 11:13:11');
INSERT INTO `t_blog` VALUES ('8652d6f0-5f49-11ec-b395-6d1b1a7579ec', '二叉树中和为某一值的路径(一)', 'JZ82 二叉树中和为某一值的路径(一)', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 5, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112172248228.png\" alt=\"image-20211217224821135\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112172248181.png\" alt=\"image-20211217224839136\" /></p>\n<h2>代码</h2>\n<h3>代码1 深度优先遍历（DFS），计算每条路径总和</h3>\n<pre><code class=\"language-js\">/*\n深度优先遍历\nlog(root.val)\ndfs(root.left)\ndfs(root.right)\n\n采用深度优先遍历二叉树的路径节点，\n同时计算二叉树路径节点的数字之和，\n当到达叶子节点且路径的数字之和等于 sum 则说明二叉树中存在节点和为指定值的路径\n1、特殊情况：当二叉树为空，则返回 false\n2、遍历根节点的左右子树，记录根节点的数字之和 total\n当节点的左右子树均为空，且 total == sum，则返回 true\n3、递归 该节点的左右子树，做上述计算\n*/\nfunction hasPathSum( root ,  sum ) {\n    \n    if(!root) return false\n    \n    return preOrder(root, sum, 0)\n    \n    // 先序遍历二叉树 根左右 计算每条路径上节点的总和，返回true或false\n    // 传递一个 total 计算当前累加和\n    function preOrder(root, sum, total){\n        // 出口 都遍历完了，加和还没有与sum相等，返回false\n        if(!root) return false\n        \n        total += root.val\n        \n        // 当遍历到叶子节点时，正好累加和等于sum时，返回true\n        if(!root.left &amp;&amp; !root.right &amp;&amp; sum === total) return true\n        \n        // 否则的话继续遍历\n        return preOrder(root.left, sum, total) || preOrder(root.right, sum, total)\n    }\n    \n}\n</code></pre>\n<p>时间复杂度 O(N)：最坏的情况是递归每个结点，N为节点数<br />\n空间复杂度 O(1)：常数级开销。</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/508378c0823c423baa723ce448cbfd0c?tpId=13&amp;tqId=634&amp;ru=/practice/a861533d45854474ac791d90e447bafd&amp;qru=/ta/coding-interviews/question-ranking\">JZ82 二叉树中和为某一值的路径(一)</a></p>\n', '2021-12-17 22:56:33', '2021-12-17 22:56:33');
INSERT INTO `t_blog` VALUES ('87a08d30-3d8a-11ec-97a5-ef78eceb5d73', '阻塞渲染的CSS', '默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。', '-1', 2, 'https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 8, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。请务必精简您的 CSS，尽快提供它，并利用媒体类型和查询来解除对渲染的阻塞。</p>\n<p>在<a href=\"http://www.bnbiye.cn/#/articleDetail/3c9212f0-3d8a-11ec-97a5-ef78eceb5d73\">构建渲染树</a>中，我们看到关键渲染路径要求我们同时具有 DOM 和 CSSOM 才能构建渲染树。这会给性能造成严重影响: <strong>HTML 和 CSS 都是阻塞渲染的资源。</strong> HTML 显然是必需的，因为如果没有 DOM，我们就没有可渲染的内容，但 CSS 的必要性可能就不太明显。如果我们在 CSS 不阻塞渲染的情况下尝试渲染一个普通网页会怎样？</p>\n<h2>分析</h2>\n<ul>\n<li>默认情况下，CSS 被视为阻塞渲染的资源。</li>\n<li>我们可以通过媒体类型和媒体查询将一些 CSS 资源标记为不阻塞渲染。</li>\n<li>浏览器会下载所有 CSS 资源，无论阻塞还是不阻塞。</li>\n</ul>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041746582.png\" alt=\"image-20211104174658480\" /></p>\n<p>上例展示了纽约时报网站使用和不使用 CSS 的显示效果，它证明了为何要在 CSS 准备就绪之前阻塞渲染，---没有 CSS 的网页实际上无法使用。右侧的情况通常称为“内容样式短暂失效”(FOUC)。浏览器将阻塞渲染，直至 DOM 和 CSSOM 全都准备就绪。</p>\n<p><em><strong>CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</strong></em></p>\n<p>不过，如果我们有一些 CSS 样式只在特定条件下（例如显示网页或将网页投影到大型显示器上时）使用，又该如何？如果这些资源不阻塞渲染，该有多好。</p>\n<p>我们可以通过 CSS“媒体类型”和“媒体查询”来解决这类用例:</p>\n<pre><code class=\"language-css\">&lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n&lt;link href=&quot;print.css&quot; rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;\n&lt;link href=&quot;other.css&quot; rel=&quot;stylesheet&quot; media=&quot;(min-width: 40em)&quot;&gt;\n</code></pre>\n<p><a href=\"https://developers.google.com/web/fundamentals/design-and-ux/responsive/#use-css-media-queries-for-responsiveness\">媒体查询</a>由媒体类型以及零个或多个检查特定媒体特征状况的表达式组成。例如，上面的第一个样式表声明未提供任何媒体类型或查询，因此它适用于所有情况，也就是说，它始终会阻塞渲染。第二个样式表则不然，它只在打印内容时适用---或许您想重新安排布局、更改字体等等，因此在网页首次加载时，该样式表不需要阻塞渲染。最后，最后一个样式表声明提供由浏览器执行的“媒体查询”: 符合条件时，浏览器将阻塞渲染，直至样式表下载并处理完毕。</p>\n<p>通过使用媒体查询，我们可以根据特定用例（比如显示或打印），也可以根据动态情况（比如屏幕方向变化、尺寸调整事件等）定制外观。<strong>声明您的样式表资产时，请密切注意媒体类型和查询，因为它们将严重影响关键渲染路径的性能。</strong></p>\n<p>让我们考虑下面这些实例:</p>\n<pre><code class=\"language-html\">&lt;link href=&quot;style.css&quot;    rel=&quot;stylesheet&quot;&gt;\n&lt;link href=&quot;style.css&quot;    rel=&quot;stylesheet&quot; media=&quot;all&quot;&gt;\n&lt;link href=&quot;portrait.css&quot; rel=&quot;stylesheet&quot; media=&quot;orientation:portrait&quot;&gt;\n&lt;link href=&quot;print.css&quot;    rel=&quot;stylesheet&quot; media=&quot;print&quot;&gt;\n</code></pre>\n<ul>\n<li>第一个声明阻塞渲染，适用于所有情况。</li>\n<li>第二个声明同样阻塞渲染: “all”是默认类型，如果您不指定任何类型，则隐式设置为“all”。因此，第一个声明和第二个声明实际上是等效的。</li>\n<li>第三个声明具有动态媒体查询，将在网页加载时计算。根据网页加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞渲染。</li>\n<li>最后一个声明只在打印网页时应用，因此网页首次在浏览器中加载时，它不会阻塞渲染。</li>\n</ul>\n<p>最后，请注意“阻塞渲染”仅是指浏览器是否需要暂停网页的首次渲染，直至该资源准备就绪。无论哪一种情况，浏览器仍会下载 CSS 资产，只不过不阻塞渲染的资源优先级较低罢了。</p>\n<p>下一篇： <a href=\"http://www.bnbiye.cn/#/articleDetail/d12707e0-3d8a-11ec-97a5-ef78eceb5d73\">使用JavaScript添加交互</a></p>\n', '2021-11-05 00:16:13', '2021-11-05 09:00:33');
INSERT INTO `t_blog` VALUES ('87ae3b80-5f39-11ec-b395-6d1b1a7579ec', '二叉搜索树的后序遍历序列', 'JZ33 二叉搜索树的后序遍历序列', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 2, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112172047385.png\" alt=\"image-20211217204727294\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112172047429.png\" alt=\"image-20211217204750377\" /></p>\n<h2>代码</h2>\n<h3>代码1 递归（分治）</h3>\n<pre><code class=\"language-js\">/*\n分治，递归判断\n判断数组是否是后序遍历的二叉搜索树，后序遍历（左右根），根在最后\n二叉搜索树满足 左节点的值 &lt; 根节点的值 &lt; 右节点的值\n所以可以每次从数组的末尾拿一个根出来，然后根据根的大小，把数组前面的值分为左子树和右子树\n然后继续重复这样的操作，当右子树的值小于根节点时，那就不符合二叉搜索树\n*/\n\nfunction VerifySquenceOfBST(sequence)\n{\n    // 题目要求空树不是二叉搜索树\n    if(!sequence || sequence.length === 0) return false\n    \n    // 分治求解\n    return vertify(sequence, 0, sequence.length - 1 )\n    \n    \n    // 用来递归判断是否符合二叉搜索树 返回true或false\n    // start表示起始位置\n    // rootIndex表示根所在的位置索引\n    function vertify(sequence, start, rootIndex) {\n        // 出口\n        // 当rootIndex &lt;= start 表示剩一个节点，校验到最后了\n        if(rootIndex &lt;= start) return true\n        \n        // 开始分治，根据末尾的根节点，找左、右子树\n        let i = 0 // 左右子树的分割点的索引\n        for(; i &lt; rootIndex; i++ ){\n            // 当找到一个比根还大的值时，说明是右子树的开始，停止循环，记录这个位置\n            if(sequence[i] &gt; sequence[rootIndex]) {\n                break;\n            }\n        }\n        \n        // 在右子树中，判断有没有比根节点还小的值，如果有，那就不是二叉搜索树，返回false\n        for(let j = i; j &lt; rootIndex; j++){\n            if(sequence[j] &lt; sequence[rootIndex]){\n                return false\n            }\n        }\n        \n        \n        // 如果上面这一次循环都符合，那继续缩小规模，分治\n        let leftTree = sequence.slice(0, i)\n        let rightTree = sequence.slice(i, sequence.length-1)\n        return vertify(leftTree, 0, leftTree.length-1) &amp;&amp; vertify(rightTree, 0, rightTree.length-1)\n    }\n}\n</code></pre>\n<p>时间复杂度为O(N^2)：当二叉搜索树是一个链表时，递归N次，每次也需要比较N次，所以时间复杂度最坏情况为<code>O(N^2)</code></p>\n<p>空间复杂度O(n),：当树为链式结构时, 递归深度为n</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd?tpId=13&amp;tqId=23289&amp;ru=/practice/7fe2212963db4790b57431d9ed259701&amp;qru=/ta/coding-interviews/question-ranking\">JZ33 二叉搜索树的后序遍历序列</a></p>\n', '2021-12-17 21:02:03', '2021-12-17 21:02:03');
INSERT INTO `t_blog` VALUES ('87ae8880-5e5b-11ec-b395-6d1b1a7579ec', '二叉树的深度', 'JZ55 二叉树的深度', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 7, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112161755244.png\" alt=\"image-20211216175535161\" /></p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：\n{1,2,3,4,5,#,6,#,#,7}\n返回值：\n4\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：\n{}\n返回值：\n0\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 深度遍历（分治法，先左后右 挨个遍历一遍，递归）</h3>\n<pre><code class=\"language-js\">/*\n深度遍历，分治法：\n求一个规模为n的问题，先求左边规模大约为n/2的问题，再求右边规模大约为n/2的问题，\n然后合并左边、右边的解，从而求得最终解。\n1. 求 pro(left, rigth) -&gt; int\n2. 先求pro(left, (left+right)/2) -&gt; lval\n3. 再求pro((left+right)/2 + 1, right) -&gt; rval\n4. merge(lval, rval) -&gt; result\n\n最终结果为 max( 头结点左子树的最大深度, 头结点右子树的最大深度)+1\n*/\nfunction TreeDepth(pRoot)\n{\n    if(!pRoot) return 0\n    \n    let lval = TreeDepth(pRoot.left)\n    let rval = TreeDepth(pRoot.right)\n    \n    return Math.max(lval, rval) + 1\n    \n}\n</code></pre>\n<p>时间复杂度为 O(n)：n为遍历的节点数量，计算树的深度时所需要遍历的所有节点</p>\n<p>空间复杂度为O(n)：n为递归时需要开辟的额外栈空间，用于递归方法堆栈</p>\n<h3>代码2 层次遍历（使用队列辅助，先入先出，一层一层的找）</h3>\n<pre><code class=\"language-js\">/*\n层次遍历法：一层一层的遍历，需要使用个队列辅助一下，js中使用数组模拟一下\n1. 初始化：一个队列queue&lt;treenode*&gt; q， 将root节点入队列q\n2. 如果队列不空，做如下操作：\n3. 弹出队列头，保存为node，将node的左右非空孩子加入队列\n4. 做2,3步骤，知道队列为空\n*/\nfunction TreeDepth(pRoot)\n{\n    if(!pRoot) return null\n    // 使用数组模拟一个队列\n    let queue = []\n    // 根节点入队\n    queue.push(pRoot)\n    \n    let height = 0 // 记录深度\n    \n    // 开始层次遍历\n    while(queue.length &gt; 0){ // 一层一层的遍历\n        // 先获取到当前队列中有几个节点（本层节点数）\n        let size = queue.length\n        while(size !== 0) { // 遍历该层的节点，没遍历一个 就出队一个，遍历的同时，把他们下一层的节点入队\n            // 出队（先入先出，因为之前是push进的，所以使用shift出队）\n            let currentNode = queue.shift()\n            if(currentNode.left){ // 入队\n                queue.push(currentNode.left)\n            }\n            if(currentNode.right){ // 入队\n                queue.push(currentNode.right)\n            }\n            \n            //每循环一次，当前层的节点数就减一\n            size--\n        }\n        // 里层的循环每次执行完，就表示走完了一层，深度+1\n        height++\n    }\n    \n    return height\n}\n</code></pre>\n<p>时间复杂度O(n)：n是遍历节点的个数。</p>\n<p>空间复杂度O(n)：队列占用的空间。</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b?tpId=13&amp;tqId=23294&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\">JZ55 二叉树的深度</a></p>\n', '2021-12-16 18:32:55', '2021-12-16 18:33:19');
INSERT INTO `t_blog` VALUES ('87ecdb40-4e5b-11ec-96d5-7933aca11ca0', '\"new Function\" 语法', 'js中除了使用`function`关键字创建函数外，还有一种很少见的方法，`new Function`，但是很少使用，不过也需要了解一下。', '-1', 2, 'https://zh.javascript.info/new-function', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 5, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>js中除了使用<code>function</code>关键字创建函数外，还有一种很少见的方法，<code>new Function</code>，但是很少使用，不过也需要了解一下。</p>\n<h2>语法</h2>\n<p>创建函数的语法：</p>\n<pre><code class=\"language-js\">let func = new Function ([arg1, arg2, ...argN], functionBody);\n</code></pre>\n<p>该函数是通过使用参数 <code>arg1...argN</code> 和给定的 <code>functionBody</code> 创建的。</p>\n<p>下面这个例子可以帮助你理解创建语法。这是一个带有两个参数的函数：</p>\n<pre><code class=\"language-js\">let sum = new Function(\'a\', \'b\', \'return a + b\');\n\nconsole.log(sum(1, 2)); // 3\n</code></pre>\n<p>这里有一个没有参数的函数，只有函数体：</p>\n<pre><code class=\"language-js\">let sayHi = new Function(\'console.log(&quot;Hello&quot;)\');\n\nsayHi(); // Hello\n</code></pre>\n<p>与我们已知的其他方法相比，这种方法最大的不同在于，它实际上是通过运行时通过参数传递过来的字符串创建的。</p>\n<p>以前的所有声明方法都需要我们 —— 程序员，在脚本中编写函数的代码。</p>\n<p>但是 <code>new Function</code> 允许我们将任意字符串变为函数。例如，我们可以从服务器接收一个新的函数并执行它：</p>\n<pre><code class=\"language-js\">let str = ... 动态地接收来自服务器的代码 ...\n\nlet func = new Function(str);\nfunc();\n</code></pre>\n<p>使用 <code>new Function</code> 创建函数的应用场景非常特殊，比如在复杂的 Web 应用程序中，我们需要从服务器获取代码或者动态地从模板编译函数时才会使用。</p>\n<h2>闭包</h2>\n<p>我们在学习闭包时，知道了词法环境的概念，js中，每次创建函数时，引擎默认都会使用<code>[[Environment]]</code>记录当前函数创建的外部环境。但是如果我们使用 <code>new Function</code> 创建一个函数，那么该函数的 <code>[[Environment]]</code> 并不指向当前的词法环境，而是指向全局环境。所以，记得当时我们说，js中的所有函数都是天然闭包的，不过排除了<code>new Function</code>的情况。</p>\n<p>如果我们使用 <code>new Function</code> 创建一个函数，那么该函数的 <code>[[Environment]]</code> 并不指向当前的词法环境，而是指向全局环境。</p>\n<p>因此，此类函数无法访问外部（outer）变量，只能访问全局变量。</p>\n<pre><code class=\"language-js\">function getFunc() {\n    let value = &quot;test&quot;;\n\n    let func = new Function(\'console.log(value)\');\n\n    return func;\n}\n\ngetFunc()(); // ReferenceError: value is not defined\n</code></pre>\n<p>将其与常规行为进行比较：</p>\n<pre><code class=\"language-js\">function getFunc() {\n    let value = &quot;test&quot;;\n    let func = function () { console.log(value); };\n    return func;\n}\n\ngetFunc()(); // &quot;test&quot;，从 getFunc 的词法环境中获取的\n</code></pre>\n<p><code>new Function</code> 的这种特性看起来有点奇怪，不过在实际中却非常实用。</p>\n<p>想象以下我们必须通过一个字符串来创建一个函数。在编写脚本时我们不会知道该函数的代码（这也就是为什么我们不用常规方法创建函数），但在执行过程中会知道了。我们可能会从服务器或其他来源获取它。</p>\n<p>例如，如果一个函数有 <code>let userName</code>，压缩程序会把它替换为 <code>let a</code>（如果 a 已被占用了，那就使用其他字符），剩余的局部变量也会被进行类似的替换。一般来说这样的替换是安全的，毕竟这些变量是函数内的局部变量，函数外的任何东西都无法访问它。在函数内部，压缩程序会替换所有使用了使用了这些变量的代码。压缩程序很聪明，它会分析代码的结构，而不是呆板地查找然后替换，因此它不会“破坏”你的程序。</p>\n<p>但是在这种情况下，如果使 <code>new Function</code> 可以访问自身函数以外的变量，它也很有可能无法找到重命名的 <code>userName</code>，这是因为新函数的创建发生在代码压缩以后，变量名已经被替换了。</p>\n<p><strong>即使我们可以在 <code>new Function</code> 中访问外部词法环境，我们也会受挫于压缩程序。</strong></p>\n<p>此外，这样的代码在架构上很差并且容易出错。</p>\n<p>当我们需要向 <code>new Function</code> 创建出的新函数传递数据时，我们必须显式地通过参数进行传递。</p>\n<h2>总结</h2>\n<p>语法：</p>\n<pre><code class=\"language-js\">let func = new Function ([arg1, arg2, ...argN], functionBody);\n</code></pre>\n<p>由于历史原因，参数也可以按逗号分隔符的形式给出。</p>\n<p>以下三种声明的含义相同：</p>\n<pre><code class=\"language-js\">new Function(\'a\', \'b\', \'return a + b\'); // 基础语法\nnew Function(\'a,b\', \'return a + b\'); // 逗号分隔\nnew Function(\'a , b\', \'return a + b\'); // 逗号和空格分隔\n</code></pre>\n<p>使用 <code>new Function</code> 创建的函数，它的 <code>[[Environment]]</code> 指向全局词法环境，而不是函数所在的外部词法环境。因此，我们不能在 <code>new Function</code> 中直接使用外部变量。不过这样是好事，这有助于降低我们代码出错的可能。并且，从代码架构上讲，显式地使用参数传值是一种更好的方法，并且避免了与使用压缩程序而产生冲突的问题。</p>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/new-function\">https://zh.javascript.info/new-function</a></p>\n', '2021-11-26 09:52:37', '2021-11-26 09:52:37');
INSERT INTO `t_blog` VALUES ('8b9cc6b0-57d9-11ec-96d5-7933aca11ca0', '灾难性回溯', '有些正则表达式看上去很简单，但是执行起来耗时非常非常非常长，甚至会导致 JavaScript 引擎「挂起」。', '-1', 2, 'https://zh.javascript.info/regexp-catastrophic-backtracking#li-zi', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 2, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>有些正则表达式看上去很简单，但是执行起来耗时非常非常非常长，甚至会导致 JavaScript 引擎「挂起」。</p>\n<p>开发者们很容易一不小心就写出这类正则表达式，所以我们迟早会面对这种意外问题。</p>\n<p>典型的症状就是 —— 一个正则表达式有时能正常工作，但对于某些特定的字符串就会消耗 100% 的 CPU 算力，出现“挂起”现象。</p>\n<p>在这种情况下，Web 浏览器会建议杀死脚本并重新载入页面。这显然不是我们愿意看到的。</p>\n<p>在服务器端 JavaScript 中，在使用这种正则表达式处理用户数据时可能会引发程序漏洞。</p>\n<h2>一个小例子</h2>\n<p>假设，我们现在有一个字符串，我们想检查其中是否包含一些单词 <code>\\w+</code>，允许字符后跟着可选的空格符 <code>\\s?</code>。</p>\n<p>我们使用一个这样的正则 <code>^(\\w+\\s?)*$</code>，它指定了 0 个或更多个此类的字符。</p>\n<p>我们运行一下：</p>\n<pre><code class=\"language-js\">let regexp = /^(\\w+\\s?)*$/;\n\nconsole.log(regexp.test(&quot;A good string&quot;)); // true\nconsole.log(regexp.test(&quot;Bad characters: $@#&quot;)); // false\n</code></pre>\n<p>这似乎能正常工作。结果是正确的。但是在特定的字符串上，它会消耗很多时间。它耗时太久以至于让 CPU 会跑满 100% 负载，导致 JavaScript 引擎「挂起」。</p>\n<p>如果你运行下面这个例子，由于 JavaScript 会进入「挂起」状态，因此你可能什么结果都看不到。此时浏览器会停止对事件的响应，UI 也会停止运作。一段时间之后浏览器会建议重新载入页面。所以请谨慎对待：</p>\n<pre><code class=\"language-js\">let regexp = /^(\\w+\\s?)*$/;\nlet str = &quot;An input string that takes a long time or even makes this regexp to hang!&quot;;\n\n// 会耗费大量时间\nconsole.log( regexp.test(str) );\n</code></pre>\n<p>有些正则引擎能够处理好这种查询，但大多数引擎对此都无能为力。</p>\n<h2>简化的例子</h2>\n<p>问题在哪？为何正则表达式会「挂起」？</p>\n<p>为了理解它，我们来简化一下例子：移除空格符 <code>\\s?</code>，使其成为 <code>^(\\w+)*$</code>。</p>\n<p>同时为了让问题更显著，再用 <code>\\d</code> 替换掉 <code>\\w</code>。这个新的正则表达式执行时仍然会挂起，比如：</p>\n<pre><code class=\"language-js\">let regexp = /^(\\d+)*$/;\n\nlet str = &quot;012345678901234567890123456789!&quot;;\n\n// 会耗费大量时间\nconsole.log(regexp.test(str));\n</code></pre>\n<p>所以正则到底哪里出了问题？</p>\n<p>首先，有人可能发现了这个正则 <code>(\\d+)*</code> 有点奇怪，量词 <code>*</code> 有点画蛇添足。如果我们要匹配数字，那我们可以使用 <code>\\d+</code>。</p>\n<p>实际上，正则表达式是非常死板、机械化的。造成它运行缓慢的原因和上面我们看到的那样，所以让我们来理解它运作过程，然后问题的原因就会显而易见了。</p>\n<h3>回溯分析</h3>\n<p>这里使用<code>123456789!</code>做例子（简写方便举例），正则表达式还是之前的<code>/^(\\d+)*$/</code>。</p>\n<p>当在<code>123456789!</code>中查询 <code>^(\\d+)*$</code> 时到底发生了什么，要耗时这么久呢？</p>\n<ol>\n<li>\n<p>首先，正则引擎尝试查一个数字 <code>\\d+</code>。加号 <code>+</code> 默认为贪婪模式，所以它囊括/消耗（consume）了所有数字：</p>\n<pre><code class=\"language-js\">\\d+.......\n(123456789)z\n</code></pre>\n<p>然后它尝试应用星号量词，但是此时已经没有更多数字了，所以星号匹配不到任何东西。</p>\n<p>模式中接下来的 <code>$</code> 匹配字符串的结束，但是我们例子的文字中有 <code>!</code>，所以匹配失败，没有匹配结果：</p>\n<pre><code class=\"language-js\">X\n\\d+........$\n(123456789)!\n</code></pre>\n</li>\n<li>\n<p>由于没有匹配结果，贪婪量词 <code>+</code> 的重复匹配次数会减一，并往前回溯一个字符。</p>\n<p>现在 <code>\\d+</code> 会匹配除了最后一个数字之外的所有数字：</p>\n<pre><code class=\"language-js\">\\d+.......\n(12345678)9!\n</code></pre>\n</li>\n<li>\n<p>然后引擎尝试从新位置 (<code>9</code>) 继续搜索。</p>\n<p>星号 <code>(\\d+)*</code> 可以成功应用 – 它匹配到了数字 <code>9</code> ：</p>\n<pre><code class=\"language-js\">\\d+.......\\d+\n(12345678)(9)!\n</code></pre>\n<p>引擎再次去尝试匹配 <code>$</code>，但是失败了，因为它遇到了 <code>!</code>：</p>\n<pre><code class=\"language-js\">X\n\\d+.......\\d+\n(12345678)(9)z\n</code></pre>\n</li>\n<li>\n<p>没有匹配结果，所以引擎继续回溯，减少重复匹配次数。回溯的运行过程基本上是这样的：最后一个贪婪量词逐渐减少重复匹配次数，然后前一个贪婪量词再减少重复匹配次数，以此类推。</p>\n<p>它会尝试所有可能的排列组合，这里是他们的例子：</p>\n<p>第一串数字 <code>\\d+</code> 有 7 位数，后面跟着一串 2 位数的数字：</p>\n<pre><code class=\"language-js\">X\n\\d+......\\d+\n(1234567)(89)!\n</code></pre>\n<p>第一串数字有 7 位数，后面跟着两串数字，每串数字各有 1 位数：</p>\n<pre><code class=\"language-js\">X\n\\d+......\\d+\\d+\n(1234567)(8)(9)!\n</code></pre>\n<p>第一串数字有 6 位数，后面跟着一串 3 位数的数字：</p>\n<pre><code class=\"language-js\">X\n\\d+.......\\d+\n(123456)(789)!\n</code></pre>\n<p>第一串数字有 6 位数，后面跟着两串数字：</p>\n<pre><code class=\"language-js\">X\n\\d+.....\\d+ \\d+\n(123456)(78)(9)!\n</code></pre>\n<p>……以此类推。</p>\n</li>\n</ol>\n<p>像 <code>123456789</code> 这样一串数字，分割成多个数的话有好几种分割方式。准确的说，如果这数字长度是 <code>n</code> ，则共有  2^n^-1 种方式去分割它。</p>\n<p>假设 <code>n=20</code>，那么就有差不多一百万种排列组合，假设 <code>n=30</code>，那就得再乘上一千倍。正因为要尝试每种排列组合，所以才导致会消耗这么多时间。</p>\n<p>那我们该怎么办？</p>\n<p>我们应转而使用懒惰模式吗？</p>\n<p>不幸的是，这没用：如果我们用 <code>\\d+?</code> 去替代 <code>\\d+</code>，它还是会挂起。排列组合的顺序会变化，但是总数不变。</p>\n<p>有些正则表达式引擎应经过严密的测试，并自带一种能够避免遍历所有排列组合的有限自动机来优化速度。但并不是所有引擎能够做到，也不是在所有场合下都有效果。</p>\n<h2>回到字符和字符串</h2>\n<p>在我们第一个例子中，当我们用 <code>^(\\w+\\s?)*$</code> 这种模式在字符串 <code>An input that hangs!</code> 中查找字符时，也遇到了相同的问题。</p>\n<p>原因是 <code>\\w+</code> 可以用来表示一个或多个字符：</p>\n<pre><code class=\"language-js\">(input)\n(inpu)(t)\n(inp)(u)(t)\n(in)(p)(ut)\n...\n</code></pre>\n<p>对于我们人类来说，很显然它们无法匹配成功，因为例子中的字符串以感叹号 <code>!</code> 结尾，然而正则表达式期望在末尾有一个词语式字符 <code>\\w</code> 或者空格 <code>\\s</code> 来结尾。正则引擎理解不了这种状况。</p>\n<p>它尝试了所有 <code>(\\w+\\s?)*</code> 的排列组合试图去囊括整个字符串，包含了带空格 <code>(\\w+\\s)*</code> 的情形和不带空格 <code>(\\w+)*</code> 的情形（因为 <code>\\s?</code> 是可选的）。由于各种排列组合的数量太多了，所以耗费了大量时间去查询。</p>\n<h2>如何解决问题？</h2>\n<p>主要有 2 种解决方法。</p>\n<p>第一种去试着减少各种排列组合的数量。</p>\n<p>我们用把正则重写成 <code>^(\\w+\\s)*\\w*</code> – 此处我们会查找后面跟着一个空格的、任意数量的单字字符 <code>(\\w+\\s)*</code>，然后跟着一个（可选的）单字字符 <code>\\w*</code>。</p>\n<p>这个正则表达式在查询效果上等同于之前那个（查找的内容是相同的），运行起来也没问题：</p>\n<pre><code class=\"language-js\">let regexp = /^(\\w+\\s)*\\w*$/;\nlet str = &quot;An input string that takes a long time or even makes this regex to hang!&quot;;\n\nconsole.log(regexp.test(str)); // false\n</code></pre>\n<p>为什么问题消失了？</p>\n<p>现在星号 <code>*</code> 跟在 <code>\\w+\\s</code> 后面，而不是 <code>\\w+\\s?</code> 后面。这意味着它无法匹配一个拥有多个连续单字字符串 <code>\\w+</code> 的单词，也就省下了原本去尝试这些排列组合的时间。</p>\n<p>举个例子，之前那个模式 <code>(\\w+\\s?)*</code> 可能以两个 <code>\\w+</code> 的方式来匹配单词 <code>string</code>：</p>\n<pre><code class=\"language-js\">\\w+\\w+\nstring\n</code></pre>\n<p>之前那个模式<code>/^(\\w+\\s?)*$/</code>，由于存在可选的 <code>\\s</code>，它允许 <code>\\w+</code>、<code>\\w+\\s</code> 和 <code>\\w+\\w+</code> 等等的变体形式。</p>\n<p>我们重写之后的 <code>(\\w+\\s)*</code> 就不存在这些情况：它可能会是 <code>\\w+\\s</code> 或者 <code>\\w+\\s\\w+\\s</code>，但不可能是 <code>\\w+\\w+</code>。所以总体上，排列组合的可能性大大减少了。</p>\n<h2>防止回溯</h2>\n<p>有时候重写正则会比较麻烦，而且要推敲如何重写正则恐怕也并非易事。</p>\n<p>另一种思路是禁止量词的回溯。</p>\n<p>有些正则表达式我们人眼一看就知道无法匹配成功，但正则引擎还是会硬去尝试很多它的排列组合。</p>\n<p>比如，正则 <code>(\\d+)*$</code> 中 <code>+</code> 对于我们人类来说很明显不应去回溯，就算我们用两个独立的 <code>\\d+\\d+</code> 去替换一个 <code>\\d+</code>，也是根本没作用的：</p>\n<pre><code class=\"language-js\">\\d+........\n(123456789)!\n\n\\d+...\\d+....\n(1234)(56789)!\n</code></pre>\n<p>原先的那个例子 <code>^(\\w+\\s?)*$</code> 中我们可能希望禁止在 <code>\\w+</code> 这里去进行回溯。逻辑是： <code>\\w+</code> 应当尽可能多地去匹配一个完整的单词。在 <code>\\w+</code> 这里减少重复次数，然后将之进行分割，形成 <code>\\w+\\w+</code>，这类的做法没有任何意义。</p>\n<p>为此，现代正则表达式引擎支持占有型量词（Possessive Quantifiers）。它们就像贪婪量词一样，但是不会进行回溯（所以比一般的正则量词更简单）。</p>\n<p>它们也被成为“原子捕获分组（atomic capturing groups）” – 能够在括号内禁止回溯。</p>\n<p>不幸的是，JavaScript 并不支持它，但是仍有其他办法。</p>\n<h3>用前瞻视角解决问题</h3>\n<p>我们可以使用前瞻断言来防止回溯。</p>\n<p>在不进行回溯的前提下，我们用 <code>(?=(\\w+))\\1</code> 这个模式就可以尽可能多地重复匹配 <code>\\w</code>：</p>\n<p>来解读一下：</p>\n<ul>\n<li>前瞻断言 <code>?=</code> 从当前位置开始，向前查找最长的单词 <code>\\w+</code>。</li>\n<li>引擎默认不会去记录 <code>?=...</code> 括号中的内容。为了记录它们，所以我们把 <code>\\w+</code> 放入括号中，这样引擎会记录括号中的内容了。</li>\n<li>……然后用 <code>\\1</code> 来引用括号中的内容。</li>\n</ul>\n<p>它的逻辑是：我们先进行前瞻查找 – 如果有符合 <code>\\w+</code> 的单词，我们就可以用 <code>\\1</code> 来匹配。</p>\n<p>为什么？因为前瞻断言查找到一个单词 <code>\\w+</code>，将其作为一个整体，然后进行捕获形成 <code>\\1</code> 。所以我们最终实现了一种占有型加号 <code>+</code> 量词。它只将 <code>\\w+</code> 作为一个整体来捕获，而不会只捕获它的某一部分。</p>\n<p>例如，在单词 <code>JavaScript</code> 中不仅可以匹配 <code>Java</code>，而且可以忽略 <code>Script</code> ，匹配模式的其余部分。</p>\n<p>下面是 2 个模式的对比：</p>\n<pre><code class=\"language-js\">console.log(&quot;JavaScript&quot;.match(/\\w+Script/)); // [ \'JavaScript\', index: 0, input: \'JavaScript\', groups: undefined ]\nconsole.log(&quot;JavaScript&quot;.match(/(?=(\\w+))\\1Script/)); // null\n</code></pre>\n<ol>\n<li>第一个变体 <code>\\w+</code> 首先捕获整个 <code>JavaScript</code> 单词，然而接下来 <code>+</code> 会一个字一个字地进行回溯，试图匹配整个模式的其余部分，直到 <code>\\w+</code> 匹配到了 <code>Java</code> 时，它最终才匹配成功。</li>\n<li>第二个变体 <code>(?=(\\w+))</code> 前瞻查找并匹配整个单词 <code>JavaScript</code>，然后把整个单词作为一个整体包含进 <code>\\1</code> 中，所以在它后面就无法查找到 <code>Script</code> 了。</li>\n</ol>\n<p>当我们需要禁止 <code>+</code> 进行回溯的话，我们只要把 <code>(?=(\\w+))\\1</code> 中的 <code>\\w</code> 替换成更复杂的正则表达式就能实现了。</p>\n<p>我们现在用前瞻断言重写第一个例子中的正则来防止回溯吧：</p>\n<pre><code class=\"language-js\">let regexp = /^((?=(\\w+))\\2\\s?)*$/;\n\nconsole.log(regexp.test(&quot;A good string&quot;)); // true\n\nlet str = &quot;An input string that takes a long time or even makes this regex to hang!&quot;;\n\nconsole.log(regexp.test(str)); // false，执行得很快！\n</code></pre>\n<p>这里我们用 <code>\\2</code> 代替 <code>\\1</code>，因为这里附加了额外的外部括号。为了防止数字产生混淆，我们可以给括号命名，例如 <code>(?&lt;word&gt;\\w+)</code>。</p>\n<pre><code class=\"language-js\">// 括号被命名为 ?&lt;word&gt;，使用 \\k&lt;word&gt; 来引用\nlet regexp = /^((?=(?&lt;word&gt;\\w+))\\k&lt;word&gt;\\s?)*$/;\n\nlet str = &quot;An input string that takes a long time or even makes this regex to hang!&quot;;\n\nconsole.log(regexp.test(str)); // false\n\nconsole.log(regexp.test(&quot;A correct string&quot;)); // true\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>\n<p>正则表达式的量词<code>+、*、?</code>，默认都是贪婪匹配模式，会匹配尽可能多的字符。</p>\n</li>\n<li>\n<p>贪婪模式下，匹配后的字符串，如果不满足紧接着的正则规则，会进行回溯，比如：</p>\n<p><code>/^(\\d+)*$/</code>：这个正则表示，以数字为开头，然后尽可能多的匹配连续数字（这个正则是为了演示灾难性回溯硬写的，不用考虑合理性），这里面有两个贪婪量词<code>+ *</code></p>\n<ol>\n<li>\n<p>正好匹配的情况</p>\n<p>如下面这个例子，<code>\\d+</code>会尽可能多的匹配数字，所以匹配到了<code>0123456789</code>，然后使用贪婪量词<code>*</code>再次匹配捕获组1中的规则，没有可以匹配的字符了，然后匹配结尾符<code>$</code>，正好是结尾，所以就匹配成功了。这个字符串并没有发生回溯。</p>\n<pre><code class=\"language-js\">let str = \'0123456789\'\nlet reg = /^(\\d+)*$/\nconsole.log(reg.test(str)) // true\n</code></pre>\n</li>\n<li>\n<p>回溯的情况</p>\n<p>下面这种情况就会发生灾难性回溯，</p>\n<pre><code class=\"language-js\">let str = \'0123456789!\'\nlet reg = /^(\\d+)*$/\n\n// 如果字符串很长的话，会耗费大量时间，甚至可能挂起引擎\nconsole.log(reg.test(str)) // false\n</code></pre>\n<pre><code class=\"language-js\">let str = \'0123456789!\'\nlet reg = /^(\\d+)*$/\nconsole.log(reg.test(str)) // false\n\n// 会有各种匹配结果\n(0123456789)! // 不符合 开始第1次回溯 + 回溯\n(012345678)(9)! // 不符合 开始第2次回溯  + 回溯\n(01234567)(89)! // 不符合 开始第3次回溯  *回溯    \n(01234567)(8)(9)! // 不符合 开始第4次回溯  +回溯\n(0123456)(789)! // 不符合 开始第5次回溯  *回溯    \n(0123456)(78)(9)! // 不符合 开始第6次回溯  *回溯   \n(0123456)(7)(8)(9)! // 不符合 开始第7次回溯  +回溯      \n(012345)(6789)! // 不符合 开始第8次回溯  *回溯\n// ... 以此类推\n// 最后都不符合 所以返回false\n// 但是一旦 回溯的次数特别多时，引擎就会挂起，或者崩溃\n</code></pre>\n</li>\n<li>\n<p>避免灾难性回溯</p>\n<ol>\n<li>\n<p>减少回溯次数，比如上面的例子，<code>*</code>完全没有必要，我们把它删除掉，这样就少了很多回溯的次数。</p>\n<pre><code class=\"language-js\">let str = \'0123456789!\'\n// 减少回溯次数\nlet reg = /^\\d+$/\nconsole.log(reg.test(str)) // false\n</code></pre>\n</li>\n<li>\n<p>使用后瞻断言，来防止回溯，比如：</p>\n<pre><code class=\"language-js\">let str = \'0123456789!\'\n// 后瞻断言防止回溯\nlet reg = /^(?=(\\d+))\\1*$/\nconsole.log(reg.test(str)) // false\n</code></pre>\n<p>括号里的后瞻断言默认是不会进入到捕获组中的，所以可以再用括号包裹一下，就是例子中的<code>(\\d+)</code>，即<code>\\1</code>，被捕获组捕获到的字符串会记录在捕获组返回的结果数组中，并不会发生回溯，分析一下上面的例子</p>\n<pre><code class=\"language-js\">let str = \'0123456789!\'\nlet reg = /^(?=(\\d+))\\1*$/\nconsole.log(reg.test(str)) // false\n\n// 后瞻断言(?=(\\d+))捕获到了\n(0123456789) // 此时的\\1就是这一串字符串\n(^(0123456789)!) // 接着匹配 *，此时的* 会重复前面的\\1，因为只有一个!号了，所以没有匹配到\n(^(0123456789)!) // 接着匹配 $，此时的$ 会判断是否以前面的\\1为结尾，但是此时结尾是感叹号，没有匹配到，\n// 最终返回false 捕获组\\1中的结果并不会发生回溯\n</code></pre>\n<p>还可以结合命名组使用</p>\n<pre><code class=\"language-js\">let str = \'0123456789!\'\nlet reg = /^(?=(?&lt;number&gt;\\d+))\\k&lt;number&gt;*$/\nconsole.log(reg.test(str)) // false\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-catastrophic-backtracking#li-zi\">https://zh.javascript.info/regexp-catastrophic-backtracking#li-zi</a></p>\n', '2021-12-08 11:47:20', '2021-12-08 11:47:20');
INSERT INTO `t_blog` VALUES ('8bafda00-346d-11ec-a1da-59f2d55bf031', 'BFC', 'BFC创建了一块互不干扰的空间，外面的不会干扰到里面的，里面也不会干扰到外边的， 主要应用场景，外边距合并、清除浮动、两栏自适应...', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 3, 46, 1, 1, 2, 1, 'http://82.156.76.49:20517/upload/png/2021-10-24/a7c1ac50-346d-11ec-a1da-59f2d55bf031.png', '<p>创建了一块互不干扰的空间，外面的不会干扰到里面的，里面也不会干扰到外边的，</p>\n<p>主要应用场景，外边距合并、清除浮动、两栏自适应</p>\n<h2>BFC布局规则</h2>\n<p>触发bfc的元素不会干扰外部的布局方式，外部也不会干扰到bfc内部，是一个独立的空间</p>\n<ul>\n<li>内部的box会在垂直方向一个接着一个排列</li>\n<li>同一个bfc的两个相邻box的margin会发生重叠</li>\n<li>bfc容器里的元素，都会与包含块（也就是容器）border的左边接触（对于从左往右的格式化，如果是从右往左的格式化就与右边接触），即使存在浮动的元素也是如此。</li>\n<li>bfc的区域不会与float box重叠</li>\n<li>bfc是页面上一个隔离的独立容器，容器里的子元素不会影响到外面的元素，反之如此</li>\n<li>计算bfc的高度时，浮动的元素也参与其中</li>\n</ul>\n<h2>哪些元素会生成BFC</h2>\n<ul>\n<li>根元素<code>html</code></li>\n<li><code>float</code>属性不为<code>none</code></li>\n<li><code>position</code>为<code>absolute</code>或<code>fixed</code></li>\n<li><code>display</code>为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、<code>inline-flex</code></li>\n<li><code>overflow</code>不为<code>visible</code></li>\n</ul>\n<h2>BFC的作用及原理</h2>\n<h3>自适应两栏布局</h3>\n<p>假设有两栏<code>aside</code>和<code>main</code>，把aside浮动到左侧，这时候aside就脱离了文档流，main元素根据bfc布局的第三条原则，会紧贴着容器的左侧排列（body是跟，跟本身就是一个BFC），所以最终渲染的效果，</p>\n<p>main元素会为顶到之前aside的位置，导致了main元素被盖在了aside的底部</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cfcaea6184e4c5cb7edadea63ea211b~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211024091731612.png\" /></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    body {\n        width: 300px;\n    }\n \n    .aside {\n        width: 100px;\n        height: 150px;\n        float: left;\n        background: #f66;\n    }\n \n    .main {\n        height: 200px;\n        background: #fcc;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>根据BFC布局的第四条规则，bfc区域不会与浮动的元素重叠，所以可以将main元素变成一个BFC快，实现自适应两栏布局</p>\n<pre><code class=\"language-css\">.main {\n    overflow: hidden;\n}\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/793cd0d4d0e949adbdc2b7fd7f32c325~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211024092148468.png\" /></p>\n<h3>清除内部浮动</h3>\n<p>根据BFC的第六条布局规则，计算BFC的高度时，浮动的元素也会参与计算，所以可以根据这条特性，解决子元素浮动，父元素高度塌陷问题。如下图，当父元素parent不是bfc块时，内部的child浮动后，导致了自己高度的塌陷</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96a1dc856f674ec9b8c470253ed6dc18~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211024092148468.png\" /></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    .parent {\n        border: 5px solid #fcc;\n        width: 300px;\n    }\n\n    .child {\n        border: 5px solid #f66;\n        width:100px;\n        height: 100px;\n        float: left;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;parent&quot;&gt;\n        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>当将父元素parent变为bfc块时，根据特性，浮动元素参加高度计算，变相的清除了浮动</p>\n<pre><code class=\"language-css\">.par {\n    overflow: hidden;\n}\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46f2f9a3390443e880ecf0ddf02e6271~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211024092148468.png\" /></p>\n<h3>防止外边距合并</h3>\n<p>同一个bfc块下，毗邻的两个元素的外边距会发生合并，如下有两个box块，最后发生外边距合并后，两个box相差了30px</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/757b0e5a921d4b6bb36cf5079781da1c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211024092148468.png\" /></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    .box {\n        margin: 20px 0 30px;\n        background-color: green;\n        width: 100px;\n        height: 100px;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>如何避免合并呢，让两个box不处于同一个bfc块下就好了，在第二个box加一个包裹wrapper，让wrapper变成一个bfc，那么两个box就处于两个bfc下了，就避免了外边距合并，代码改造如下</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    .box {\n        margin: 20px 0 30px;\n        background-color: green;\n        width: 100px;\n        height: 100px;\n    }\n    .wrapper {\n        overflow: hidden;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;wrapper&quot;&gt;\n        &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e270955f15dc4092a0a5600429b12040~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211024092148468.png\" /></p>\n<h2>总结</h2>\n<p>上述的所有例子都体现了BFC的第五条规则，bfc是一个独立的容器，里面和外面互不影响。</p>\n<p>因为<code>BFC</code>内部的元素和外部的元素绝对不会互相影响，因此， 当<code>BFC</code>外部存在浮动时，它不应该影响<code>BFC</code>内部Box的布局，<code>BFC</code>会通过变窄，而不与浮动有重叠。同样的，当<code>BFC</code>内部有浮动时，为了不影响外部元素的布局，<code>BFC</code>计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p>\n<p>参考：</p>\n<p><a href=\"https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html\">https://www.cnblogs.com/lhb25/p/inside-block-formatting-ontext.html</a></p>\n', '2021-10-24 09:56:04', '2021-12-09 21:54:56');
INSERT INTO `t_blog` VALUES ('8bb3bd10-5bea-11ec-96d5-7933aca11ca0', 'JSON的常用方法', 'JSON.stringfy和JSON.parse', '-1', 2, 'https://zh.javascript.info/json', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 1, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>假设我们有一个复杂的对象，我们希望将其转换为字符串，以通过网络发送，或者只是为了在日志中输出它。</p>\n<p>当然，这样的字符串应该包含所有重要的属性。</p>\n<p>我们可以像这样实现转换：</p>\n<pre><code class=\"language-js\">let user = {\n    name: &quot;John&quot;,\n    age: 30,\n\n    toString() {\n        return `{name: &quot;${this.name}&quot;, age: ${this.age}}`;\n    }\n};\n\nconsole.log(user.toString()); // {name: &quot;John&quot;, age: 30}\n</code></pre>\n<p>……但在开发过程中，会新增一些属性，旧的属性会被重命名和删除。每次更新这种 <code>toString</code> 都会非常痛苦。我们可以尝试遍历其中的属性，但是如果对象很复杂，并且在属性中嵌套了对象呢？我们也需要对它们进行转换。</p>\n<p>幸运的是，不需要编写代码来处理所有这些问题。这项任务已经解决了。</p>\n<h2>JSON.stringfy</h2>\n<p><a href=\"http://en.wikipedia.org/wiki/JSON\">JSON</a>（JavaScript Object Notation）是表示值和对象的通用格式。最初它是为 JavaScript 而创建的，但许多其他编程语言也有用于处理它的库。因此，当客户端使用 JavaScript 而服务器端是使用 Ruby/PHP/Java 等语言编写的时，使用 JSON 可以很容易地进行数据交换。</p>\n<p>JavaScript 提供了如下方法：</p>\n<ul>\n<li><code>JSON.stringify</code> 将对象转换为 JSON。</li>\n<li><code>JSON.parse</code> 将 JSON 转换回对象。</li>\n</ul>\n<h3>对象转换</h3>\n<p>例如，在这里我们 <code>JSON.stringify</code> 一个 <code>student</code> 对象：</p>\n<pre><code class=\"language-js\">let student = {\n    name: \'John\',\n    age: 30,\n    isAdmin: false,\n    courses: [\'html\', \'css\', \'js\'],\n    wife: null\n};\n\nlet json = JSON.stringify(student);\n\nconsole.log(typeof json); // string\n\nconsole.log(json);\n  /* JSON 编码的对象：\n{\n&quot;name&quot;: &quot;John&quot;,\n&quot;age&quot;: 30,\n&quot;isAdmin&quot;: false,\n&quot;courses&quot;: [&quot;html&quot;, &quot;css&quot;, &quot;js&quot;],\n&quot;wife&quot;: null\n}\n*/\n</code></pre>\n<p>方法 <code>JSON.stringify(student)</code> 接收对象并将其转换为字符串。</p>\n<p>得到的 <code>json</code> 字符串是一个被称为 <strong>JSON 编码（JSON-encoded）</strong> 或 <strong>序列化（serialized）</strong> 或 <strong>字符串化（stringified）</strong> 或 <strong>编组化（marshalled）</strong> 的对象。我们现在已经准备好通过有线发送它或将其放入普通数据存储。</p>\n<p>请注意，JSON 编码的对象与对象字面量有几个重要的区别：</p>\n<ul>\n<li>字符串使用双引号。JSON 中没有单引号或反引号。所以 <code>\'John\'</code> 被转换为 <code>&quot;John&quot;</code>。</li>\n<li>对象属性名称也是双引号的。这是强制性的。所以 <code>age:30</code> 被转换成 <code>&quot;age&quot;:30</code>。</li>\n</ul>\n<h3>原始值转换</h3>\n<p><code>JSON.stringify</code> 也可以应用于原始（primitive）数据类型。</p>\n<p>JSON 支持以下数据类型：</p>\n<ul>\n<li>Objects <code>{ ... }</code></li>\n<li>Arrays <code>[ ... ]</code></li>\n<li>Primitives：\n<ul>\n<li>strings，</li>\n<li>numbers，</li>\n<li>boolean values <code>true/false</code>，</li>\n<li><code>null</code>。</li>\n</ul>\n</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"language-js\">// 数字在 JSON 还是数字\nconsole.log( JSON.stringify(1) ) // 1\n\n// 字符串在 JSON 中还是字符串，只是被双引号扩起来\nconsole.log( JSON.stringify(\'test\') ) // &quot;test&quot;\n\nconsole.log( JSON.stringify(true) ); // true\n\nconsole.log( JSON.stringify([1, 2, 3]) ); // [1,2,3]\n</code></pre>\n<h3>无法转换的几个属性</h3>\n<p>JSON 是语言无关的纯数据规范，因此一些特定于 JavaScript 的对象属性会被 <code>JSON.stringify</code> 跳过。</p>\n<p>即：</p>\n<ul>\n<li>函数属性（方法）。</li>\n<li>Symbol 类型的属性。</li>\n<li>存储 <code>undefined</code> 的属性。</li>\n</ul>\n<pre><code class=\"language-js\">let user = {\n  sayHi() { // 被忽略\n    alert(&quot;Hello&quot;);\n  },\n  [Symbol(&quot;id&quot;)]: 123, // 被忽略\n  something: undefined // 被忽略\n};\n\nconsole.log( JSON.stringify(user) ); // {}（空对象）\n</code></pre>\n<h3>支持嵌套对象转换</h3>\n<p>JSON.stringfy 最棒的是支持嵌套对象转换，并且可以自动对其进行转换。</p>\n<pre><code class=\"language-js\">let meetup = {\n    title: &quot;Conference&quot;,\n    room: {\n        number: 23,\n        participants: [&quot;john&quot;, &quot;ann&quot;]\n    }\n};\n\nconsole.log(JSON.stringify(meetup));\n  /* 整个解构都被字符串化了\n{\n&quot;title&quot;:&quot;Conference&quot;,\n&quot;room&quot;:{&quot;number&quot;:23,&quot;participants&quot;:[&quot;john&quot;,&quot;ann&quot;]},\n}\n*/\n</code></pre>\n<h3>不能有循环引用</h3>\n<p>重要的限制：不得有循环引用。有的话转换的时候会报错。</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let room = {\n    number: 23\n};\n\nlet meetup = {\n    title: &quot;Conference&quot;,\n    participants: [&quot;john&quot;, &quot;ann&quot;]\n};\n\nmeetup.place = room;       // meetup 引用了 room\nroom.occupiedBy = meetup; // room 引用了 meetup\n\nconsole.log(JSON.stringify(meetup)); // TypeError: Converting circular structure to JSON\n</code></pre>\n<p>在这里，转换失败了，因为循环引用：<code>room.occupiedBy</code> 引用了 <code>meetup</code>，<code>meetup.place</code> 引用了 <code>room</code>：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112131512566.png\" alt=\"image-20211213151246440\" /></p>\n<h3>排除和转换：replacer</h3>\n<p><code>JSON.stringify</code> 的完整语法是：</p>\n<pre><code class=\"language-js\">let json = JSON.stringify(value[, replacer, space])\n</code></pre>\n<ol>\n<li>value 要编码的值。</li>\n<li>replacer 要编码的属性数组或映射函数 <code>function(key, value)</code>。</li>\n<li>space 用于格式化的空格数量</li>\n</ol>\n<p>大部分情况，<code>JSON.stringify</code> 仅与第一个参数一起使用。但是，如果我们需要微调替换过程，比如过滤掉循环引用，我们可以使用 <code>JSON.stringify</code> 的第二个参数。</p>\n<h4>replacer：传递数组</h4>\n<p>如果我们传递一个属性数组给它，那么只有这些属性会被编码。</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let room = {\n    number: 23\n};\n\nlet meetup = {\n    title: &quot;Conference&quot;,\n    participants: [{ name: &quot;John&quot; }, { name: &quot;Alice&quot; }],\n    place: room // meetup 引用了 room\n};\n\nroom.occupiedBy = meetup; // room 引用了 meetup\n\nconsole.log(JSON.stringify(meetup, [\'title\', \'participants\']));\n// {&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[{},{}]}\n</code></pre>\n<p>这里我们可能过于严格了。属性列表应用于了整个对象结构。所以 <code>participants</code> 是空的，因为 <code>name</code> 不在列表中。</p>\n<p>让我们包含除了会导致循环引用的 <code>room.occupiedBy</code> 之外的所有属性：</p>\n<pre><code class=\"language-js\">let room = {\n    number: 23\n};\n\nlet meetup = {\n    title: &quot;Conference&quot;,\n    participants: [{ name: &quot;John&quot; }, { name: &quot;Alice&quot; }],\n    place: room // meetup 引用了 room\n};\n\nroom.occupiedBy = meetup; // room 引用了 meetup\n\nconsole.log(JSON.stringify(meetup, [\'title\', \'participants\', \'place\', \'name\', \'number\']));\n  /*\n{\n&quot;title&quot;:&quot;Conference&quot;,\n&quot;participants&quot;:[{&quot;name&quot;:&quot;John&quot;},{&quot;name&quot;:&quot;Alice&quot;}],\n&quot;place&quot;:{&quot;number&quot;:23}\n}\n*/\n</code></pre>\n<p>现在，除 <code>occupiedBy</code> 以外的所有内容都被序列化了。但是属性的列表太长了。</p>\n<h4>replacer：传递函数</h4>\n<p>幸运的是，我们可以使用一个函数代替数组作为 <code>replacer</code>。</p>\n<p>该函数会为每个 <code>(key,value)</code> 对调用并返回“已替换”的值，该值将替换原有的值。如果值被跳过了，则为 <code>undefined</code>。</p>\n<p>在我们的例子中，我们可以为 <code>occupiedBy</code> 以外的所有内容按原样返回 <code>value</code>。为了 <code>occupiedBy</code>，下面的代码返回 <code>undefined</code>：</p>\n<pre><code class=\"language-js\">let room = {\n    number: 23\n};\n\nlet meetup = {\n    title: &quot;Conference&quot;,\n    participants: [{ name: &quot;John&quot; }, { name: &quot;Alice&quot; }],\n    place: room // meetup 引用了 room\n};\n\nroom.occupiedBy = meetup; // room 引用了 meetup\n\nconsole.log(JSON.stringify(meetup, function replacer(key, value) {\n    console.log(`${key}: ${value}`);\n    return (key === \'occupiedBy\') ? undefined : value;\n}));\n\n/* key:value pairs that come to replacer:\n:             [object Object]\ntitle:        Conference\nparticipants: [object Object],[object Object]\n0:            [object Object]\nname:         John\n1:            [object Object]\nname:         Alice\nplace:        [object Object]\nnumber:       23\n*/\n\n// {&quot;title&quot;:&quot;Conference&quot;,&quot;participants&quot;:[{&quot;name&quot;:&quot;John&quot;},{&quot;name&quot;:&quot;Alice&quot;}],&quot;place&quot;:{&quot;number&quot;:23}}\n</code></pre>\n<p>请注意 <code>replacer</code> 函数会获取每个键/值对，包括嵌套对象和数组项。它被递归地应用。<code>replacer</code> 中的 <code>this</code> 的值是包含当前属性的对象。</p>\n<p>第一个调用很特别。它是使用特殊的“包装对象”制作的：<code>{&quot;&quot;: meetup}</code>。换句话说，第一个 <code>(key, value)</code> 对的键是空的，并且该值是整个目标对象。这就是上面的示例中第一行是 <code>&quot;:[object Object]&quot;</code> 的原因。</p>\n<p>这个理念是为了给 <code>replacer</code> 提供尽可能多的功能：如果有必要，它有机会分析并替换/跳过整个对象。</p>\n<h3>格式化：space</h3>\n<p><code>JSON.stringify(value, replacer, spaces)</code> 的第三个参数是用于优化格式的空格数量。</p>\n<p>以前，所有字符串化的对象都没有缩进和额外的空格。如果我们想通过网络发送一个对象，那就没什么问题。<code>space</code> 参数专门用于调整出更美观的输出。</p>\n<p>这里的 <code>space = 2</code> 告诉 JavaScript 在多行中显示嵌套的对象，对象内部缩进 2 个空格：</p>\n<pre><code class=\"language-js\">let user = {\n    name: &quot;John&quot;,\n    age: 25,\n    roles: {\n        isAdmin: false,\n        isEditor: true\n    }\n};\n\nconsole.log(JSON.stringify(user, null, 2));\n  /* 两个空格的缩进：\n{\n  &quot;name&quot;: &quot;John&quot;,\n  &quot;age&quot;: 25,\n  &quot;roles&quot;: {\n    &quot;isAdmin&quot;: false,\n    &quot;isEditor&quot;: true\n  }\n}\n*/\n\n/* 对于 JSON.stringify(user, null, 4) 的结果会有更多缩进：\n{\n    &quot;name&quot;: &quot;John&quot;,\n    &quot;age&quot;: 25,\n    &quot;roles&quot;: {\n        &quot;isAdmin&quot;: false,\n        &quot;isEditor&quot;: true\n    }\n}\n*/\n</code></pre>\n<p><code>spaces</code> 参数仅用于日志记录和美化输出。</p>\n<h2>自定义 toJSON</h2>\n<p>像 <code>toString</code> 进行字符串转换，对象也可以提供 <code>toJSON</code> 方法来进行 JSON 转换。如果可用，<code>JSON.stringify</code> 会自动调用它。</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let room = {\n  number: 23\n};\n\nlet meetup = {\n  title: &quot;Conference&quot;,\n  date: new Date(Date.UTC(2017, 0, 1)),\n  room\n};\n\nconsole.log( JSON.stringify(meetup) );\n/*\n  {\n    &quot;title&quot;:&quot;Conference&quot;,\n    &quot;date&quot;:&quot;2017-01-01T00:00:00.000Z&quot;,  // (1)\n    &quot;room&quot;: {&quot;number&quot;:23}               // (2)\n  }\n*/\n</code></pre>\n<p>在这儿我们可以看到 <code>date</code> <code>(1)</code> 变成了一个字符串。这是因为所有日期都有一个内建的 <code>toJSON</code> 方法来返回这种类型的字符串。</p>\n<p>现在让我们为对象 <code>room</code> 添加一个自定义的 <code>toJSON</code>：</p>\n<pre><code class=\"language-js\">let room = {\n  number: 23,\n  toJSON() {\n    return this.number;\n  }\n};\n\nlet meetup = {\n  title: &quot;Conference&quot;,\n  room\n};\n\nconsole.log( JSON.stringify(room) ); // 23\n\nconsole.log( JSON.stringify(meetup) );\n/*\n  {\n    &quot;title&quot;:&quot;Conference&quot;,\n    &quot;room&quot;: 23\n  }\n*/\n</code></pre>\n<p>正如我们所看到的，<code>toJSON</code> 既可以用于直接调用 <code>JSON.stringify(room)</code> 也可以用于当 <code>room</code> 嵌套在另一个编码对象中时。</p>\n<h2>JSON.parse</h2>\n<p>要解码 JSON 字符串，我们需要另一个方法 <a href=\"https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\">JSON.parse</a>。</p>\n<p>语法：</p>\n<pre><code class=\"language-js\">let value = JSON.parse(str, [reviver]);\n</code></pre>\n<ol>\n<li>str 要解析的 JSON 字符串。</li>\n<li>reviver 可选的函数 function(key,value)，该函数将为每个 <code>(key, value)</code> 对调用，并可以对值进行转换。</li>\n</ol>\n<p>例如：</p>\n<pre><code class=\"language-js\">// 字符串化数组\nlet numbers = &quot;[0, 1, 2, 3]&quot;;\n\nlet numbers2 = JSON.parse(numbers);\n\nconsole.log(typeof numbers2); // object\nconsole.log(Object.prototype.toString.call(numbers2)); // [object Array]\nconsole.log(numbers2); // [ 0, 1, 2, 3 ]\nconsole.log(numbers2[1]); // 1\n</code></pre>\n<p>对于嵌套对象：</p>\n<pre><code class=\"language-js\">let userData = \'{ &quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 35, &quot;isAdmin&quot;: false, &quot;friends&quot;: [0,1,2,3] }\';\n\nlet user = JSON.parse(userData);\n\nconsole.log(typeof user); // object\nconsole.log(Object.prototype.toString.call(user)); // [object Object]\nconsole.log(user); // { name: \'John\', age: 35, isAdmin: false, friends: [ 0, 1, 2, 3 ] }\nconsole.log(user.friends[1]); // 1\n</code></pre>\n<p>JSON 可能会非常复杂，对象和数组可以包含其他对象和数组。但是它们必须遵循相同的 JSON 格式。</p>\n<p>以下是手写 JSON 时的典型错误（有时我们必须出于调试目的编写它）：</p>\n<pre><code class=\"language-js\">let json = `{\n  name: &quot;John&quot;,                     // 错误：属性名没有双引号\n  &quot;surname&quot;: \'Smith\',               // 错误：值使用的是单引号（必须使用双引号）\n  \'isAdmin\': false,                  // 错误：键使用的是单引号（必须使用双引号）\n  &quot;birthday&quot;: new Date(2000, 2, 3), // 错误：不允许使用 &quot;new&quot;，只能是裸值\n  &quot;friends&quot;: [0,1,2,3]              // 这个没问题\n}`;\n</code></pre>\n<p>此外，JSON 不支持注释。向 JSON 添加注释无效。</p>\n<p>常规的 JSON 格式严格，并不是因为它的开发者很懒，而是为了实现简单，可靠且快速地实现解析算法。</p>\n<h3>使用 reviver</h3>\n<p>想象一下，我们从服务器上获得了一个字符串化的 <code>meetup</code> 对象。</p>\n<p>它看起来像这样：</p>\n<pre><code class=\"language-js\">// title: (meetup title), date: (meetup date)\nlet str = \'{&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;}\';\n</code></pre>\n<p>……现在我们需要对它进行 <strong>反序列（deserialize）</strong>，把它转换回 JavaScript 对象。</p>\n<p>让我们通过调用 <code>JSON.parse</code> 来完成：</p>\n<pre><code class=\"language-js\">let str = \'{&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;}\';\n\nlet meetup = JSON.parse(str);\n\nconsole.log(meetup.date.getDate()); // TypeError: meetup.date.getDate is not a function\n</code></pre>\n<p>啊！报错了！</p>\n<p><code>meetup.date</code> 的值是一个字符串，而不是 <code>Date</code> 对象。<code>JSON.parse</code> 怎么知道应该将字符串转换为 <code>Date</code> 呢？</p>\n<p>让我们将 reviver 函数传递给 <code>JSON.parse</code> 作为第二个参数，该函数按照“原样”返回所有值，但是 <code>date</code> 会变成 <code>Date</code>：</p>\n<pre><code class=\"language-js\">let str = \'{&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;}\';\n\nlet meetup = JSON.parse(str, function (key, value) {\n    if (key == \'date\') return new Date(value);\n    return value;\n});\n\nconsole.log(meetup.date.getDate()); // 现在正常运行了！ 30\n</code></pre>\n<p>顺便说一下，这也适用于嵌套对象：</p>\n<pre><code class=\"language-js\">let schedule = `{\n  &quot;meetups&quot;: [\n    {&quot;title&quot;:&quot;Conference&quot;,&quot;date&quot;:&quot;2017-11-30T12:00:00.000Z&quot;},\n    {&quot;title&quot;:&quot;Birthday&quot;,&quot;date&quot;:&quot;2017-04-18T12:00:00.000Z&quot;}\n  ]\n}`;\n\nschedule = JSON.parse(schedule, function(key, value) {\n  if (key == \'date\') return new Date(value);\n  return value;\n});\n\nconsole.log( schedule.meetups[1].date.getDate() ); // 正常运行了！\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li><code>JSON.stringfy(value, replacer, space)</code>\n<ol>\n<li><code>value</code>：需要被序列化的值</li>\n<li><code>replacer</code>：可以传数组或者方法，对序列化的属性做一个拦截，可以设置哪些字段需要被序列化，传递方法时比较灵活</li>\n<li><code>space</code>：序列化后的缩进空格，为了美观</li>\n</ol>\n</li>\n<li><code>JSON.stringfy</code> 不能有循环引用，如果有的话会报错，但是如果碰到了循环引用，可以传递一个<code>replacer</code>函数，将循环引用的属性给忽略掉</li>\n<li><code>JSON.stringfy</code>遇到下面几种<code>key</code>时会忽略：\n<ol>\n<li>值为<code>undefined</code></li>\n<li>键为<code>Symbol</code>的</li>\n<li>函数属性</li>\n</ol>\n</li>\n<li>除了可以转换对象<code>object</code>和数组<code>array</code>外，<code>JSON.stringfy</code>还能转换基本类型，<code>string、number、boolean和null</code></li>\n<li>在调用<code>JSON.stringfy</code>转换为<code>JSON</code>字符串的过程中，默认会自动调用每一个对象的<code>toJSON</code>方法</li>\n<li><code>JSON.parse(string, reviver)</code>：将<code>JSON</code>字符串转换为对象\n<ol>\n<li><code>string</code> 需要被转换的JSON字符串</li>\n<li><code>reviver</code>：过滤某些转换后的结果</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p>https://zh.javascript.info/json</p>\n', '2021-12-13 15:59:06', '2021-12-13 15:59:06');
INSERT INTO `t_blog` VALUES ('8f7d1a00-566c-11ec-96d5-7933aca11ca0', '量词 `+, *, ?` 和 `{n}`', '假设我们有一个字符串 `+7(903)-123-45-67`，并且想要找到它包含的所有数字。但与之前不同的是，我们对单个数字不感兴趣，只对全数感兴趣：`7, 903, 123, 45, 67`。\n\n数字是一个或多个 `\\d` 的序列。用来形容我们所需要的数量的词被称为**量词**。', '-1', 2, 'https://zh.javascript.info/regexp-quantifiers', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 2, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>假设我们有一个字符串 <code>+7(903)-123-45-67</code>，并且想要找到它包含的所有数字。但与之前不同的是，我们对单个数字不感兴趣，只对全数感兴趣：<code>7, 903, 123, 45, 67</code>。</p>\n<p>数字是一个或多个 <code>\\d</code> 的序列。用来形容我们所需要的数量的词被称为<strong>量词</strong>。</p>\n<h2>数量<code>{n}</code>、<code>{m , n}</code>、<code>{n,}</code></h2>\n<p>最明显的量词便是一对引号间的数字：<code>{n}</code>。在一个字符（或一个字符类等等）后跟着一个量词，用来指出我们具体需要的数量。</p>\n<p>它有更高级的格式，用一个例子来说明：</p>\n<h3>例子1：<code>{5}</code></h3>\n<p><code>\\d{5}</code> 表示 5 位的数字，如同 <code>\\d\\d\\d\\d\\d</code>。</p>\n<p>接下来的例子将会查找一个五位数的数字：</p>\n<pre><code class=\"language-js\">console.log(&quot;I\'m 12345 years old&quot;.match(/\\d{5}/)); // [ \'12345\', index: 4, input: &quot;I\'m 12345 years old&quot;, groups: undefined ]\n</code></pre>\n<h3>例子2：<code>\\b\\d{5}\\b</code></h3>\n<p>我们可以添加 <code>\\b</code> 来排除更多位数的数字：<code>\\b\\d{5}\\b</code>。</p>\n<pre><code class=\"language-js\">console.log(&quot;123 1234 456 123456789&quot;.match(/\\d{3}/g)) // [ \'123\', \'123\', \'456\', \'123\', \'456\', \'789\' ]\nconsole.log(&quot;123 1234 456 123456789&quot;.match(/\\b\\d{3}\\b/g)) //[ \'123\', \'456\' ]\n</code></pre>\n<h3>例子3：<code>{3,5}</code></h3>\n<p><strong>某个范围的位数：</strong><code>{3,5}</code></p>\n<p>我们可以将限制范围的数字放入括号中，来查找位数为 3 至 5 位的数字：<code>\\d{3,5}</code></p>\n<pre><code class=\"language-js\">console.log(&quot;I\'m not 12, but 1234 years old&quot;.match(/\\d{3,5}/)); // &quot;1234&quot;\n/* \n[\n  \'1234\',\n  index: 16,\n  input: &quot;I\'m not 12, but 1234 years old&quot;,\n  groups: undefined\n]\n*/\n</code></pre>\n<p>我们可以省略上限。那么正则表达式 <code>\\d{3,}</code> 就会查找位数<strong>大于或等于 3</strong> 的数字：</p>\n<pre><code class=\"language-js\">console.log(&quot;I\'m not 12, but 345678 years old&quot;.match(/\\d{3,}/)); // &quot;345678&quot;\n/*\n[\n  \'345678\',\n  index: 16,\n  input: &quot;I\'m not 12, but 345678 years old&quot;,\n  groups: undefined\n]\n*/\n</code></pre>\n<p>对于字符串 <code>+7(903)-123-45-67</code> 来说，我们如果需要一个或多个连续的数字，就使用 <code>\\d{1,}</code>：</p>\n<pre><code class=\"language-js\">console.log(&quot;+7(903)-123-45-67&quot;.match(/\\d{1,}/g)); // [ \'7\', \'903\', \'123\', \'45\', \'67\' ]\n</code></pre>\n<h2>缩写</h2>\n<p>大多数常用的量词都可以有缩写：</p>\n<h3><code>+</code></h3>\n<p>代表“一个或多个”，相当于 <code>{1,}</code>。</p>\n<p>例如，<code>\\d+</code> 用来查找所有数字：</p>\n<pre><code class=\"language-js\">// + ==&gt;  {1,} 表示一个或多个\nconsole.log(&quot;+7(903)-123-45-67&quot;.match(/\\d+/g)); // [ \'7\', \'903\', \'123\', \'45\', \'67\' ]\n</code></pre>\n<h3><code>?</code></h3>\n<p>代表“零个或一个”，相当于 <code>{0,1}</code>。换句话说，它使得符号变得可选。</p>\n<pre><code class=\"language-js\">let str = &quot;Should I write color or colour?&quot;;\n\n// ？ ==&gt; {0,1} 可有可无\n// ?前面的u 就变得可有可无了\nconsole.log(str.match(/colou?r/g)); // [ \'color\', \'colour\' ]\n</code></pre>\n<h3><code>*</code></h3>\n<p>代表着“零个或多个”，相当于 <code>{0,}</code>。也就是说，这个字符可以多次出现或不出现。</p>\n<pre><code class=\"language-js\">// * ==&gt; {0,}\nconsole.log(&quot;100 10 1&quot;.match(/\\d0*/g)) // [ \'100\', \'10\', \'1\' ]\n\n// + ==&gt; {1,}\nconsole.log(&quot;100 10 1&quot;.match(/\\d0+/g)) // [ \'100\', \'10\' ]\n</code></pre>\n<h2>更多示例</h2>\n<p>量词是经常被使用的。它们是构成复杂的正则表达式的主要模块之一，我们接着来看更多的例子。</p>\n<h3>例子1</h3>\n<p><strong>正则表达式“浮点数”（带浮点的数字）：</strong><code>\\d+\\.\\d+</code></p>\n<p>实现：</p>\n<pre><code class=\"language-js\">console.log( &quot;0 1 12.345 7890&quot;.match(/\\d+\\.\\d+/g) ); // [ \'12.345\' ]\n</code></pre>\n<h3>例子2</h3>\n<p><strong>正则表达式“打开没有属性的 HTML 标记”，比如</strong> <code>&lt;span&gt;</code> <strong>或</strong> <code>&lt;p&gt;</code><strong>：</strong><code>/&lt;[a-z]+&gt;/i</code></p>\n<p>实现：</p>\n<pre><code class=\"language-js\">console.log( &quot;&lt;body&gt; ... &lt;/body&gt;&quot;.match(/&lt;[a-z]+&gt;/gi) ); // [ \'&lt;body&gt;\' ]\n</code></pre>\n<p>我们查找字符 <code>\'&lt;\'</code> 后跟一个或多个英文字母，然后是 <code>\'&gt;\'</code>。</p>\n<h3>例子3</h3>\n<p>正则表达式“打开没有属性的HTML标记”（改进版）：<code>/&lt;[a-z][a-z0-9]*&gt;/i</code></p>\n<p>更好的表达式：根据标准，HTML 标记名称可以在除了第一个位置以外的任意一个位置有一个数字，比如 <code>&lt;h1&gt;</code>。</p>\n<pre><code class=\"language-js\">console.log(&quot;&lt;h1&gt;Hi!&lt;/h1&gt;&quot;.match(/&lt;[a-z][a-z0-9]*&gt;/gi)); // [ \'&lt;h1&gt;\' ]\n</code></pre>\n<h3>例子4</h3>\n<p><strong>正则表达式“打开没有属性的HTML标记”：</strong><code>/&lt;\\/?[a-z][a-z0-9]*&gt;/i</code></p>\n<p>我们在标记前加上了一个可选的斜杆 <code>/?</code>。必须用一个反斜杠来转义它，否则 JavaScript 就会认为它是这个模式的结束符。</p>\n<pre><code class=\"language-js\">console.log(&quot;&lt;h1&gt;Hi!&lt;/h1&gt;&quot;.match(/&lt;\\/?[a-z][a-z0-9]*&gt;/gi)); // [ \'&lt;h1&gt;\', \'&lt;/h1&gt;\' ]\n</code></pre>\n<blockquote>\n<p><strong>更精确意味着更复杂</strong></p>\n<p>我们能够从这些例子中看到一个共同的规则：正则表达式越精确 —— 它就越长且越复杂。</p>\n<p>例如，HTML 标记能用一个简单的正则表达式：<code>&lt;\\w+&gt;</code>。</p>\n<p>因为 <code>\\w</code> 代表任意英文字母或数字或 <code>\'_\'</code>，这个正则表达式也能够匹配非标注的内容，比如 <code>&lt;_&gt;</code>。但它要比 <code>&lt;[a-z][a-z0-9]*&gt;</code> 简单很多。</p>\n<p>我们能够接受 <code>&lt;\\w+&gt;</code> 或者我们需要 <code>&lt;[a-z][a-z0-9]*&gt;</code>？</p>\n<p>在现实生活中，两种方式都能接受。取决于我们对于“额外”匹配的宽容程度以及是否难以通过其他方式来过滤掉它们。</p>\n</blockquote>\n<h2>总结</h2>\n<p>我们想要匹配一个字符出现一次或者多次时，可以使用量词。</p>\n<ol>\n<li><code>{5}</code>：表示出现5次</li>\n<li><code>{1,3}</code>：表示出现1到3次</li>\n<li><code>{0,1}</code>：表示出现0次或者多次</li>\n<li><code>{1,}</code>：表示出现1次或者多次</li>\n<li><code>{0,}</code>：表示出现0次或者多次</li>\n</ol>\n<p>缩写形式，如下</p>\n<ol>\n<li><code>{5}</code>→<code>{5}</code></li>\n<li><code>{1,3}</code>→<code>{1,3}</code></li>\n<li><code>{0,1}</code>→<code>?</code></li>\n<li><code>{1,}</code>→<code>+</code></li>\n<li><code>{0,}</code>→<code>*</code></li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-quantifiers\">https://zh.javascript.info/regexp-quantifiers</a></p>\n', '2021-12-06 16:14:40', '2021-12-06 16:14:40');
INSERT INTO `t_blog` VALUES ('919af480-607e-11ec-b395-6d1b1a7579ec', '序列化二叉树', 'JZ37 序列化二叉树', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 1, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112191051688.png\" alt=\"image-20211219105139598\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112191051211.png\" alt=\"image-20211219105154176\" /></p>\n<h2>代码</h2>\n<h3>代码1 层次遍历，序列化和反序列化</h3>\n<pre><code class=\"language-js\">/*\n序列化函数：二叉树转字符串\n\n使用层次遍历将二叉树转换为字符串\n空节点使用 # 占位\n*/\nfunction Serialize(pRoot)\n{\n    if(!pRoot) return \'\' // 如果是空树，返回空字符串\n    \n    // 层次遍历序列化为字符串\n    let q = [] // 使用js的数组模拟队列\n    q.push(pRoot) // 入队\n    \n    let placeHolder = new TreeNode(\'#\') // 空节点的占位符\n    \n    let result = [] // 最终返回的结果，记得转换为字符串\n    \n    // 开始层次遍历\n    while( q.length &gt; 0 ){\n        \n        let current = q.shift() // 使用shift模拟出队\n        \n        // 如果是占位符，就不继续找他的下一层了\n        if(current !== placeHolder){ \n            // 下一层入队，如果没有左右节点，使用个占位符\n            q.push( current.left ? current.left : placeHolder)\n            q.push( current.right ? current.right : placeHolder)\n        }\n        \n        // 将每一层的节点，依次塞进结果数组中\n        result.push(current.val) \n        \n    }\n    \n    // 返回的结果是一串字符串\n    return result.join() \n}\n\n/*\n反序列化函数：  字符串转二叉树\n层次遍历的字符串 还原为一个树，返回它的头节点\n还按照层次遍历的思路来解\n*/\nfunction Deserialize(s)\n{\n    if(!s) return null // 如果是空字符串，返回空节点\n    \n    let arr = s.split(\',\') // 字符串转为数组\n    \n    let q = [] // 使用数组模拟队列，一层一层的还原\n    let root = new TreeNode( +arr.shift() ) // 根节点\n    \n    q.push(root) // 入队\n    \n    \n    // 开始一层一层的还原\n    while( q.length &gt; 0 ){\n        \n        let current = q.shift() // 出队\n        \n        // 拼接左节点\n        let leftVal = arr.shift()\n        if(leftVal === \'#\'){\n            current.left = null \n            // 空节点就不用继续找了，无需入队\n        }else {\n            let leftNode = new TreeNode(+leftVal)\n            current.left = leftNode\n            // 入队\n            q.push(leftNode)\n        }\n        \n        // 拼接右节点\n        let rightVal = arr.shift()\n        if(rightVal === \'#\'){\n            current.right = null \n            // 空节点就不用继续找了，无需入队\n        }else {\n            let rightNode = new TreeNode(+rightVal)\n            current.right = rightNode\n            // 入队\n            q.push(rightNode)\n        }\n        \n\n    }\n    \n    return root // 返回最终拼接好的根\n}\n</code></pre>\n<p>时间复杂度O(n)</p>\n<p>空间复杂度O(n)</p>\n<h3>代码2 先序遍历，序列化和反序列化</h3>\n<pre><code class=\"language-js\">/*\n先序遍历序列化\n1. 为null的地方输出个 #\n*/\nfunction Serialize(pRoot)\n{\n    if(!pRoot) return \'\' // 如果空节点，返回一个空字符串\n    \n    let result = [] // 先序遍历的结果存到此处，值为null的保存为 #\n    \n    // 先序遍历存结果\n    preOrder(pRoot)\n    \n    return result.toString() // 返回序列化后的字符串\n    \n    // 先序遍历 根左右\n    function preOrder(pRoot){\n        // 出口\n        if(pRoot === null){\n            result.push(\'#\')\n            return\n        }\n        \n        result.push(pRoot.val)\n        preOrder(pRoot.left)\n        preOrder(pRoot.right)\n    }\n}\n/*\n先序遍历字符串反序列化为树\n返回根节点\n*/\nfunction Deserialize(s)\n{\n    if(!s) return null // 如果是空字符串，返回空节点\n    \n    let arr = s.split(\',\') // 字符串转为数组\n    \n    // 先序遍历重建二叉树\n    let root = preOrder(arr)\n    \n    return root\n    \n    // 先序遍历 数组转为二叉树，返回头结点\n    function preOrder(arr) {\n        let val = arr.shift() // shift方法 原数组的长度会减一，返回删除的头结点\n        \n        // 出口\n        if(val === \'#\') {\n            return null\n        } else {\n            let current = new TreeNode( +val )\n            current.left = preOrder(arr)\n            current.right = preOrder(arr)\n            \n            return current\n        }\n    }\n}\n</code></pre>\n<p>时间复杂度O(n)</p>\n<p>空间复杂度O(n)</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=13&amp;tqId=23455&amp;ru=/practice/445c44d982d04483b04a54f298796288&amp;qru=/ta/coding-interviews/question-ranking\">JZ37 序列化二叉树</a></p>\n', '2021-12-19 11:48:46', '2021-12-19 11:48:46');
INSERT INTO `t_blog` VALUES ('9499b500-42c3-11ec-96d5-7933aca11ca0', 'js中的this指向', 'js的this指向一直是个老生常谈的问题，我们知道，.前面是谁，this就是谁；非严格模式下，this有时也会指向window（浏览器端）或者global（nodejs端）；严格模式下有时会是undefined；箭头函数没有this，它的this取决于外部包裹它的函数。本章我们就通过一些例子来探究一下js的this指向问题。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 1, 23, 1, 1, 2, 1, 'http://cdn.qiniu.bnbiye.cn/img/202111111120327.png', '<h2>前言</h2>\n<p>js的<code>this</code>指向一直是个老生常谈的问题，我们知道，<code>.</code>前面是谁，<code>this</code>就是谁；非严格模式下，<code>this</code>有时也会指向<code>window</code>（浏览器端）或者<code>global</code>（nodejs端）；严格模式下有时会是<code>undefined</code>；箭头函数没有<code>this</code>，它的<code>this</code>取决于外部包裹它的函数。</p>\n<p>本章我们就通过一些例子来探究一下js的<code>this</code>指向问题，不过，在正式开始前，我们先来思考一个问题？</p>\n<p><code>this</code>为什么会被设计出来？它的用途是干什么的？</p>\n<h2><code>this</code>的由来</h2>\n<h3>对象和方法</h3>\n<p><code>js</code>中可以使用<code>{}</code>来声明对象，对象里的属性可以描述它的特征，对象里的方法可以用来描绘对象的一些行为动作，比如：</p>\n<pre><code class=\"language-js\">let user = {\n  name: &quot;John&quot;,\n  age: 30\n};\n\nuser.sayHi = function() {\n  console.log(&quot;Hello!&quot;);\n};\n\nuser.sayHi(); // Hello!\n</code></pre>\n<p>上述代码就描绘了一个<code>user</code>对象，他的名字叫<code>John</code>，他的年龄是<code>30</code>岁。他有个<code>sayHi</code>的方法，所以他可以向别人打招呼，然后他调用了自己打招呼的方法，跟我们说了声<code>Hello!</code>。</p>\n<blockquote>\n<p>🚩面向对象编程</p>\n<p>其实，上面这种用对象描述实体的方式，就是所谓的 <a href=\"https://en.wikipedia.org/wiki/Object-oriented_programming\">面向对象编程</a>，简称为 “OOP”。</p>\n<p>OOP 是一门大学问，本身就是一门有趣的科学。怎样选择合适的实体？如何组织它们之间的交互？这就是架构，有很多关于这方面的书，例如 E. Gamma、R. Helm、R. Johnson 和 J. Vissides 所著的《设计模式：可复用面向对象软件的基础》，G. Booch 所著的《面向对象分析与设计》等。</p>\n<p>参考：<a href=\"https://zh.javascript.info/object-methods#jian-tou-han-shu-mei-you-zi-ji-de-this\">https://zh.javascript.info/object-methods#jian-tou-han-shu-mei-you-zi-ji-de-this</a></p>\n</blockquote>\n<p>上述的示例代码其实还可以简写一下：</p>\n<pre><code class=\"language-js\">let user = {\n  name: &quot;John&quot;,\n  age: 30,\n  sayHi: function() {\n     console.log(&quot;Hello&quot;);\n  }\n};\n\n// 方法简写看起来更好，对吧？\nlet user = {\n  name: &quot;John&quot;,\n  age: 30,\n  sayHi() { // 与 &quot;sayHi: function()&quot; 一样\n     console.log(&quot;Hello&quot;);\n  },\n};\n</code></pre>\n<h3>方法中的<code>this</code></h3>\n<p>通常，对象方法需要访问对象中存储的信息才能完成其工作。比如上面例子里的<code>John</code>向别人打招呼时，需要顺便介绍一下自己的名字和年龄，这时就需要用到 <code>user</code> 的 <code>name</code>和<code>age</code>属性。所以，为了能访问到自己，就诞生出了<code>this</code>关键字。</p>\n<p><strong><code>this</code> 的值就是在点之前的这个对象，即调用该方法的对象。</strong></p>\n<pre><code class=\"language-js\">let user = {\n    name: &quot;John&quot;,\n    age: 30,\n    sayHi() {\n        // &quot;this&quot; 指的是“当前的对象”\n        console.log(this.name);\n    }\n};\n\nuser.sayHi(); // John\n</code></pre>\n<p>在这里 <code>user.sayHi()</code> 执行过程中，<code>this</code> 的值是 <code>user</code>。</p>\n<p>技术上讲，也可以在不使用 <code>this</code> 的情况下，通过外部变量名来引用它：</p>\n<pre><code class=\"language-js\">let user = {\n    name: &quot;John&quot;,\n    age: 30,\n    sayHi() {\n        console.log(user.name); // &quot;user&quot; 替代 &quot;this&quot;\n    }\n};\n\nuser.sayHi(); // John\n</code></pre>\n<blockquote>\n<p>🤫……但上面的代码是不可靠的。如果我们决定将 <code>user</code> 复制给另一个变量，例如 <code>admin = user</code>，并赋另外的值给 <code>user</code>，那么它将访问到错误的对象。比如：</p>\n</blockquote>\n<pre><code class=\"language-js\">let user = {\n    name: &quot;John&quot;,\n    age: 30,\n    sayHi() {\n        console.log(user.name); // 导致错误\n    }\n};\nlet admin = user;\nuser = null; // 重写让其更明显\n\nadmin.sayHi(); // TypeError: Cannot read property \'name\' of null\n</code></pre>\n<p>我们可以画图来理解一下上面的例子，看一下为什么会报错：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111111120327.png\" alt=\"堆内存栈内存\" /></p>\n<p>如图所示，JS的变量存储在栈内存中，对象和方法存储在堆内存中，<code>user</code>实际存储的是对象的引用，一串地址空间</p>\n<ol>\n<li>首先声明了一个<code>user</code>变量，将其指向堆内存的一个对象上。</li>\n<li>然后又声明了一个<code>admin</code>变量，也保存刚才的地址，所以此时的<code>admin</code>和<code>user</code>指向的是同一块内存空间，即图中的对象保存的地方。</li>\n<li>这时做了一个操作，将<code>user</code>变量置为空，那么此时的<code>user</code>变量就找不到原来的对象了。</li>\n<li>而<code>admin</code>保存的仍旧是原先的那块地址空间，所以还能找到对象里的<code>sayHi</code>方法，但是由于<code>user = null</code>，所以打印输出时会报错，<code>TypeError: Cannot read property \'name\' of null</code>。</li>\n</ol>\n<blockquote>\n<p>所以这时就体现出<code>this</code>的好处了，将代码中的<code>user</code>替换成<code>this</code>，代码就能正常运行了。如下所示：</p>\n</blockquote>\n<pre><code class=\"language-js\">let user = {\n    name: &quot;John&quot;,\n    age: 30,\n    sayHi() {\n        console.log(this.name);\n    }\n};\n\nlet admin = user;\nuser = null;\n\nadmin.sayHi(); // John\n</code></pre>\n<p>继续画图分析一下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111111133285.png\" alt=\"堆内存栈内存2\" /></p>\n<p>前两步和之前的一样，我们直接从第三步开始看</p>\n<ol start=\"3\">\n<li>将变量<code>user</code>置为空后，变量<code>user</code>就找不到之前的对象了，就没什么用了。</li>\n<li>此时的变量<code>admin</code>还保存着之前对象的引用地址，所以指向的还是刚才声明的对象，所以能找到<code>sayHi</code>方法，在打印输出中，我们改为了<code>this.name</code>，此时的<code>this</code>就是当前对象。因为使用的<code>admin.sayHi()</code>调用的该方法，所以此时的<code>this</code>就是<code>admin</code>（<code>.</code>之前的对象就是<code>this</code>），，所以当调用<code>this.name</code>时，正常输出了<code>John</code>。</li>\n</ol>\n<h2><code>this</code>指向的不确定性</h2>\n<blockquote>\n<p>在方法里使用<code>this</code>时，并不受限制，可以随便用，JS并不会直接将<code>this</code>绑定在当前方法上，具体的指向只有在调用函数时，根据上下文才会被确定，也就是说，this的指向是不确定的。</p>\n</blockquote>\n<h3>指向<code>window</code>、<code>global</code>或者<code>undefined</code></h3>\n<pre><code class=\"language-js\">// &quot;use strict&quot;\nfunction sayHi() {\n    console.log(this);\n}\nsayHi()\n</code></pre>\n<p>如上面的例子，直接使用<code>function</code>声明一个方法，方法里面打印<code>this</code>，而我们并不把这个方法绑定到某个对象上，而是直接使用方法名调用，这时有两种情况</p>\n<ul>\n<li>非严格模式下：</li>\n</ul>\n<ol>\n<li>\n<p>浏览器端，<code>this</code>指向全局对象<code>window</code></p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111111337988.png\" alt=\"image-20211111133753844\" /></p>\n</li>\n<li>\n<p>nodejs端，<code>this</code>指向全局对象<code>global</code></p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111111338205.png\" alt=\"image-20211111133816137\" /></p>\n</li>\n</ol>\n<ul>\n<li>严格模式下（在头部增加<code>&quot;use strict&quot;</code>），此时<code>this</code>为<code>undefined</code></li>\n</ul>\n<h3>指向<code>.</code>前面的对象</h3>\n<pre><code class=\"language-js\">let user = { name: &quot;John&quot; };\nlet admin = { name: &quot;Admin&quot; };\n\nfunction sayHi() {\n    console.log(this.name);\n}\n\n// 在两个对象中使用相同的函数\nuser.f = sayHi;\nadmin.f = sayHi;\n\n// 这两个调用有不同的 this 值\n// 函数内部的 &quot;this&quot; 是“点符号前面”的那个对象\nuser.f(); // John（this === user）\nadmin.f(); // Admin（this === admin）\n\nadmin[\'f\'](); // Admin（使用点符号或方括号语法来访问这个方法，都没有关系。）\n</code></pre>\n<p>如上面的例子，<code>this</code>就是<code>.</code>前面的对象。我们画图来分析一下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111111440947.png\" alt=\"堆内存栈内存3\" /></p>\n<ol>\n<li>我们先声明了一个变量<code>user</code>，指向了堆内存中的一个对象上。（实际保存的是地址的引用）</li>\n<li>又声明了一个变量<code>admin</code>，也指向了堆内存中的一个对象上，2中的对象与1中的对象不是同一个，分别保存在堆内存的不同位置上。（实际保存的是地址的引用）</li>\n<li>使用<code>function</code>声明了一个<code>sayHi</code>方法，这时又在堆内存开辟了一块新的内存空间，保存这个方法，<code>sayHi</code>变量保存该方法的引用。</li>\n<li><code>user.f = sayHi</code>，为<code>user</code>对象添加一个变量<code>f</code>指向<code>sayHi</code>方法。</li>\n<li><code>admin.f = sayHi</code>，为<code>admin</code>对象添加一个变量<code>f</code>指向<code>sayHi</code>方法。</li>\n<li><code>user.f()</code>，因为为<code>user</code>增加的<code>f</code>变量指向了<code>sayHi</code>方法，所以此时的<code>f</code>就是<code>sayHi</code>方法，此时<code>sayHi</code>中的<code>this</code>就是<code>user</code>对象本身，所以打印出了<code>John</code>。</li>\n<li><code>admin.f()</code>，因为为<code>admin</code>增加的<code>f</code>变量指向了<code>sayHi</code>方法，所以此时的<code>f</code>就是<code>sayHi</code>方法，此时<code>sayHi</code>中的<code>this</code>就是<code>admin</code>对象本身，所以打印出了<code>Admin</code>。</li>\n</ol>\n<blockquote>\n<p>🚩<strong>解除</strong> <code>this</code> <strong>绑定的后果</strong></p>\n<p>如果你经常使用其他的编程语言，那么你可能已经习惯了“绑定 <code>this</code>”的概念，即在对象中定义的方法总是又指向该对象的 <code>this</code>。</p>\n<p>在 JavaScript 中，<code>this</code> 是“自由”的，它的值是在调用时计算出来的，它的值并不取决于方法声明的位置，而是取决于在“点符号前”的是什么对象。</p>\n<p>在运行时对 <code>this</code> 求值的这个概念既有优点也有缺点。一方面，函数可以被重用于不同的对象。另一方面，更大的灵活性造成了更大的出错的可能。</p>\n<p>这里我们的立场并不是要评判编程语言的这个设计是好是坏。而是要了解怎样使用它，如何趋利避害。</p>\n<p>参考：<a href=\"https://zh.javascript.info/object-methods#jian-tou-han-shu-mei-you-zi-ji-de-this\">https://zh.javascript.info/object-methods#jian-tou-han-shu-mei-you-zi-ji-de-this</a></p>\n</blockquote>\n<h2>箭头函数没有自己的<code>this</code></h2>\n<p>我们知道，箭头函数没有自己的<code>this</code>，如果访问 <code>this</code>，则会从外部包裹它的函数中获取。我们看下面这个例子，这里 <code>forEach</code> 中使用了箭头函数，所以其中的 <code>this.title</code> 其实和外部方法 <code>showList</code> 的完全一样。那就是：<code>group.title</code>，所以最终会打印正确的结果。</p>\n<pre><code class=\"language-js\">&quot;use strict&quot;\nlet group = {\n    title: &quot;Our Group&quot;,\n    students: [&quot;John&quot;, &quot;Pete&quot;, &quot;Alice&quot;],\n\n    showList() {\n        this.students.forEach((item) =&gt; {\n            console.log(this.title + \': \' + item)\n        });\n    }\n};\n\ngroup.showList();\n</code></pre>\n<p>但是当我们换成普通的匿名函数时，就会报错：</p>\n<pre><code class=\"language-js\">&quot;use strict&quot;\nlet group = {\n    title: &quot;Our Group&quot;,\n    students: [&quot;John&quot;, &quot;Pete&quot;, &quot;Alice&quot;],\n\n    showList() {\n        this.students.forEach(function (item) {\n            // TypeError: Cannot read property \'title\' of undefined\n            console.log(this.title + \': \' + item)\n        });\n    }\n};\n\ngroup.showList();\n</code></pre>\n<p>报错是因为 <code>forEach</code> 运行它里面的这个函数，但是这个函数的 <code>this</code> 为默认值 <code>this=undefined</code>（严格模式下默认为<code>undifined</code>），因此就出现了尝试访问 <code>undefined.title</code> 的情况。</p>\n<h2>总结</h2>\n<ol>\n<li>\n<p>在方法里使用<code>this</code>时，并不会受限制，可以随便用，js并不会直接将<code>this</code>绑定在当前方法上，具体的指向只有在调用函数时，根据上下文才会被确定。</p>\n</li>\n<li>\n<p>直接使用<code>function</code>声明一个方法时，通过方法名直接调用，此时的<code>this</code>指向分为两种情况：</p>\n<p>2.1 非严格模式下，浏览器端<code>this</code>指向<code>window</code>，<code>nodejs</code>端指向<code>global</code></p>\n<p>2.2 严格模式下，<code>this === undefined</code></p>\n</li>\n<li>\n<p>使用<code>object.fn()</code>【对象<code>.</code>方法】的形式调用时，<code>this</code>就是<code>.</code>前面的对象。</p>\n</li>\n<li>\n<p>箭头函数默认没有<code>this</code>，如果访问 <code>this</code>，则会从外部包裹它的函数中获取。</p>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/object-methods\">https://zh.javascript.info/object-methods</a></p>\n<p><a href=\"https://zh.javascript.info/arrow-functions\">https://zh.javascript.info/arrow-functions</a></p>\n', '2021-11-11 15:47:12', '2021-11-11 15:49:49');
INSERT INTO `t_blog` VALUES ('97ad9e00-5d99-11ec-b395-6d1b1a7579ec', '链表中倒数最后k个结点', 'JZ22 链表中倒数最后k个结点', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 3, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112151902429.png\" alt=\"image-20211215190214379\" /></p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：\n{1,2,3,4,5},2\n返回值：\n{4,5}\n说明：\n返回倒数第2个节点4，系统会打印后面所有的节点来比较。\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：\n{2},8\n返回值：\n{}\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 快慢指针法</h3>\n<pre><code class=\"language-js\">/*\n快慢指针法（快慢指针都先指向一个虚拟的头节点）\n1. 快指针先走k步，走到k步之后，慢指针开始走\n2. 快指针走到null，结束\n    此时，慢指针走的位置即为结果，\n    如果快指针走到null了，慢指针还没开始走，就说明范围超了\n*/\nfunction FindKthToTail( pHead ,  k ) {\n\n    let vHead = new ListNode(-1) // 虚拟头结点\n    vHead.next = pHead\n    \n    let fast = vHead // 快指针\n    let slow = vHead // 慢指针\n    \n    // 快指针先走K步，慢指针开始走\n    let count = 0 // 计步器\n    \n    while(fast){\n        if(count &gt;= k){ // 慢指针开始走\n            slow = slow.next\n        }\n        fast = fast.next\n        count++\n    }\n    // 如果慢指针一步没走，就说明K太大了\n    if(slow === vHead) return null\n    return slow\n}\n</code></pre>\n<h3>代码2 使用栈</h3>\n<pre><code class=\"language-js\">/*\n使用栈\n1. 先把链表遍历一个遍，进栈\n2. 然后出栈重新拼个链表\n*/\nfunction FindKthToTail( pHead ,  k ) {\n    // 如果没有传或者k为0，直接返回null\n    if(!pHead || k === 0){\n        return null\n    }\n    \n    let stack = [] // 模拟一个栈\n    \n    while(pHead){ // 全部进栈\n        stack.push(pHead)\n        pHead = pHead.next\n    }\n    \n    // 如果k比数组长度还长 直接返回null\n    if( k &gt; stack.length ) return null\n    \n    // 开始找到倒数第k个节点\n    let newHead = null\n    while( k &gt; 0 ){\n        newHead = stack.pop()\n        k--\n    }\n    \n    return newHead\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=13&amp;tqId=1377477&amp;ru=/practice/75e878df47f24fdc9dc3e400ec6058ca&amp;qru=/ta/coding-interviews/question-ranking\">JZ22 链表中倒数最后k个结点</a></p>\n', '2021-12-15 19:24:39', '2021-12-15 19:24:39');
INSERT INTO `t_blog` VALUES ('98230e60-2cc0-11ec-86ae-0da8227970f6', 'git笔记', '学习git的相关知识', '-1', 1, '', 'ed61f0f0-2cbe-11ec-86ae-0da8227970f6', 4, 34, 4, 1, 2, 1, 'http://82.156.76.49:20517/upload/png/2021-10-14/8648e570-2cc0-11ec-86ae-0da8227970f6.png', '<p>该笔记是参照廖雪峰大佬写的Git教程<br />\nhttps://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/</p>\n<h2>1、下载git</h2>\n<p>下载window版本的git，网址是：</p>\n<p><a href=\"https://gitforwindows.org/\">https://gitforwindows.org/</a></p>\n<p>一路下一步</p>\n<h2>2、自报家门</h2>\n<p>安装完后才能后，需要在gitbash中设置一下你自己的邮箱和用户</p>\n<pre><code class=\"language-git\">git config --global user.name &quot;cheny&quot;\ngit config --global user.email &quot;597985642@qq.com&quot;\n</code></pre>\n<p>git中用户名和邮箱地址的作用:</p>\n<p>用户名和邮箱地址是本地git客户端的一个变量，不随git库而改变。</p>\n<p>每次commit都会用用户名和邮箱纪录。</p>\n<p>github的contributions统计就是按邮箱来统计的。</p>\n<p>由于我们把remote 仓库放在这类云端，而提交的验证方式则是通过用户名和密码。因此，我们有时会疏忽掉提交邮箱和用户名的问题。因为，能够输入云端的用户名和密码，就能够提交上去。这个时候，如果我在其他的pc上想要提交，则需要修改一些本地提交到云端的用户名和邮箱。这样才能保证提交上去都是你自己的。</p>\n<p><strong>修改当前用户邮箱和用户的方法如下</strong></p>\n<pre><code class=\"language-git\">git config --global user.name &quot;username&quot;\ngit config --global user.email &quot;email&quot;\n</code></pre>\n<p><strong>查看自己的用户和邮箱</strong></p>\n<pre><code class=\"language-git\">git config user.name\ngit config user.email\n</code></pre>\n<h2>3、创建版本库</h2>\n<p>（1）假设我在桌面创建一个目录，名字叫learngit</p>\n<pre><code class=\"language-git\">mkdir leargit\ncd leargit/\ngit init\n</code></pre>\n<p>这时候，一个新的git版本库就创建好了，会在我们的目录下面生成一个<code>.git</code>目录</p>\n<p>（2）然后我们用notepad++创建一个<code>readme.txt</code>文件，并编辑文字</p>\n<pre><code class=\"language-txt\">Git is a version control system.\nGit is free software.\n</code></pre>\n<p>（3）把新建的文件添加到仓库</p>\n<pre><code class=\"language-git\">git add readme.txt\n</code></pre>\n<p>（4）提交</p>\n<pre><code class=\"language-git\">git commit -m &quot;wrote a readme.txt file&quot;\n</code></pre>\n<p>实际上，你可以add多个文件，提交只提交一次即可，如下：</p>\n<pre><code class=\"language-git\">git add file1.txt\ngit add file2.txt\ngit add file3.txt\ngit commit -m &quot;add 3 files.&quot;\n</code></pre>\n<h2>4、修改文件，查看状态，重新提交</h2>\n<p>（1）我们已经成功地添加并提交了⼀个readme.txt⽂件，现在，是时候继续⼯作了，于是，我<br />\n们继续修改readme.txt⽂件，改成如下内容：</p>\n<pre><code class=\"language-tex\">Git is a distributed version control system.\nGit is free software.\n</code></pre>\n<p>（2）查看当前状态、修改未提交</p>\n<pre><code class=\"language-git\">git status\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019040521021099.png\" alt=\"在这里插入图片描述\" /></p>\n<p>（3）查看哪里做了修改</p>\n<pre><code class=\"language-git\">git diff readme.txt\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210225992.png\" alt=\"在这里插入图片描述\" /></p>\n<p>（4）发现是正常的修改，然后重新把文件添加到仓库</p>\n<pre><code class=\"language-git\">git add readme.txt\n</code></pre>\n<p>（5）重新查看当前状态、等待提交</p>\n<pre><code class=\"language-git\">git status\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/2019040521032670.png\" alt=\"在这里插入图片描述\" /></p>\n<p>（6）正式提交，提交到仓库</p>\n<pre><code class=\"language-git\">git commit -m &quot;add distrubuted&quot;\n</code></pre>\n<p>（7）再次查看状态、无任何变动、all clean</p>\n<pre><code class=\"language-git\">git status\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210348333.png\" alt=\"在这里插入图片描述\" /></p>\n<h2>5、版本回退</h2>\n<p>（1）先再修改一下readme.txt</p>\n<pre><code class=\"language-git\">Git is a distributed version control system.\nGit is free software distributed under the GPL.\n</code></pre>\n<p>（2）添加到仓库</p>\n<pre><code class=\"language-git\">git add readme.txt\n</code></pre>\n<p>（3）提交</p>\n<pre><code class=\"language-git\">git commit -m &quot;append GPL&quot;\n</code></pre>\n<p>（4）查看之前所有的版本-详细版</p>\n<pre><code class=\"language-git\">git log\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210412878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>（5）查看之前所有的版本-缩略版</p>\n<pre><code class=\"language-git\">git log --pretty=oneline\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210439796.png\" alt=\"在这里插入图片描述\" /></p>\n<p>（6）回退到上一版本</p>\n<p>在Git中，⽤HEAD表⽰当前版本，也就是最新的<br />\n提交“730582...a42a”（注意我的提交ID和你的肯定不⼀样），上⼀个版本就是<br />\nHEAD^，上上⼀个版本就是HEAD^^，当然往上100 个版本写100个^⽐较容易数不过来，<br />\n所以写成HEAD~100。</p>\n<pre><code class=\"language-git\">git reset --hard HEAD^\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210456776.png\" alt=\"在这里插入图片描述\" /></p>\n<p>（7）回到刚才的版本</p>\n<p>用刚才的指令还可以继续回退到上⼀个版本“add 3 files”，不过且慢，然我们⽤git log再看<br />\n看现在版本库的状态：发现刚才的&quot;append GPL&quot;版本没了，最新的那个版本“append GPL”已经看不到了！好⽐你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？办法其实还是有的，只要上⾯的命令⾏窗⼝还没有被关掉，你就可以顺着往上找啊找啊，找到那个“append GPL”的commit id是“730582...a42a”，于是就可以指定回到未来的某个版本：<strong>不用写全</strong></p>\n<pre><code class=\"language-git\">git reset --hard 73058\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210510385.png\" alt=\"在这里插入图片描述\" /></p>\n<p>（8）查看reademe.txt</p>\n<pre><code class=\"language-git\">cat readme.txt\n</code></pre>\n<p>你会发先已经改变回来了</p>\n<p>（9）查看所有提交的版本操作</p>\n<p>现在，你回退到了某个版本，关掉了电脑，第⼆天早上就后悔了，想恢复到新版本怎么办？<br />\n找不到新版本的commit id怎么办？在Git中，总是有后悔药可以吃的。当你⽤$ git reset --hard HEAD^回退到“add distributed”版本时，再想恢复到“append GPL”，就必须找到“append GPL”的commit id。Git提供了⼀个命令git reflog⽤来记录你的每⼀次命令：</p>\n<pre><code class=\"language-git\">git reflog\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210527804.png\" alt=\"在这里插入图片描述\" /></p>\n<h2>6、工作区和暂存区</h2>\n<p><strong>⼯作区（Working Directory）</strong>：就是你在电脑⾥能看到的目录，⽐如我的learngit⽂件夹<br />\n就是⼀个⼯作区。</p>\n<p><strong>版本库（Repository）</strong>：⼯作区有⼀个隐藏⺫录“.git”，这个不算⼯作区，⽽是Git的版本<br />\n库。<br />\nGit的版本库⾥存了很多东⻄，其中最重要的就是称为stage（或者叫index）的暂存区，还<br />\n有Git为我们⾃动创建的第⼀个分⽀master，以及指向master的⼀个指针叫HEAD。<br />\n<img src=\"https://img-blog.csdnimg.cn/20190405210547845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>第⼀步是⽤“git add”把⽂件添加进去，实际上就是把⽂件修改添加到暂存区；<br />\n第⼆步是⽤“git commit”提交更改，实际上就是把暂存区的所有内容提交到当前分⽀。<br />\n因为我们创建Git版本库时，Git⾃动为我们创建了唯⼀⼀个master分⽀，所以，现在，<br />\ncommit就是往master分⽀上提交更改。</p>\n<p>实践：</p>\n<p>（1）修改readme.txt</p>\n<pre><code class=\"language-tex\">Git is a distributed version control system.\nGit is free software distributed under the GPL.\nGit has a mutable index called stage.\n</code></pre>\n<p>（2）在工作区新建一个LICENSE.txt</p>\n<pre><code class=\"language-txt\">hrbust_cheny\n</code></pre>\n<p>（3）查看当前状态、一个是修改状态、一个是从未被添加过是Untracked状态。</p>\n<pre><code>git status\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210616152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>（3）将两个文件都添加进去、并查看当前状态、</p>\n<pre><code class=\"language-git\">git add readme.txt\ngit add LICENSE.txt\ngit status\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210636799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage）</strong></p>\n<p>现在工作区的状态是这个样子的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210656415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>（4）commit提交、查看当前状态</p>\n<pre><code class=\"language-git\">git commit -m &quot;understand how stage works&quot;\ngit status\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210720466.png\" alt=\"在这里插入图片描述\" /></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210737273.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>现在版本库变成了这样，暂存区就没有任何内容了</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210802289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2>7、Git跟踪并管理的是修改，⽽⾮⽂件</h2>\n<p>当你有如下的操作时</p>\n<p><strong>第⼀次修改 -&gt; git add -&gt; 第⼆次修改 -&gt; git commit</strong></p>\n<p>第二次修改的内容并没有提交到分支上，git只把提交到缓存区的内容上传到了主分支。</p>\n<p>自己悟一下~</p>\n<p>一个好用的命令，<strong>查看⼯作区和版本库⾥⾯最新版本的区别</strong></p>\n<pre><code class=\"language-git\">git diff HEAD -- readme.txt\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210833214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<h2>8、撤销修改、add之前撤销原样、commit之前撤销回原样</h2>\n<p>(1)</p>\n<p>状态1：⼀种是readme.txt⾃修改后还没有被放到暂存区，现在，撤销修改就回到和版本库⼀模⼀<br />\n样的状态</p>\n<p>状态2：⼀种是readme.txt已经添加到暂存区后，⼜作了修改，现在，撤销修改就回到添加到暂存<br />\n区后的状态</p>\n<pre><code class=\"language-git\">git checkout -- readme.txt\n</code></pre>\n<p>(2)</p>\n<p>把暂存区的修改撤销掉（unstage），重新放回⼯作区</p>\n<pre><code class=\"language-git\">git reset HEAD readme.txt\n</code></pre>\n<p>这样就把等待commit的文件，又回退到了还未add的状态</p>\n<h2>9、删除commit之后的文件、或者还原删除过的文件</h2>\n<p>当你把一个文件commit之后，你直接在文件夹中把这个文件删除，或者用命令行删除，这个时候你查看一下当前git的状态，git是有反应的</p>\n<p>删除文件的指令</p>\n<pre><code class=\"language-git\">rm test.txt\n</code></pre>\n<p>这个时候查看git的状态</p>\n<pre><code class=\"language-git\">git status\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210906808.png\" alt=\"在这里插入图片描述\" /></p>\n<p>（1）这个时候你有两种选择，一种是真的从git中删除</p>\n<pre><code class=\"language-git\">git rm test.txt\n</code></pre>\n<p>然后再查看状态</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210924268.png\" alt=\"在这里插入图片描述\" /></p>\n<p>然后你再commit一下，就彻底没了</p>\n<pre><code class=\"language-git\">git commit -m &quot;remove test.txt&quot;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405210940247.png\" alt=\"在这里插入图片描述\" /></p>\n<p>（2）另一种选择是，你后悔了，你想在把这个文件恢复回来</p>\n<pre><code class=\"language-git\">git checkout -- test.txt\n</code></pre>\n<p>git checkout其实是⽤版本库⾥的版本替换⼯作区的版本，⽆论⼯作区是修改还是删除，都<br />\n可以“⼀键还原”</p>\n<h2>10、连接远程仓库、使用SSH公私钥</h2>\n<p>（1）创建SSH Key。在⽤户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下<br />\n有没有id_rsa和id_rsa.pub这两个⽂件，如果已经有了，可直接 跳到下⼀步。如果没有，打<br />\n开Shell（Windows下打开Git Bash），创建SSH Key</p>\n<pre><code class=\"language-linux\">ssh-keygen -t rsa -C &quot;597985642@qq.com&quot;\n</code></pre>\n<p>一路回车即可，也不用设密码，没啥用</p>\n<p>然后会在你的用户目录下面生成一个<code>.ssh</code>目录</p>\n<p>我的目录是这样子的：<code>C:\\Users\\cheny\\.ssh</code><br />\n<img src=\"https://img-blog.csdnimg.cn/20190731214931247.png\" alt=\"在这里插入图片描述\" /></p>\n<p>⾥⾯有id_rsa和id_rsa.pub两个⽂件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放⼼地告诉任何⼈。</p>\n<p>（2）在github上添加自己的公钥</p>\n<p>把自己本地的公钥<code>id_rsa.pub</code>的内容复制到github里，title可以随便填</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211004221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，⽽<br />\n不是别⼈冒充的，⽽Git⽀持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只<br />\n有你⾃⼰才能推送。<br />\n当然，GitHub允许你添加多个Key。假定你有若干电脑，你⼀会⼉在公司提交，⼀会⼉在<br />\n家⾥提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送<br />\n了。</p>\n<h2>11、将本地文件夹与远程github关联</h2>\n<p>这里假如你已经把本地的SSh公钥添加到了github中，就可以执行以下操作来进行关联</p>\n<p>（1）在github里新建一个远程仓库，取名叫做<code>learngit</code></p>\n<p>（2）在本地的<code>learngit</code>仓库运行下面的命令</p>\n<pre><code class=\"language-git\">git remote add origin git@github.com:13836005450/learngit.git\n</code></pre>\n<p>请千万注意，把上⾯的<code>13836005450</code>替换成你⾃⼰的GitHub账户名，否则，你在本地关联的<br />\n就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不<br />\n在我的账户列表中。</p>\n<p>（3）将本地的内容推送到远端</p>\n<pre><code class=\"language-git\">git push -u origin master\n</code></pre>\n<p>把本地库的内容推送到远程，⽤git push命令，实际上是把当前分⽀master推送到远程。</p>\n<p>由于远程库是空的，我们第⼀次推送master分⽀时，加上了-u参数，Git不但会把本地的<br />\nmaster分⽀内容推送的远程新的master分⽀，还会把本地的master分⽀和远程的master<br />\n分⽀关联起来，在以后的推送或者拉取时就可以简化命令。<br />\n推送成功后，可以⽴刻在GitHub⻚⾯中看到远程库的内容已经和本地⼀模⼀样。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211032234.png\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>从现在起，只要本地作了提交，就可以通过命令</strong></p>\n<pre><code class=\"language-git\">git push origin master\n</code></pre>\n<p><strong>把本地master分⽀的最新修改推送⾄GitHub。</strong></p>\n<h2>13、从远程github克隆项目到本地</h2>\n<p>（1）在远程新建一个项目<code>gitskills</code>，在初始化一个<code>README.md</code></p>\n<p>（2）在本地克隆</p>\n<pre><code class=\"language-git\">git clone git@github.com:13836005450/gitskills.git\n</code></pre>\n<p>（3）查看一下</p>\n<pre><code class=\"language-git\">cd gitskills\nls\n</code></pre>\n<p>这时候就会看到你的<code>README.md</code></p>\n<h2>14、git的分支操作（鼓励使用分支）</h2>\n<p>git分支的创建、切换、合并速度都非常快，</p>\n<p><strong>（1）分支的好处如下：</strong></p>\n<p>分⽀就是科幻电影⾥⾯的平⾏宇宙，当你正在电脑前努⼒学习Git的时候，另⼀个你正在另<br />\n⼀个平⾏宇宙⾥努⼒学习SVN。<br />\n如果两个平⾏宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平⾏宇<br />\n宙合并了，结果，你既学会了Git⼜学会了SVN！</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211157456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>（2）分支的原理</strong></p>\n<p>⼀开始的时候，master分⽀是⼀条线，Git⽤master指向最新的提交，再⽤HEAD指向<br />\nmaster，就能确定当前分⽀，以及当前分⽀的提交点</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211206110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>每次提交，master分⽀都会向前移动⼀步，这样，随着你不断提交，master分⽀的线也越<br />\n来越⻓。<br />\n当我们创建新的分⽀，例如dev时，Git新建了⼀个指针叫dev，指向master相同的提交，<br />\n再把HEAD指向dev，就表⽰当前分⽀在dev上：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211212750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>从现在开始，对⼯作区的修改和提交就是针对dev分⽀了，⽐如新提交⼀次后，dev<br />\n指针往前移动⼀步，⽽master指针不变：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211221895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /><br />\n假如我们在dev上的⼯作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单<br />\n的⽅法，就是直接把master指向dev的当前提交，就完成了合并</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211229433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p>合并完分⽀后，甚⾄可以删除dev分⽀。删除dev分⽀就是把dev指针给删掉，删掉后，我<br />\n们就剩下了⼀条master分⽀</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211236124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW55X1lhbmc=,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\" /></p>\n<p><strong>所以，git分支操作速度很快，方便快捷</strong></p>\n<p>（1）git创建分支、快速创建并切换</p>\n<pre><code class=\"language-git\">git checkout -b dev\n</code></pre>\n<p>（2）创建分支、不切换</p>\n<pre><code class=\"language-git\">git branch dev\n</code></pre>\n<p>（3）切换分支</p>\n<pre><code class=\"language-git\">git checkout dev\n</code></pre>\n<p>（4）查看分支</p>\n<pre><code class=\"language-git\">git branch\n</code></pre>\n<p>（5）删除分支</p>\n<pre><code class=\"language-git\">git branch -d dev\n</code></pre>\n<p>（6）合并分支</p>\n<pre><code class=\"language-git\">git merge dev\n</code></pre>\n<h2>15、解决冲突</h2>\n<p>当两个不同的分支同时改变了同一行文字时，就会产生冲突，这时候当你自动合并分支的时候，会产生一个新的提交状态，冲突状态，并且会自动的将冲突的内容写在一起，让你手动的解决冲突。如下</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211305117.png\" alt=\"在这里插入图片描述\" /></p>\n<p>Git⽤&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分⽀的内容</p>\n<p>手动更改之后，重新add、commit就行了。</p>\n<h2>16、分支策略</h2>\n<p>master分支应该是非常稳定的，应不稳定的分支应该是dev，每个小伙伴都有一个自己的分支，时不时的将自己的分支合并到dev上，当dev分支比较稳定后，在把dev分支合并到master分支上，所以一般工作时候的状态应该是这样子的。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190405211318253.png\" alt=\"在这里插入图片描述\" /></p>\n<h2>17、bug分支</h2>\n<p>假如你正在操作你自己的分支，这时候boss突然告诉你，master分支上有一个bug，你去修复一下。</p>\n<p>这个时候你手里任务还没完成，你还不能提交到dev分支，怎么办？</p>\n<p>有个好办法，<strong>git提供了一个可以保存当前状态的方法</strong></p>\n<pre><code class=\"language-git\">git stash\n</code></pre>\n<p>这样就把你当前的状态给保存的下来，你就放心的去切换到主分支去修复bug把。</p>\n<p>一般修复bug都会建一个临时的分支，比如<code>issure101</code>，等修复完后，再切换到主分支合并这个bug分支，然后把问题分支删除就行了。</p>\n<p>接下来，你继续完成你剩余的工作，切换到自己的分支，你发现，里面啥也没有！</p>\n<p>其实是给你隐藏了起来，查看隐藏的<code>stash</code></p>\n<pre><code class=\"language-git\">git stash list\n</code></pre>\n<p>发现你没有完成的工作就在这里，然后恢复一下，这时有两种操作，一种是恢复后直接删除刚才的<code>list</code></p>\n<pre><code class=\"language-git\">git stash pop\n</code></pre>\n<p>另一种是先恢复，后删除</p>\n<pre><code class=\"language-git\">git stash apply\ngit stash drop\n</code></pre>\n<h2>18、强行删除一个分支</h2>\n<pre><code class=\"language-git\">git branch -D name\n</code></pre>\n<h2>19、多人合作</h2>\n<p>（1）首先在github新建一个远程仓库，默认只有一个master分支，再手动建一个dev分支</p>\n<p>（2）克隆远程仓库到本地</p>\n<pre><code class=\"language-git\">git clone git@github.com:13836005450/gitskills.git\n</code></pre>\n<p>（3）当克隆过后，只克隆过来了一个master分支，在操作前先更新一下本地仓库，把其它的分支都拉取下来</p>\n<pre><code class=\"language-git\">git pull\n</code></pre>\n<p>（4）本地的master分支与远程的master分支直接就关联到了一起，本地把远程的master分支叫做origin，从本地创建一个dev分支，与远程的dev分支关联</p>\n<pre><code class=\"language-git\">git checkout -b dev origin/dev\n</code></pre>\n<p>（5）然后就直接正常操作了，注意，每次写代码前先更新一下当前的仓库，然后再正常上传推送</p>\n<pre><code class=\"language-git\">git pull\ngit push origin dev\n</code></pre>\n<p>（6）如果dev分支不让pull，出现&quot;no tracking information&quot;，应该是本地的dev分支与远程的dev分支没有关联上</p>\n<pre><code class=\"language-git\">git branch --set-upstream dev origin/dev\n</code></pre>\n<h2>20、标签管理</h2>\n<p>发布⼀个版本时，我们通常先在版本库中打⼀个标签，这样，就唯⼀确定了打标签时刻的版<br />\n本。将来⽆论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。<br />\n所以，标签也是版本库的⼀个快照。</p>\n<p>（1）为最新的commit打一个标签</p>\n<pre><code class=\"language-git\">git tag v1.0\n</code></pre>\n<p>（2）查看所有的commit，为其中的某一个打一个标签</p>\n<pre><code class=\"language-git\">git log --pretty=oneline --abbrev-commit\ngit tag v0.9 4846\n</code></pre>\n<p>（3）打一个带有备注的标签</p>\n<pre><code class=\"language-git\">git tag -a v0.1 -m &quot;version 0.1 released&quot; 86fc\n</code></pre>\n<p>（4）查看所有标签</p>\n<pre><code class=\"language-git\">git tag\n</code></pre>\n<p>（5）查看标签的详细信息</p>\n<pre><code class=\"language-git\">git show v1.0\n</code></pre>\n<p>（6）删除标签</p>\n<pre><code class=\"language-git\">git tag -d v0.1\n</code></pre>\n<p>（7）推送本地标签到远程</p>\n<pre><code class=\"language-git\">git push origin v1.0      推送一个\n或者\ngit push origin --tags    推送所有\n</code></pre>\n<p>（8）删除远程的标签</p>\n<pre><code class=\"language-git\">git tag -d v0.9    先删除本地的\ngit push origin :refs/tags/v0.9    再删除远端的\n</code></pre>\n<h2>21、忽略某些文件、.gitignore文件</h2>\n<p>（1）新建一个<code>.gitignore</code>文件</p>\n<pre><code class=\"language-git\">touch .gitignore\n</code></pre>\n<p>（2）编辑</p>\n<pre><code class=\"language-txt\"># 测试\ndist/\naa.txt\n</code></pre>\n<p>这样里面的dist文件夹和aa.txt就被忽略的，再用<code>git status</code>查看时就没有提示了。</p>\n', '2021-10-14 15:30:23', '2021-12-09 21:43:50');
INSERT INTO `t_blog` VALUES ('98816ad0-5f30-11ec-b395-6d1b1a7579ec', '从上往下打印二叉树', 'JZ32 从上往下打印二叉树', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 1, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171955982.png\" alt=\"image-20211217195512878\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171955063.png\" alt=\"image-20211217195524022\" /></p>\n<h2>代码</h2>\n<h3>代码1 层次遍历 输出结果</h3>\n<pre><code class=\"language-js\">/*\n层次遍历\n使用个队列辅助\n*/\nfunction PrintFromTopToBottom(root)\n{\n    if(!root) return []\n    \n    let q = [] // 使用数组模拟队列\n    q.push(root) // 入队\n    \n    let result = []\n    \n    // 开始层次遍历\n    while(q.length&gt;0){\n        let current = q.shift() // shift模拟出队\n        \n        // 挨个把本层的val塞到数组中\n        result.push(current.val)\n        \n        // 把下一次的节点入队\n        if(current.left){\n            q.push(current.left)\n        }\n        if(current.right){\n            q.push(current.right)\n        }\n    }\n    \n    return result\n    \n}\n</code></pre>\n<p>时间复杂度 O(N) ： N为二叉树的节点数量，层次遍历需循环N次。<br />\n空间复杂度 O(N) ： 最差情况下，当树为平衡二叉树时，最多有N/2个树节点同时在队列/栈中，使用O(N)大小的额外空间。</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=23280&amp;ru=/practice/a9d0ecbacef9410ca97463e4a5c83be7&amp;qru=/ta/coding-interviews/question-ranking\">JZ32 从上往下打印二叉树</a></p>\n', '2021-12-17 19:58:06', '2021-12-17 19:58:06');
INSERT INTO `t_blog` VALUES ('a3d1b000-60b8-11ec-b395-6d1b1a7579ec', '在二叉树中找到两个节点的最近公共祖先', 'JZ86 在二叉树中找到两个节点的最近公共祖先', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 3, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112191806838.png\" alt=\"image-20211219180635761\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112191806994.png\" alt=\"image-20211219180649954\" /></p>\n<h2>代码</h2>\n<h3>代码1 两次深度优先遍历，找到各自的路径，然后找最近公共父节点的值</h3>\n<pre><code class=\"language-js\">/*\n深度优先遍历 分别找到到两个节点的路径\n把路径保存到数组中\n然后两个路径有长有短，只需要遍历短的长度即可，因为路径都是从根节点开始的，最差也会返回一个根节点\n比如 一个路径为 3 5 6\n另一个路径为 3 5 2 7\n一个节点是6，一个节点是7，所以只需比较三次即可\n*/\nfunction lowestCommonAncestor( root ,  o1 ,  o2 ) {\n    \n    let arr1 = [] // 保存到达o1的路径\n    let arr2 = [] // 保存到达o2的路径\n    \n    // 是否找到了这个节点，如果找到了就更新为true，跳出搜索\n    let isFind = false \n    \n    // dfs遍历root，分别找到到达o1和o2的路径信息\n    dfs(root, o1, arr1)\n    isFind = false // 重置一下\n    dfs(root, o2, arr2)\n    \n    // 开始查找最近的公共父节点，从头开始找\n    let i = 0\n    let result = null // 找到的最近父节点\n    let size = Math.min(arr1.length,arr2.length)\n    \n    while( i &lt; size){ // 倒着找，从倒数第二个开始找\n        if(arr1[i] !== arr2[i]) break;\n        result = arr1[i]\n        i++\n    }\n    \n    return result // 返回最近公共父节点\n    \n    \n    // 深度遍历，找到路径，保存到数组中\n    function dfs(root, o, arr){\n        // 出口，遍历到最后的空节点了\n        if(root === null) return\n        \n        arr.push(root.val)\n        // 如果找到了，更新标识，递归提前返回结果\n        if(root.val === o) {\n            isFind = true\n            return\n        }\n        \n        dfs(root.left, o, arr)\n        if(isFind) return // 如果已经找到了，提前返回\n        dfs(root.right, o, arr)\n        if(isFind) return // 如果已经找到了，提前返回\n        \n        // 如果发生回溯了，路径减一（即：把最后一个塞进去的值pop出去）\n        arr.pop()\n    }\n    \n}\n</code></pre>\n<p>时间复杂度O(n)：两次dfs递归，每次最多递归n次。</p>\n<p>空间复杂度O(n)：两个存储路径的数组和递归的栈内存开销。</p>\n<h3>代码2 递归求解（得仔细寻思代码才能想明白）</h3>\n<pre><code class=\"language-js\">/*\n递归求解\n三种情况\n1. 都在左侧\n2. 都在右侧\n3. 左右两侧\n*/\nfunction lowestCommonAncestor( root ,  o1 ,  o2 ) {\n    \n    return dfs(root ,  o1 ,  o2).val\n    \n    function dfs(root ,  o1 ,  o2) {\n        if(root === null) return null //超过叶节点，返回空\n        if(root.val === o1 || root.val === o2) return root //节点为其中一个\n        \n        let lval = dfs(root.left ,  o1 ,  o2)\n        let rval = dfs(root.right ,  o1 ,  o2)\n        if(lval === null) return rval //此时两个节点都在右侧 \\\n        if(rval === null) return lval //此时两个节点都在左侧 /\n        \n        return root //此时两个节点分别位于左右两侧 / \\\n    }\n}\n</code></pre>\n<p>参考解析：<a href=\"https://blog.nowcoder.net/n/1195f0380d404496aeab25609fae2c7d?f=comment\">题解 | #在二叉树中找到两个节点的最近公共祖先#</a></p>\n<p>时间复杂度O(n)</p>\n<p>空间复杂度O(n)</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/e0cc33a83afe4530bcec46eba3325116?tpId=13&amp;tqId=1024325&amp;ru=/practice/965fef32cae14a17a8e86c76ffe3131f&amp;qru=/ta/coding-interviews/question-ranking\">JZ86 在二叉树中找到两个节点的最近公共祖先</a></p>\n', '2021-12-19 18:44:28', '2021-12-19 18:44:28');
INSERT INTO `t_blog` VALUES ('a75b0ab0-557c-11ec-96d5-7933aca11ca0', '锚点（Anchors）：字符串开始^和末尾$', '插入符号 `^` 和美元符号 `$` 在正则表达式中具有特殊的意义。它们被称为“锚点”。\n\n插入符号 `^` 匹配文本开头，而美元符号 `$` － 则匹配文本末尾。', '-1', 2, 'https://zh.javascript.info/regexp-anchors', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 3, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>插入符号 <code>^</code> 和美元符号 <code>$</code> 在正则表达式中具有特殊的意义。它们被称为“锚点”。</p>\n<p>插入符号 <code>^</code> 匹配文本开头，而美元符号 <code>$</code> － 则匹配文本末尾。</p>\n<h2>一个例子</h2>\n<p>举个例子，让我们测试一下文本是否以 <code>Mary</code> 开头：</p>\n<pre><code class=\"language-js\">let str1 = &quot;Mary had a little lamb&quot;;\nconsole.log(/^Mary/.test(str1)); // true\n</code></pre>\n<p>该模式 <code>^Mary</code> 的意思是：字符串开始，接着是 “Mary”。</p>\n<p>与此类似，我们可以用 <code>snow$</code> 来测试文本是否以 <code>snow</code> 结尾:</p>\n<pre><code class=\"language-js\">let str1 = &quot;it\'s fleece was white as snow&quot;;\nconsole.log( /snow$/.test(str1) ); // true\n</code></pre>\n<p>在以上这些具体的例子中我们实际上可以用 <code>startsWith/endsWith</code> 来代替。正则表达式应该被用于更加复杂的测试中。</p>\n<h2>测试完全匹配</h2>\n<p>这两个锚点 <code>^...$</code> 放在一起常常被用于测试一个字符串是否完全匹配一个模式。比如，测试用户的输入是否符合正确的格式。</p>\n<p>让我们测试一下一个字符串是否属于 <code>12:34</code> 格式的时间。即，两个数字，然后一个冒号，接着是另外两个数字。</p>\n<p>用正则表达式来表示就是 <code>\\d\\d:\\d\\d</code>：</p>\n<pre><code class=\"language-js\">let goodInput = &quot;12:34&quot;;\nlet badInput = &quot;12:345&quot;;\n\nlet regexp = /^\\d\\d:\\d\\d$/;\nconsole.log( regexp.test(goodInput) ); // true\nconsole.log( regexp.test(badInput) ); // false\n</code></pre>\n<p>在这个例子中 <code>\\d\\d:\\d\\d</code> 所对应的匹配文本必须正好在文本开头 <code>^</code> 之后，而在这之后必须紧跟文本末尾 <code>$</code>。</p>\n<p>整个字符串必须准确地符合这一个格式。如果其中有任何偏差或者额外的字符，结果将为 <code>false</code>。</p>\n<p>当修饰符 <code>m</code> 出现时，锚点将会有不同的行为。我们将在后面学习到。</p>\n<blockquote>\n<p><strong>锚点具有“零宽度”</strong></p>\n<p>锚点 <code>^</code> 和 <code>$</code> 属于测试。它们的宽度为零。</p>\n<p>换句话来说，它们并不匹配一个具体的字符，而是让正则引擎测试所表示的条件（文本开头/文本末尾）。</p>\n</blockquote>\n<h2>总结</h2>\n<p>使用正则的开始锚点<code>^</code>和结束锚点<code>$</code>，可以测试一个字符串是否完全匹配。</p>\n<p>如果单存的为了判断字符串是否以某个字符串开头或结尾，可以使用<code>startsWith/endsWith</code> 来代替。</p>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-anchors\">https://zh.javascript.info/regexp-anchors</a></p>\n', '2021-12-05 11:37:21', '2021-12-05 11:37:21');
INSERT INTO `t_blog` VALUES ('a8f45760-58f5-11ec-96d5-7933aca11ca0', 'GMT、UTC和北京时间的关系', 'GMT 格林尼治标准时间、UTC 协调世界时间、北京时间、时区的划分，这些问题的答案都在这里了。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 1, 17, 0, 1, 2, 1, 'http://cdn.qiniu.bnbiye.cn/img/202112091736926.jpeg', '<h2>前言</h2>\n<p>在工作中，我们经常会使用到<code>js</code>的时间对象<code>Date</code>，比如直接<code>new</code>一个日期的实例对象<code>let date = new Date()</code>，来获取当前时间。我们看一下输出结果，来引出今天的几个问题：</p>\n<ol>\n<li>在浏览器的控制台输出：\n<pre><code class=\"language-js\">let date = new Date()\n\n// 直接打印当前时间\nconsole.log(date); // Thu Dec 09 2021 16:55:48 GMT+0800 (中国标准时间)\n\n// 获取时间戳\nconsole.log(date.getTime()); // 1639040148611\n\n// 获取本地时间，当前是几点\nconsole.log(date.getHours()); // 16\n\n// 获取UTC标准时间，当前是几点\nconsole.log(date.getUTCHours()); // 8\n\n// 获取 UTC标准时间 与 本地时区 之间的时差，单位是分钟\nconsole.log(date.getTimezoneOffset()); // -480  480/60 = 8h，相当于比UTC标准时间差了 8h\n</code></pre>\n</li>\n<li>在node端输出：\n<pre><code class=\"language-js\">let date = new Date()\n\n// 直接打印当前时间\nconsole.log(date); // 2021-12-09T08:58:34.625Z\n\n// 获取时间戳\nconsole.log(date.getTime()); // 1639040314625\n\n// 获取本地时间，当前是几点\nconsole.log(date.getHours()); // 16\n\n// 获取UTC标准时间，当前是几点\nconsole.log(date.getUTCHours()); // 8\n\n// 获取 UTC标准时间 与 本地时区 之间的时差，单位是分钟\nconsole.log(date.getTimezoneOffset()); // -480  480/60 = 8h，相当于比UTC标准时间差了 8h\n</code></pre>\n</li>\n</ol>\n<h3>思考的问题</h3>\n<ol>\n<li>浏览器端输出的当前时间直接转换为了中国标准时间<code>Thu Dec 09 2021 16:55:48 GMT+0800 (中国标准时间)</code>，这里的<code>GMT+0800</code>代表什么意思？</li>\n<li>每个时间都有一个时间戳，输出的时间戳是以什么为基准的，为什么不同时间的时间戳都不一样？</li>\n<li>每个获取时间的<code>API</code>都会对应有一个获取<code>UTC</code>的<code>API</code>，比如<code>getHours()</code>、<code>getUTCHours()</code>，这个<code>UTC</code>是个啥，为什么说它是标准时间？</li>\n<li>当我们使用<code>getTimezoneOffset()</code>获取<code>UTC</code>标准时间与中国本地时间的时差时，为什么会返回了<code>-480</code>分钟，也就是<code>8</code>小时，换句话说，为什么中国标准时间会和<code>UTC</code>标准时间有<code>8</code>小时的时差？</li>\n<li><code>node</code>端输出的当前时间的格式是<code>2021-12-09T08:58:34.625Z</code>，如果仔细观察会发现，把这个时间加上8小时，就正好是我当前的本地时间，那是不是<code>node</code>端输出的这个时间就是所谓的标准时间<code>UTC</code>呢？</li>\n</ol>\n<p>上面的问题有几个关键词：GMT、时间戳、UTC、中国标准时间、时差。</p>\n<p>本篇文章就来一点点的学习这些东西到底是怎么来的，学习完之后，上面的这些问题心中自然而然就会得出答案，耐下心一点点看到最后吧。</p>\n<h2>GMT（格林尼治标准时间）和 UTC （协调世界时间）</h2>\n<p>格林尼治位于伦敦郊区，其正好位于本初子午线（0度经线）上。格林尼治标准时间（Greenwich Mean Time，GMT），指的就是正午太阳横穿格林尼治子午线时的时间。1960年以前 GMT 曾作为基本时间计量系统被广泛应用，当时主要为了1840 年之后的铁路系统服务。</p>\n<p>但是后来，人们发现地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能和实际的太阳时相差16分钟。 地球每天的自转是有些不规则的，而且正在缓慢减速。所以，格林尼治时间就不是很准确了，每隔一阵就会有误差，所以就不再被作为标准时间使用了。</p>\n<p>于是后来就出现了 协调世界时间（Universal Time Coordinated，UTC），它是由原子钟提供的。 自1924年2月5日开始，格林尼治天文台每隔一小时会向全世界发放调时信息，UTC是基于标准的GMT提供的准确时间。</p>\n<p>原子时与以往的计时系统不同，它非常精确并且不以某地的平均太阳时为基准，但是遇有地球自转速度不均匀，原子时与世界时之间的时差便日积月累，因此，UTC 会在一段时期后加上正或负的闰秒来补偿。位于巴黎的国际地球自转事务中央局(IERS) 负责决定何时加入闰秒。</p>\n<p>现在为了方便，我们一般将GMT与UTC视为等同，它们都是标准时间。</p>\n<blockquote>\n<p>尽管UTC 更加科学更加精确，但是对于手表玩家和收藏者来说，GMT 仍是更加受欢迎的。有不少人认为，UTC 是巴黎图谋世界计时中心地位的一种手段。事实上，它是以原子时为基础，在时刻上尽量接近世界时的一种时间计量系统。它的出现是现代社会对于精确计时的需要。</p>\n</blockquote>\n<h2>时区的划分</h2>\n<p>知道了UTC与GMT的区别后，我们来了解一下时区的划分。</p>\n<p>我们都知道地球是一个大圆球，每天不同地方的人，看到太阳的时间也是不一样的，当我们夜晚做着美梦时，在地球的另一侧，说不定人们正在暖暖的晒着太阳。</p>\n<h3>一些地理知识</h3>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112091811075.png\" alt=\"image-20211209181111932\" /></p>\n<p>这里我们回顾一下初高中的地理知识：</p>\n<ol>\n<li>地轴：我们假想出来的一条数轴，横穿北极和南极的中心点，地球会绕着地轴自转。站在北极点俯视地球，地球是逆时针自转。</li>\n<li>赤道：通过地心与地轴垂直的平面，这个圈就是赤道。</li>\n<li>北回归线：太阳直射点直射的最北纬线。</li>\n<li>南回归线：太阳直射点直射的最南纬线。</li>\n<li>本初子午线：连接着南北两极中心点的的连线（0度经线），指示着南北方。国际上将通过英国伦敦格林尼治天文台原址的那条经线称为<code>0°</code>经线，也叫本初子午线。</li>\n<li>纬度：从赤道开始，范围是<code>0-90°</code>，赤道以北是北纬N，赤道以南是南纬S。纬度通常是指大地的纬度（就是有多长）。</li>\n<li>北极：北纬90°，N90</li>\n<li>南极：南纬90°，S90</li>\n</ol>\n<blockquote>\n<p>本初子午线的总长度大约是40005KM，1纬度大约111KM（40005/360=111.1333）</p>\n</blockquote>\n<h3>时区划分</h3>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112091736926.jpeg\" alt=\"img\" /></p>\n<p>从本初子午线（东经0度和西经0度线），向东或向西开始划分时区，将全球划分为24个时区，每个时区占15经度。（15*12=180），相差一小时。</p>\n<p>我们以东时区为例（西时区是一样的）：</p>\n<table>\n<thead>\n<tr>\n<th>时区</th>\n<th>范围</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>中时区（本初子午线，伦敦、格林尼治、GMT、UTC）</td>\n<td>（东经0度、西经0度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东1区</td>\n<td>（东经15度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东2区</td>\n<td>（东经30度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东3区</td>\n<td>（东经45度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东4区</td>\n<td>（东经60度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东5区</td>\n<td>（东经75度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东6区</td>\n<td>（东经90度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东7区</td>\n<td>（东经105度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东8区</td>\n<td>（东经120度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东9区</td>\n<td>（东经135度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东10区</td>\n<td>（东经150度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东11区</td>\n<td>（东经165度）左右偏移7.5度</td>\n</tr>\n<tr>\n<td>东12区（国际日界线，西12区）</td>\n<td>（东经180度、西经180度）左右偏移7.5度</td>\n</tr>\n</tbody>\n</table>\n<p>伦敦在中时区，向东开始分别为，东一、东二、...，一直到东12区。北京在东八区。</p>\n<p>也就是说，当伦敦时间为早上7点时，北京时间就为7+8=15时，下午三点。</p>\n<p>我们在前言中举的例子，输出<code>Thu Dec 09 2021 16:55:48 GMT+0800</code>，<code>GMT+0800</code>就表示比标准时间<code>GMT</code>多了<code>8</code>小时，所以换成标准时间就是<code>Thu Dec 09 2021 8:55:48 GMT+0000</code>，在<code>node</code>端输出的为<code>2021-12-09T08:58:34.625Z</code>，最后尾部的<code>z</code>实际就是代表的标准时间。</p>\n<p>所以我们在使用<code>getTimezoneOffset()</code>获取标准时间与本地时间的时差时，返回的是<code>-480</code>，正好是<code>8</code>小时。</p>\n<blockquote>\n<p>国际日界线：东经<code>180度</code>和西经<code>180度</code></p>\n<p>本初子午线：东经<code>0度</code>和西经<code>0度</code></p>\n<p>从中时区（本初子午线）向东，每跨越一个时区，时间就增加1小时，向西每跨越一个时区，时间就减少一小时。比如：</p>\n<p>拿伦敦时间（中时区）举例，以标准时间<code>GMT</code>为基准，假如此时伦敦是上午<code>12</code>点，表示为<code>12:00 GMT+0000</code></p>\n<p>那么东一区的时间就是<code>12+1=13</code>，下午一点，<code>13:00 GMT+0100</code>。此时北京（东八区）时间就是<code>12+8=20</code>，晚上<code>8</code>点，表示为<code>20:00 GMT+0800</code>。西一区的时间就为<code>12-1=11</code>，上午<code>11</code>点，表示为<code>11:00 GMT-0100</code>。</p>\n</blockquote>\n<blockquote>\n<p>所以就会出现一个很有意思的现象。东十二区比标准时间<code>GMT</code>快了<code>12</code>个小时，西十二区比标准时间慢了<code>12</code>个小时，所以当从东十二区向西十二区跨越时，或者从西十二区向东十二区跨越时，日期必然会变一天。</p>\n<ol>\n<li>东12→西12，日期减一天；</li>\n<li>西12→东12，日期加一天；</li>\n</ol>\n<p>举例说明：</p>\n<p>假如伦敦时间<code>2021-12-09 12:00:00 GMT+0000</code>，</p>\n<p>那东十二区就是，<code>12+12=24</code>，表示为，<code>2021-12-10 00:00:00 GMT+1200</code>，</p>\n<p>西十二区就是，<code>12-12=0</code>，表示为<code>2021-12-09 00:00:00 GMT-1200</code>，</p>\n<p>所以东十二区和西十二区正好是错一天。</p>\n</blockquote>\n<h2>时间戳</h2>\n<p>我们知道js中每个时间都有时间戳的概念，所谓的时间戳其实就是，从<code>1970-01-01 00:00:00</code>以来经过的毫秒数。在编程语言中，使用这种方式来表示时间更轻量。假如在<code>1970-01-01</code>之前的时间，会带有负的时间戳。</p>\n<blockquote>\n<p>1000ms = 1s</p>\n<p>60s = 1min</p>\n<p>60min = 1h</p>\n<p>24h = 1天</p>\n</blockquote>\n<pre><code class=\"language-js\">// 1970-01-01 00:00:00\nlet date1 = new Date(0)\nconsole.log(date1); // 1970-01-01T00:00:00.000Z\n\n// 1970-01-01 00:00:00 的后一秒，1970-01-01 00:00:01\nlet date2 = new Date(1000)\nconsole.log(date2); // 1970-01-01T00:00:01.000Z\n\n// 1970-01-01 00:00:00 的前一秒，1969-12-31 23:59:59\nlet date3 = new Date(-1000)\nconsole.log(date3); // 1969-12-31T23:59:59.000Z\n</code></pre>\n<h2>北京时间</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112092044738.png\" alt=\"image-20211209204406651\" /></p>\n<p>中国实际上时跨越了5个时区，东5、东6、东7、东8、东9，东西时间差异很大。</p>\n<p>当北京时间是早上八点时，哈尔滨的时间已经到了早晨九点，成都则为早上七点，乌鲁木齐为六点，而新疆最西端为凌晨五点。</p>\n<p>为了方便，全国都使用了统一时间：北京时间。</p>\n<p>所以有时候就出现了，这这个地方早上七点已经出太阳了，但是那个地方的天刚蒙蒙亮（虽然都是七点┓( ´∀` )┏）。</p>\n<blockquote>\n<p>中国目前使用的北京时间并不是北京市的地方平太阳时间（东经<code>116.4°</code>），而是东经<code>120°</code>的地方平太阳时间，二者相差约<code>14.5</code>分钟。北京时间由位于中国版图几何中心位置陕西临潼的中国科学院国家授时中心的9台铯原子钟和2台氢原子钟组通过精密比对和计算实现报时，并通过人造卫星与世界各国授时部门进行实时比对。</p>\n</blockquote>\n<p>全国统一时间有利于国内经贸往来，利于管理。不会为跨省的旅客造成不便，公共交通系统，尤其是飞机，高铁，增加了管理和协调的便利度，减少了相应的成本。另一方面，中国还取消了夏令时，但各单位可根据自身行业特点灵活决定上下班时间，为了照顾民众健康，很多学校会在炎热的夏季推迟下午上课时间，这种做法比起使用夏令时，会更加合理。</p>\n<blockquote>\n<p>什么是夏令时？</p>\n<p>夏令时是人为规定的时间，其目的是为了节约能源，也称之为“日光节约时制”和“夏令时间”。</p>\n<p>一般是夏天天亮的比较早时，启用夏令时，人为的将时间调快一小时。</p>\n<p>比如冬天天亮的晚，假如是早上八点亮，下午七点黑。你天亮（上午八点）上学，天黑（下午七点）睡觉。</p>\n<p>当来到夏天的时，天七点就亮了，下午六点黑，如果你还是按之前的时间上课（上午八点）和睡觉（下午七点），那相当于天亮了一小时才去上学，天黑了一小时后才去睡觉。这样就导致，起的晚，睡得晚。</p>\n<p>所以部分地区会采用夏令时，人为的将时间调快一小时，早上早一个小时上课，晚上提前一个小时放学，即早起了，也能早睡，充分利用光照资源，晚上提前放学，也不用多耗电了，变相的节约了照明成本。</p>\n<p>参考：<a href=\"https://baike.baidu.com/item/%E5%A4%8F%E4%BB%A4%E6%97%B6/1809579?fr=aladdin\">百度百科 夏令时</a></p>\n</blockquote>\n<h2>思考问题的答案</h2>\n<p>所以，通过上面的学习，我们自然而然的就能知道前言中几个问题的答案。</p>\n<ol>\n<li>浏览器端输出的当前时间直接转换为了中国标准时间<code>Thu Dec 09 2021 16:55:48 GMT+0800 (中国标准时间)</code>，这里的<code>GMT+0800</code>代表什么意思？<br />\nGMT+0800，显然表示，比标准时间快了八小时，这是东八区的时间。<br />\nGMT是格林尼治标准时间，格林尼治位于本初子午线上（东经0°和西经0°），在19世纪时以这个地方太阳照射横穿子午线的时间为基准，成为当时的标准时间。然后从本初子午线开始，每隔15°就会划分一个时间区间，本初子午线上的为中时区，往东为东1-东12区，往西为西1-西12区，每个区间相差一小时。北京在东八区，所以以<code>GMT+0800</code>的形式表示，意思为比标准时间快了8小时。</li>\n<li>每个时间都有一个时间戳，输出的时间戳是以什么为基准的，为什么不同时间的时间戳都不一样？<br />\n时间戳是自<code>1970-01-01 00:00:00</code>所经过的毫秒数，所以每个时间都会有一个唯一的毫秒值。</li>\n<li>每个获取时间的<code>API</code>都会对应有一个获取<code>UTC</code>的<code>API</code>，比如<code>getHours()</code>、<code>getUTCHours()</code>，这个<code>UTC</code>是个啥，为什么说它是标准时间？<br />\nUTC是协调世界时间，由于地球在椭圆轨道运动速度不均匀，就导致了GMT每隔一阵就会有小小的误差，后来出现了量子计时，GMT会每隔一段时间校准一次计时。可以将UTC和GMT都视为标准时间，所以那些带<code>UTC</code>的<code>API</code>，都是为了获取标准时间的。</li>\n<li>当我们使用<code>getTimezoneOffset()</code>获取<code>UTC</code>标准时间与中国本地时间的时差时，为什么会返回了<code>-480</code>分钟，也就是<code>8</code>小时，换句话说，为什么中国标准时间会和<code>UTC</code>标准时间有<code>8</code>小时的时差？<br />\n因为北京在东八区，没间隔一个时区相差一小时，东八区与中时区正好相差了八小时。</li>\n<li><code>node</code>端输出的当前时间的格式是<code>2021-12-09T08:58:34.625Z</code>，如果仔细观察会发现，把这个时间加上8小时，就正好是我当前的本地时间，那是不是<code>node</code>端输出的这个时间就是所谓的标准时间<code>UTC</code>呢？<br />\n没有错，可以这么认为。</li>\n</ol>\n<h2>总结</h2>\n<ol>\n<li>\n<p>GMT是格林尼治标准时，格林尼治位于伦敦郊区，正好位于本初子午线上（0°经线），早期是使用这里的时间作为世界标准时间，表示的是正午太阳从子午线横穿的时间。</p>\n</li>\n<li>\n<p>UTC是调和世界时，由原子钟提供，它非常接近于世界时，但是遇到地球不匀速转动时也会有误差，所以UTC会在一定的时间增加或减少一定的润秒来作补偿。</p>\n</li>\n<li>\n<p>我们在编程的时候，可以默认将GMT和UTC都看成标准时。</p>\n</li>\n<li>\n<p>根据经度的不同，以本初子午线为（0°经线）中心区，将地球划分为24个时区（每隔<code>15°</code>一个区）。本初子午线以东为东时区，以西为西时区，分别为东一、东二、...、东十二。西一、西二、...、西十二。</p>\n</li>\n<li>\n<p>每个时区间隔一小时，北京位于东八区，所以比UTC标准时间快了八小时，伦敦位于中时区，使用的是标准时间。美国纽约位于西五区，所以比标准时间慢了五小时。</p>\n</li>\n<li>\n<p>所以，当伦敦时间为早上七点的时候，北京则为下午三点（7+8=15），纽约则为凌晨2点（7-5=2）。</p>\n</li>\n<li>\n<p>所以就会有一个很有意思的现象，从东十二区跨越到西十二区时，天数会减1。（因为东十二区比标准时间快了12小时，西十二区比标准时间慢了12小时，两个时区一折合正好是一天）。反之，当从西十二区跨越到东十二区时，天数会加1。</p>\n</li>\n<li>\n<p>在JS中表示标准时间有两种方式，一种ISO格式、一种GMT格式</p>\n<pre><code class=\"language-js\">// 假如现在伦敦时间为，2021-12-10 10:19 am\n/*\nIS0的形式（UTC标准时区、中时区、伦敦）：\n	2021-12-10T10:19:00.000Z\n东八区（北京时间）比标准时间快了8小时\n	2021-12-10T18:19:00.000+0800\n西五区（华盛顿、纽约）比标准时间慢了5小时\n	2021-12-10T18:05:00.000-0500\n*/\n/*\nGMT的格式（GMT标准时区、中时区、伦敦）\n	Fri, 10 Dec 2021 10:19:00 GMT\n东八区（北京时间）比标准时间快了8小时\n	Fri, 10 Dec 2021 18:19:00 GMT+0800\n西五区（华盛顿、纽约）比标准时间慢了5小时\n	Fri, 10 Dec 2021 05:19:00 GMT-0500\n*/\n</code></pre>\n</li>\n<li>\n<p>中国地域非常辽阔，实际上是跨越了有5个时区，从最西边的新疆，一直到东边的黑龙江，横跨了东五、东六、东七、东八、东九五个时区，为了方便全国使用了统一时间，北京时间（在东八区）。</p>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://www.jb51.net/article/77636.htm\">https://www.jb51.net/article/77636.htm</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E6%97%B6/692237?fromtitle=GMT&amp;fromid=6026868#7\">https://baike.baidu.com/item/%E4%B8%96%E7%95%8C%E6%97%B6/692237?fromtitle=GMT&amp;fromid=6026868#7</a></p>\n<p><a href=\"https://zhidao.baidu.com/question/28164750.html\">https://zhidao.baidu.com/question/28164750.html</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%8C%97%E7%BA%AC/6676985?fr=aladdin\">https://baike.baidu.com/item/%E5%8C%97%E7%BA%AC/6676985?fr=aladdin</a></p>\n<p><a href=\"https://zhidao.baidu.com/question/183937808.html\">https://zhidao.baidu.com/question/183937808.html</a></p>\n<p><a href=\"https://baijiahao.baidu.com/s?id=1647276561381784162&amp;wfr=spider&amp;for=pc\">https://baijiahao.baidu.com/s?id=1647276561381784162&amp;wfr=spider&amp;for=pc</a></p>\n<p><a href=\"https://wenku.baidu.com/view/9e027f89d0d233d4b14e699d.html\">https://wenku.baidu.com/view/9e027f89d0d233d4b14e699d.html</a></p>\n<p><a href=\"https://baike.baidu.com/item/%E5%A4%8F%E4%BB%A4%E6%97%B6/1809579?fr=aladdin\">https://baike.baidu.com/item/%E5%A4%8F%E4%BB%A4%E6%97%B6/1809579?fr=aladdin</a></p>\n', '2021-12-09 21:41:06', '2021-12-11 11:08:05');
INSERT INTO `t_blog` VALUES ('aa11c6a0-5355-11ec-96d5-7933aca11ca0', 'js中String常用方法', '本篇文章对js中String类的常用方法做一个小结。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 8, 0, 1, 2, 1, '', '<h2>引言</h2>\n<p>本篇文章对js中String类的常用方法做一个小结。</p>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>用途</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>charAt()</td>\n<td>从一个字符串中返回指定的字符。</td>\n</tr>\n<tr>\n<td>charCodeAt()</td>\n<td>返回 <code>0</code> 到 <code>65535</code> 之间的整数，表示给定索引处的 UTF-16 代码单元</td>\n</tr>\n<tr>\n<td>codePointAt()</td>\n<td>返回 一个 Unicode 编码点值的非负整数。</td>\n</tr>\n<tr>\n<td>concat()</td>\n<td>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回。</td>\n</tr>\n<tr>\n<td>endsWith()</td>\n<td>用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 <code>true</code> 或 <code>false</code>。</td>\n</tr>\n<tr>\n<td>String.fromCharCode()</td>\n<td>静态 <strong><code>String.fromCharCode()</code></strong> 方法返回由指定的 UTF-16 代码单元序列创建的字符串。</td>\n</tr>\n<tr>\n<td>String.fromCodePoint()</td>\n<td><code>String.fromCodePoint()</code> 静态方法返回使用指定的代码点序列创建的字符串。</td>\n</tr>\n<tr>\n<td>includes()</td>\n<td>用于判断一个字符串是否包含在另一个字符串中，根据情况返回 true 或 false。</td>\n</tr>\n<tr>\n<td>indexOf()</td>\n<td>返回调用它的 <code>String</code> 对象中第一次出现的指定值的索引，从 <code>fromIndex</code> 处进行搜索。如果未找到该值，则返回 -1。</td>\n</tr>\n<tr>\n<td>lastIndexOf()</td>\n<td>返回调用<code>String</code>对象的指定值最后一次出现的索引，在一个字符串中的指定位置 <code>fromIndex</code>处从后向前搜索。如果没找到这个特定值则返回-1 。</td>\n</tr>\n<tr>\n<td>localeCompare()</td>\n<td>返回一个数字来指示一个参考字符串是否在排序顺序前面或之后或与给定字符串相同。</td>\n</tr>\n<tr>\n<td>match()</td>\n<td>检索返回一个字符串匹配正则表达式的结果。</td>\n</tr>\n<tr>\n<td>matchAll()</td>\n<td>返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</td>\n</tr>\n<tr>\n<td>normalize()</td>\n<td>按照指定的一种 Unicode 正规形式将当前字符串正规化。</td>\n</tr>\n<tr>\n<td>padEnd()</td>\n<td>会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充</td>\n</tr>\n<tr>\n<td>padStart()</td>\n<td>用另一个字符串填充当前字符串(如果需要的话，会重复多次)，以便产生的字符串达到给定的长度。从当前字符串的左侧开始填充。</td>\n</tr>\n<tr>\n<td>repeat()</td>\n<td>返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。</td>\n</tr>\n<tr>\n<td>replace()</td>\n<td>返回一个由替换值（<code>replacement</code>）替换部分或所有的模式（<code>pattern</code>）匹配项后的新字符串。</td>\n</tr>\n<tr>\n<td>replaceAll()</td>\n<td>返回一个新字符串，新字符串所有满足 <code>pattern</code> 的部分都已被<code>replacement</code> 替换。</td>\n</tr>\n<tr>\n<td>search()</td>\n<td>执行正则表达式和 <code>String</code> 对象之间的一个搜索匹配。</td>\n</tr>\n<tr>\n<td>slice()</td>\n<td>提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。</td>\n</tr>\n<tr>\n<td>split()</td>\n<td>使用指定的分隔符字符串将一个<code>String</code>对象分割成子字符串数组</td>\n</tr>\n<tr>\n<td>startsWith()</td>\n<td>用来判断当前字符串是否以另外一个给定的子字符串开头，并根据判断结果返回 <code>true</code> 或 <code>false</code>。</td>\n</tr>\n<tr>\n<td>substring()</td>\n<td>返回一个字符串在开始索引到结束索引之间的一个子集, 或从开始索引直到字符串的末尾的一个子集。</td>\n</tr>\n<tr>\n<td>toLocaleLowerCase()</td>\n<td>根据任何指定区域语言环境设置的大小写映射，返回调用字符串被转换为小写的格式。</td>\n</tr>\n<tr>\n<td>toLocaleUpperCase()</td>\n<td>根据本地主机语言环境把字符串转换为大写格式，并返回转换后的字符串。</td>\n</tr>\n<tr>\n<td>toLowerCase()</td>\n<td>将调用该方法的字符串值转为小写形式，并返回。</td>\n</tr>\n<tr>\n<td>toUpperCase()</td>\n<td>方法将调用该方法的字符串转为大写形式并返回（如果调用该方法的值不是字符串类型会被强制转换）。</td>\n</tr>\n<tr>\n<td>toString()</td>\n<td>返回指定对象的字符串形式。</td>\n</tr>\n<tr>\n<td>trim()</td>\n<td>从一个字符串的两端删除空白字符。</td>\n</tr>\n<tr>\n<td>trimRight()</td>\n<td>从一个字符串的末端移除空白字符。另一个别名为<code>trimEnd()</code></td>\n</tr>\n<tr>\n<td>trimLeft()</td>\n<td>从字符串的开头删除空格。另一个别名为<code>trimStart()</code></td>\n</tr>\n<tr>\n<td>valueOf()</td>\n<td>返回 <code>String</code>对象的原始值</td>\n</tr>\n</tbody>\n</table>\n<h2>静态方法</h2>\n<h3>String.fromCharCode()</h3>\n<p>方法返回由指定的 UTF-16 代码单元序列创建的字符串。</p>\n<p>语法：<code>String.fromCharCode(num1[, ...[, numN]])</code></p>\n<p>参数为<code>num1[, ...[, numN]]</code>：范围介于 <code>0</code> 到 <code>65535</code>（<code>0xFFFF</code>）之间。大于 <code>0xFFFF</code> 的数字将被截断。不进行有效性检查。</p>\n<pre><code class=\"language-js\">let str1 = String.fromCharCode(189, 43, 190, 61)\nconsole.log(str1); // ½+¾=\n\nlet str2 = String.fromCharCode(65, 66, 67, 68)\nconsole.log(str2); // ABCD\n</code></pre>\n<h3>String.fromCodePoint()</h3>\n<p>ES6新增的方法，<strong>返回使用指定的代码点序列创建的字符串。</strong></p>\n<pre><code class=\"language-js\">let str1 = String.fromCodePoint(9731, 9733, 9842, 0x2F804)\nconsole.log(str1); // ☃★♲你\n</code></pre>\n<blockquote>\n<p>tip：<code>String.fromCharCode()</code>和<code>String.fromCodePoint()</code>的区别</p>\n<p><code>fromCharCode</code>：参数的取值范围为<code>0</code> 到 <code>65535</code>（<code>0xFFFF</code>）之间，不能识别大于<code>0xFFFF</code>的码点，ES6 提供了<code>String.fromCodePoint()</code>方法，可以识别大于<code>0xFFFF</code>的字符，弥补了<code>String.fromCharCode()</code>方法的不足。比如：</p>\n<pre><code class=\"language-js\">let str1 = String.fromCharCode(0x20BB7)\nlet str2 = String.fromCodePoint(0x20BB7)\nconsole.log(str1); // ஷ \nconsole.log(str2); // 𠮷 \n// 二者输出的字符并不一样，\n// String.fromCharCode()不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，\n// 最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。\n\nlet str3 = String.fromCharCode(0x0BB7)\nlet str4 = String.fromCodePoint(0x0BB7)\nconsole.log(str3); // ஷ\nconsole.log(str4); // ஷ\n</code></pre>\n<p>参考：<a href=\"https://blog.csdn.net/ixygj197875/article/details/79090515\">https://blog.csdn.net/ixygj197875/article/details/79090515</a></p>\n</blockquote>\n<h2>原型上的方法</h2>\n<h3>获取字符或码点</h3>\n<h4>charAt()、charCodeAt()、codePointAt()</h4>\n<ol>\n<li>\n<p>charAt() 从一个字符串中返回指定的字符。</p>\n<pre><code class=\"language-js\">let str = \'hello world\'\nconsole.log(str.charAt()); // h 默认index为0\nconsole.log(str.charAt(0)); // h\nconsole.log(str.charAt(1)); // e\nconsole.log(str.charAt(2)); // l\nconsole.log(str.charAt(3)); // l\nconsole.log(str.charAt(4)); // o\nconsole.log(str.charAt(5)); // \'\'\nconsole.log(str.charAt(6)); // w\nconsole.log(str.charAt(100)); // \'\' 超出会返回空字符串\n</code></pre>\n</li>\n<li>\n<p>charCodeAt() 返回 <code>0</code> 到 <code>65535</code> 之间的整数，表示给定索引处的 UTF-16 代码单元</p>\n<pre><code class=\"language-js\">let str = \'abcdefg\'\nconsole.log(str.charCodeAt()); // 97 默认index为0\nconsole.log(str.charCodeAt(0)); // 97\nconsole.log(str.charCodeAt(1)); // 98\nconsole.log(str.charCodeAt(2)); // 99\nconsole.log(str.charCodeAt(3)); // 100\nconsole.log(str.charCodeAt(4)); // 101\nconsole.log(str.charCodeAt(5)); // 102\nconsole.log(str.charCodeAt(100)); // NaN 超出index的范围返回NaN\n</code></pre>\n</li>\n<li>\n<p>codePointAt() 返回 一个 Unicode 编码点值的非负整数。大于65535的也会正常返回</p>\n<pre><code class=\"language-js\">console.log(\'ABC\'.codePointAt(1));         // 66\nconsole.log(\'\\uD800\\uDC00\'.codePointAt(0)); // 65536\n\nconsole.log(\'XYZ\'.codePointAt(42)); // undefined 超出索引会返回undefined\n</code></pre>\n</li>\n</ol>\n<h3>查找子字符串</h3>\n<h4>indexOf()、lastIndexOf()、includes()、stratsWith()、endsWith()</h4>\n<ol>\n<li>\n<p>indexof() 返回子字符串第一次出现的索引位置，没找到就返回-1</p>\n<pre><code class=\"language-js\">let str = \'abcdabefg\'\nconsole.log(str.indexOf(\'ab\')); // 0\nconsole.log(str.indexOf(\'ab\', 3)); // 4  第二个参数表示从哪里开始找\nconsole.log(str.indexOf(\'d\')); // 3\nconsole.log(str.indexOf(\'hhh\')); // -1 没有就返回-1\n</code></pre>\n</li>\n<li>\n<p>lastIndexOf() 倒着找，没有就返回-1</p>\n<pre><code class=\"language-js\">let str = \'abcdabefg\'\nconsole.log(str.lastIndexOf(\'ab\')); // 4 倒着找\nconsole.log(str.lastIndexOf(\'ab\', 3)); // 0  倒着找 第二个参数表示从哪里开始找\nconsole.log(str.lastIndexOf(\'d\')); // 3\nconsole.log(str.lastIndexOf(\'hhh\')); // -1 没有就返回-1\n</code></pre>\n</li>\n<li>\n<p>includes() 是否包含子字符串，返回true或false</p>\n<pre><code class=\"language-js\">let str = \'ababccd\'\nconsole.log(str.includes(\'ab\')); // true\nconsole.log(str.includes(\'abc\')); // true\nconsole.log(str.includes(\'hh\')); // false\n</code></pre>\n</li>\n<li>\n<p>startsWith() 判断当前字符串是否以另外一个给定的子字符串开头，返回true或false</p>\n<pre><code class=\"language-js\">let str = \'ababccd\'\nconsole.log(str.startsWith(\'ab\')); // true\nconsole.log(str.startsWith(\'abc\')); // false\n</code></pre>\n</li>\n<li>\n<p>endsWith() 判断当前字符串是否以另外一个给定的子字符串结尾，返回true或false</p>\n<pre><code class=\"language-js\">let str = \'ababccd\'\nconsole.log(str.endsWith(\'ab\')); // false\nconsole.log(str.endsWith(\'cd\')); // true\n</code></pre>\n</li>\n</ol>\n<h3>生成新字符串</h3>\n<h4>slice()、subString()、repeat()、concat()、padStart()、padEnd()</h4>\n<ol>\n<li>\n<p>slice() 提取字符串的一部分，返回一个新的</p>\n<pre><code class=\"language-js\">let str = \'hello world\'\nconsole.log(str.slice(0)); // hello world 从索引0截取到末尾\nconsole.log(str.slice(0, 1)); // h 从索引0截取到索引1，不包含索引1\nconsole.log(str.slice(-3)); // rld 从倒数第三个字符截取到末尾\nconsole.log(str.slice(-3, -2)); // r 从倒数第三个字符截取到倒数第二个字符，不包含倒数第二个\n</code></pre>\n</li>\n<li>\n<p>subString() 截取字符串的一部分，</p>\n<p><code>substring</code> 提取从 <code>indexStart</code> 到 <code>indexEnd</code>（不包括）之间的字符。特别地：</p>\n<ul>\n<li>如果 <code>indexStart</code> 等于 <code>indexEnd</code>，<code>substring</code> 返回一个空字符串。</li>\n<li>如果省略 <code>indexEnd</code>，<code>substring</code> 提取字符一直到字符串末尾。</li>\n<li>如果任一参数小于 0 或为 <code>NaN</code>，则被当作 0。</li>\n<li>如果任一参数大于 <code>stringName.length</code>，则被当作 <code>stringName.length</code>。</li>\n<li>如果 <code>indexStart</code> 大于 <code>indexEnd</code>，则 <code>substring</code> 的执行效果就像两个参数调换了一样。见下面的例子。</li>\n</ul>\n<pre><code class=\"language-js\">let anyString = &quot;Mozilla&quot;;\n\n// 输出 &quot;Moz&quot;\nconsole.log(anyString.substring(0,3));\nconsole.log(anyString.substring(3,0));\nconsole.log(anyString.substring(3,-3));\nconsole.log(anyString.substring(3,NaN));\nconsole.log(anyString.substring(-2,3));\nconsole.log(anyString.substring(NaN,3));\n\n// 输出 &quot;lla&quot;\nconsole.log(anyString.substring(4,7));\nconsole.log(anyString.substring(7,4));\n\n// 输出 &quot;&quot;\nconsole.log(anyString.substring(4,4));\n\n// 输出 &quot;Mozill&quot;\nconsole.log(anyString.substring(0,6));\n\n// 输出 &quot;Mozilla&quot;\nconsole.log(anyString.substring(0,7));\nconsole.log(anyString.substring(0,10));\n</code></pre>\n</li>\n<li>\n<p>repeat() 把原来的字符串重复多少遍建一个新的字符串</p>\n<pre><code class=\"language-js\">console.log(&quot;abc&quot;.repeat(0));    // &quot;&quot;\nconsole.log(&quot;abc&quot;.repeat(1));    // &quot;abc&quot;\nconsole.log(&quot;abc&quot;.repeat(2));    // &quot;abcabc&quot;\nconsole.log(&quot;abc&quot;.repeat(3.5));  // &quot;abcabcabc&quot; 参数count将会被自动转换成整数，向下取整\n</code></pre>\n</li>\n<li>\n<p>concat() 拼接字符串，返回一个新的</p>\n<pre><code class=\"language-js\">let hello = \'Hello, \'\nconsole.log(hello.concat(\'Kevin\', \'. Have a nice day.\'))\n// Hello, Kevin. Have a nice day.\n\nlet greetList = [\'Hello\', \' \', \'Venkat\', \'!\']\nconsole.log(&quot;&quot;.concat(...greetList));  // &quot;Hello Venkat!&quot;\n\nconsole.log(&quot;&quot;.concat({}));   // [object Object]\nconsole.log(&quot;&quot;.concat([]));  // &quot;&quot;\nconsole.log(&quot;&quot;.concat(null));  // &quot;null&quot;\nconsole.log(&quot;&quot;.concat(true));  // &quot;true&quot;\nconsole.log(&quot;&quot;.concat(4, 5));  // &quot;45&quot;\n</code></pre>\n</li>\n<li>\n<p>padStart() 在字符串的左边填充一堆字符串，满足length</p>\n<pre><code class=\"language-js\">let str = \'abc\'\nconsole.log(str.padStart(10, \'cheny\')); // chenychabc\nconsole.log(str.padStart(10, \'*\')); // *******abc\nconsole.log(str.padStart(1, \'cheny\')); // abc 如果长度变小了，就忽略，返回原来的字符串\n</code></pre>\n</li>\n<li>\n<p>padEnd() 在字符串的右边填充一堆字符串，满足length</p>\n<pre><code class=\"language-js\">let str = \'abc\'\nconsole.log(str.padEnd(10, \'cheny\')); // abcchenych\nconsole.log(str.padEnd(10, \'*\')); // abc*******\nconsole.log(str.padEnd(1, \'cheny\')); // abc 如果长度变小了，就忽略，返回原来的字符串\n</code></pre>\n</li>\n</ol>\n<h3>转变大小写的</h3>\n<h4>toLowerCase()、toUpperCase()、toLocalLowerCase()、toLocalUpperCase()</h4>\n<ol>\n<li>\n<p>toLowerCase() 字符串值转为小写形式，并返回。</p>\n<pre><code class=\"language-js\">let str = \'ABC\'\nconsole.log(str.toLowerCase()); // abc\nconsole.log(str); // ABC\n</code></pre>\n</li>\n<li>\n<p>toUpperCase() 字符串值转为大写形式，并返回。</p>\n<pre><code class=\"language-js\">let str = \'abc\'\nconsole.log(str.toUpperCase()); // ABC\nconsole.log(str); // abc\n</code></pre>\n</li>\n<li>\n<p>toLocalLowerCase() 转换为小写（可以传地区，不同地区的Unicode也可能不一样，默认是主机环境的当前区域）</p>\n<pre><code class=\"language-js\">console.log(\'ALPHABET\'.toLocaleLowerCase()); // \'alphabet\'\nconsole.log(\'\\u0130\'.toLocaleLowerCase(\'tr\') === \'i\');    // true\nconsole.log(\'\\u0130\'.toLocaleLowerCase(\'en-US\') === \'i\'); // false\n</code></pre>\n</li>\n<li>\n<p>toLocalUpperCase() 转换为大写（可以传地区，不同地区的Unicode也可能不一样，默认是主机环境的当前区域）</p>\n<pre><code class=\"language-js\">const city = \'istanbul\';\nconsole.log(city.toLocaleUpperCase(\'en-US\')); // ISTANBUL\nconsole.log(city.toLocaleUpperCase(\'TR\')); // İSTANBUL\n</code></pre>\n</li>\n</ol>\n<h3>参数可以是正则的</h3>\n<h4>match()、matchAll()、replace()、replaceAll()、search()</h4>\n<ol>\n<li>match() 方法检索返回一个字符串匹配正则表达式的结果。</li>\n<li>matchAll() 返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</li>\n<li>replace() 方法返回一个由替换值（<code>replacement</code>）替换部分或所有的模式（<code>pattern</code>）匹配项后的新字符串。</li>\n<li>replaceAll() 返回一个新字符串，新字符串所有满足 <code>pattern</code> 的部分都已被<code>replacement</code> 替换。</li>\n<li>search() 执行正则表达式和 <code>String</code>对象之间的一个搜索匹配。</li>\n</ol>\n<blockquote>\n<p>具体使用方法将在正则表达式章节学习。参考：<a href=\"http://www.bnbiye.cn/#/articleDetail/02832040-583d-11ec-96d5-7933aca11ca0\">正则表达式（RegExp）和字符串（String）的方法</a></p>\n</blockquote>\n<h3>转数组的</h3>\n<h4>split()</h4>\n<p>以一个分隔符为基准，将一串字符串转换为数组。（参数也可以是正则）</p>\n<pre><code class=\"language-js\">let str1 = \'abc\'\nlet str2 = \'a b c\'\nlet str3 = \'a-b-c\'\n\nconsole.log(str1.split(\'\'))  // [ \'a\', \'b\', \'c\' ]\nconsole.log(str2.split(\' \')) // [ \'a\', \'b\', \'c\' ]\nconsole.log(str3.split(\'-\')) // [ \'a\', \'b\', \'c\' ]\n</code></pre>\n<h3>去除空格的</h3>\n<h4>trim()、trimLeft()、trimRight()</h4>\n<ol>\n<li>\n<p>trim() 去除左右两边空格</p>\n<pre><code class=\"language-js\">let str1 = \'  123  \'\nconsole.log(str1.trim()); // \'123\'\n</code></pre>\n</li>\n<li>\n<p>trimLeft() 去除左边的空格，也叫trimStart()</p>\n<pre><code class=\"language-js\">let str1 = \'  123  \'\nconsole.log(str1.trimStart()); // \'123  \'\nconsole.log(str1.trimLeft()); // \'123  \'\n</code></pre>\n</li>\n<li>\n<p>trimRight() 去除右边的空格，也叫trimEnd()</p>\n<pre><code class=\"language-js\">let str1 = \'  123  \'\nconsole.log(str1.trimEnd()); // \'  123\'\nconsole.log(str1.trimRight()); // \'  123\'\n</code></pre>\n</li>\n</ol>\n<h3>其他</h3>\n<h4>toString()、valueOf()</h4>\n<ol>\n<li>\n<p>toString() 返回一个字符串对象的字符串形式</p>\n<pre><code class=\"language-js\">var x = new String(&quot;Hello world&quot;);\nconsole.log(typeof x); // object\nlet y = x.toString()\nconsole.log(y); // \'Hello world\'\nconsole.log(typeof y) // string\n</code></pre>\n</li>\n<li>\n<p>valueOf() 返回字符串的原始值</p>\n<p>The <code>valueOf()</code> method of <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\"><code>String</code></a> returns the primitive value of a <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\"><code>String</code></a> object as a string data type. This value is equivalent to <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/toString\"><code>String.prototype.toString()</code></a>.</p>\n<p>其实内部的valueOf()就是toString()</p>\n<pre><code class=\"language-js\">var x = new String(&quot;Hello world&quot;);\nconsole.log(typeof x); // object\nlet y = x.valueOf()\nconsole.log(y); // \'Hello world\'\nconsole.log(typeof y) // string\n</code></pre>\n</li>\n</ol>\n<h2>总结</h2>\n<p>本章概括了字符串的常用方法，可以按功能记忆。</p>\n<ol>\n<li>\n<p>静态方法</p>\n<ol>\n<li>fromCharCode() 使用码点创建字符串，范围不能超过<code>65535 (0xffff)</code></li>\n<li>fromCodePoint() 使用码点创建字符串,es6新增的，范围可以超过<code>65535 (0xffff)</code></li>\n</ol>\n</li>\n<li>\n<p>原型方法</p>\n<ol>\n<li>\n<p>获取字符或码点</p>\n<ol>\n<li>cahrAt() 从一个字符串中返回指定的字符。</li>\n<li>charCodeAt() 返回 <code>0</code> 到 <code>65535</code> 之间的码点</li>\n<li>codePointAt() 返回指定位置字符的码点，大于65535的也会正常返回</li>\n</ol>\n</li>\n<li>\n<p>查找子字符串</p>\n<ol>\n<li>indexOf() 返回查找到的第一个子字符串的位置索引，没有返回-1</li>\n<li>lastIndexOf() 倒着查，没有返回-1</li>\n<li>includes() 返回true或false</li>\n<li>startsWith() 查找是否以子字符串为开头，返回true或false</li>\n<li>endsWith() 是否以子字符串为结尾，返回true或false</li>\n</ol>\n</li>\n<li>\n<p>生成新字符串</p>\n<ol>\n<li>\n<p>slice() 截取一段字符串，不传参默认截取全部，(0,1)表示从索引0截取到索引1，不包含索引1。参数还可以是负数，(-2,-1)表示，从倒数第二个截取到倒数第一个，不包含倒数第一个。</p>\n</li>\n<li>\n<p>subString() 也是截取一部分，</p>\n<p><code>substring</code> 提取从 <code>indexStart</code> 到 <code>indexEnd</code>（不包括）之间的字符。特别地：</p>\n<ul>\n<li>如果 <code>indexStart</code> 等于 <code>indexEnd</code>，<code>substring</code> 返回一个空字符串。</li>\n<li>如果省略 <code>indexEnd</code>，<code>substring</code> 提取字符一直到字符串末尾。</li>\n<li>如果任一参数小于 0 或为 <code>NaN</code>，则被当作 0。</li>\n<li>如果任一参数大于 <code>stringName.length</code>，则被当作 <code>stringName.length</code>。</li>\n<li>如果 <code>indexStart</code> 大于 <code>indexEnd</code>，则 <code>substring</code> 的执行效果就像两个参数调换了一样。</li>\n</ul>\n</li>\n<li>\n<p>repeat() 把原来的字符串重复多少遍，生成一个新的，比如<code>repeat(1)</code>，<code>repeat(2)</code>，如果传入的是小数，会默认向下取整。</p>\n</li>\n<li>\n<p>concat() 拼接字符串，返回一个新的</p>\n</li>\n<li>\n<p>padStart() 在字符串的左边填充一堆字符串，满足length</p>\n</li>\n<li>\n<p>padEnd() 在字符串的右边填充一堆字符串，满足length</p>\n</li>\n</ol>\n</li>\n<li>\n<p>转变大小写</p>\n<ol>\n<li>toLowerCase() 转换为小写</li>\n<li>toUpperCase() 转换为大写</li>\n<li>toLocalLowereCase() 转换为小写，可以传地区</li>\n<li>toLocalUpperCase() 转换为大写，可以传地区</li>\n</ol>\n</li>\n<li>\n<p>参数可以是正则的</p>\n<ol>\n<li>match() 方法检索返回一个字符串匹配正则表达式的结果。</li>\n<li>matchAll() 返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。</li>\n<li>replace() 方法返回一个由替换值（<code>replacement</code>）替换部分或所有的模式（<code>pattern</code>）匹配项后的新字符串。</li>\n<li>replaceAll() 返回一个新字符串，新字符串所有满足 <code>pattern</code> 的部分都已被<code>replacement</code> 替换。</li>\n<li>search() 执行正则表达式和 <code>String</code>对象之间的一个搜索匹配。</li>\n</ol>\n<p>（在正则部分在详细学习，参考：<a href=\"http://www.bnbiye.cn/#/articleDetail/02832040-583d-11ec-96d5-7933aca11ca0\">正则表达式（RegExp）和字符串（String）的方法</a>）</p>\n</li>\n<li>\n<p>转数组</p>\n<ol>\n<li>split() 以某个字符为基准，将字符串转换为数组</li>\n</ol>\n</li>\n<li>\n<p>去除空格</p>\n<ol>\n<li>trim() 去除左右两边的空格</li>\n<li>trimLeft() 去除左边的空格，也叫<code>trimStart()</code></li>\n<li>trimRight() 去除右边的空格，也叫<code>trimEnd()</code></li>\n</ol>\n</li>\n<li>\n<p>其他</p>\n<ol>\n<li>toString() 将String对象转换为字符串</li>\n<li>valueOf()  获取String对象的原始值，实际上就是toString()</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/54228216\">https://zhuanlan.zhihu.com/p/54228216</a></p>\n', '2021-12-02 17:53:13', '2021-12-09 09:48:54');
INSERT INTO `t_blog` VALUES ('aa9450f0-4f1f-11ec-96d5-7933aca11ca0', 'js中垃圾回收', '在学习闭包时，我们知道了内部函数可以访问外部函数的参数和变量，即使外部函数已经被返回（寿命终止）。那么你是否存在过这样一个疑惑，如果这些变量通过闭包的形式还能访问到，就说明它们仍旧存储在内存中，那假设我们在闭包中声明了很多很多的变量，有很多很多个这样的闭包，那内存肯定会有不够的时候，如果某个变量我们不再需要的时候，它还存储在内存中，这显然是不合理的？', '-1', 2, 'https://zh.javascript.info/garbage-collection', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 3, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>在学习闭包时，我们知道了内部函数可以访问外部函数的参数和变量，即使外部函数已经被返回（寿命终止）。那么你是否存在过这样一个疑惑，如果这些变量通过闭包的形式还能访问到，就说明它们仍旧存储在内存中，那假设我们在闭包中声明了很多很多的变量，有很多很多个这样的闭包，那内存肯定会有不够的时候，如果某个变量我们不再需要的时候，它还存储在内存中，这显然是不合理的？</p>\n<p>对于这种情况，js引擎是如何应对的？</p>\n<p>实际上，js引擎有一套独立的垃圾回收机制，对于那些不再使用的变量，js的垃圾回收器会自动删除它们，释放内存。</p>\n<p>本章就学习一下，js中，当我们不再需要某个东西时会发生什么？引擎是如何发现它并清理它？</p>\n<h2>可达性（Reachability）</h2>\n<p>JavaScript 中主要的内存管理概念是 <strong>可达性</strong>。</p>\n<p>简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。</p>\n<ol>\n<li>\n<p>这里列出固有的可达值的基本集合，这些值明显不能被释放。</p>\n<p>比方说：</p>\n<ul>\n<li>当前函数的局部变量和参数。</li>\n<li>嵌套调用时，当前调用链上所有函数的变量与参数。</li>\n<li>全局变量。</li>\n<li>（还有一些内部的）</li>\n</ul>\n<p>这些值被称作 <strong>根（roots）</strong>。</p>\n</li>\n<li>\n<p>如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的。</p>\n<p>比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 <strong>该</strong> 对象被认为是可达的。而且它引用的内容也是可达的。下面是详细的例子。</p>\n</li>\n</ol>\n<p>在 JavaScript 引擎中有一个被称作 <a href=\"https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)\">垃圾回收器</a> 的东西在后台执行。它监控着所有对象的状态，并删除掉那些已经不可达的。</p>\n<h2>一个简单的例子</h2>\n<p>这里是一个最简单的例子：</p>\n<pre><code class=\"language-js\">// user 具有对这个对象的引用\nlet user = {\n  name: &quot;John&quot;\n};\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261048080.png\" alt=\"image-20211126104849949\" /></p>\n<p>这里的箭头描述了一个对象引用。全局变量 <code>&quot;user&quot;</code> 引用了对象 <code>{name：&quot;John&quot;}</code>（为简洁起见，我们称它为 John）。John 的 <code>&quot;name&quot;</code> 属性存储一个原始值，所以它被写在对象内部。</p>\n<p>如果 <code>user</code> 的值被重写了，这个引用就没了：</p>\n<pre><code class=\"language-js\">user = null;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261050047.png\" alt=\"image-20211126105006006\" /></p>\n<p>现在 John 变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。</p>\n<h2>两个引用</h2>\n<p>现在让我们想象下，我们把 <code>user</code> 的引用复制给 <code>admin</code>：</p>\n<pre><code class=\"language-js\">// user 具有对这个对象的引用\nlet user = {\n  name: &quot;John&quot;\n};\n\nlet admin = user;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261050083.png\" alt=\"image-20211126105046043\" /></p>\n<p>现在如果执行刚刚的那个操作：</p>\n<pre><code class=\"language-js\">user = null;\n</code></pre>\n<p>……然后对象仍然可以被通过 <code>admin</code> 这个全局变量访问到，所以对象还在内存中。如果我们又重写了 <code>admin</code>，对象就会被删除。</p>\n<h2>相互关联的对象</h2>\n<p>现在来看一个更复杂的例子。这是个家庭：</p>\n<pre><code class=\"language-js\">function marry(man, woman) {\n  woman.husband = man;\n  man.wife = woman;\n\n  return {\n    father: man,\n    mother: woman\n  }\n}\n\nlet family = marry({\n  name: &quot;John&quot;\n}, {\n  name: &quot;Ann&quot;\n});\n</code></pre>\n<p><code>marry</code> 函数通过让两个对象相互引用使它们“结婚”了，并返回了一个包含这两个对象的新对象。</p>\n<p>由此产生的内存结构：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261051002.png\" alt=\"image-20211126105138956\" /></p>\n<p>到目前为止，所有对象都是可达的。</p>\n<p>现在让我们移除两个引用：</p>\n<pre><code class=\"language-js\">delete family.father;\ndelete family.mother.husband;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261052355.png\" alt=\"image-20211126105234305\" /></p>\n<p>仅删除这两个引用中的一个是不够的，因为所有的对象仍然都是可达的。</p>\n<p>但是，如果我们把这两个都删除，那么我们可以看到再也没有对 John 的引用了：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261052659.png\" alt=\"image-20211126105257613\" /></p>\n<p>对外引用不重要，只有传入引用才可以使对象可达。所以，John 现在是不可达的，并且将被从内存中删除，同时 John 的所有数据也将变得不可达。</p>\n<p>经过垃圾回收：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261053755.png\" alt=\"image-20211126105317713\" /></p>\n<h2>无法到达的岛屿</h2>\n<p>几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。</p>\n<p>源对象与上面相同。然后：</p>\n<pre><code class=\"language-js\">family = null;\n</code></pre>\n<p>内存内部状态将变成：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261054842.png\" alt=\"image-20211126105444794\" /></p>\n<p>这个例子展示了可达性概念的重要性。</p>\n<p>显而易见，John 和 Ann 仍然连着，都有传入的引用。但是，这样还不够。</p>\n<p>前面说的 <code>&quot;family&quot;</code> 对象已经不再与根相连，没有了外部对其的引用，所以它变成了一座“孤岛”，并且将被从内存中删除。</p>\n<h2>内部算法</h2>\n<p>垃圾回收的基本算法被称为 “mark-and-sweep”（标记and清除）。</p>\n<p>定期执行以下“垃圾回收”步骤：</p>\n<ul>\n<li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li>\n<li>然后它遍历并“标记”来自它们的所有引用。</li>\n<li>然后它遍历标记的对象并标记 <strong>它们的</strong> 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>\n<li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li>\n<li>没有被标记的对象都会被删除。</li>\n</ul>\n<p>例如，使我们的对象有如下的结构：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261056889.png\" alt=\"image-20211126105625844\" /></p>\n<p>我们可以清楚地看到右侧有一个“无法到达的岛屿”。现在我们来看看“标记和清除”垃圾收集器如何处理它。</p>\n<p>第一步标记所有的根：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261056369.png\" alt=\"image-20211126105640324\" /></p>\n<p>然后它们的引用被标记了：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261056145.png\" alt=\"image-20211126105659105\" /></p>\n<p>……如果还有引用的话，继续标记：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261057799.png\" alt=\"image-20211126105716753\" /></p>\n<p>现在，无法通过这个过程访问到的对象被认为是不可达的，并且会被删除。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111261057355.png\" alt=\"image-20211126105731310\" /></p>\n<p>我们还可以将这个过程想象成从根溢出一个巨大的油漆桶，它流经所有引用并标记所有可到达的对象。然后移除未标记的。</p>\n<p>这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不影响正常代码运行。</p>\n<p>一些优化建议：</p>\n<ul>\n<li><strong>分代收集（Generational collection）</strong>—— 对象被分成两组：“新的”和“旧的”。许多对象出现，完成它们的工作并很快死去，它们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。</li>\n<li><strong>增量收集（Incremental collection）</strong>—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理。这需要它们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟。</li>\n<li><strong>闲时收集（Idle-time collection）</strong>—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li>\n</ul>\n<p>还有其他垃圾回收算法的优化和风格。尽管我想在这里描述它们，但我必须打住了，因为不同的引擎会有不同的调整和技巧。而且，更重要的是，随着引擎的发展，情况会发生变化，所以在没有真实需求的时候，“提前”学习这些内容是不值得的。当然，除非你纯粹是出于兴趣。我在下面给你提供了一些相关链接。</p>\n<h2>总结</h2>\n<p>主要需要掌握的内容：</p>\n<ul>\n<li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li>\n<li>当对象是可达状态时，它一定是存在于内存中的。</li>\n<li>被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。</li>\n</ul>\n<p>现代引擎实现了垃圾回收的高级算法。</p>\n<p>《The Garbage Collection Handbook: The Art of Automatic Memory Management》（R. Jones 等人著）这本书涵盖了其中一些内容。</p>\n<p>如果你熟悉底层（low-level）编程，关于 V8 引擎垃圾回收器的更详细信息请参阅文章 <a href=\"http://jayconrod.com/posts/55/a-tour-of-v8-garbage-collection\">V8 之旅：垃圾回收</a>。</p>\n<p><a href=\"http://v8project.blogspot.com/\">V8 博客</a> 还不时发布关于内存管理变化的文章。当然，为了学习垃圾收集，你最好通过学习 V8 引擎内部知识来进行准备，并阅读一个名为 <a href=\"http://mrale.ph/\">Vyacheslav Egorov</a> 的 V8 引擎工程师的博客。我之所以说 “V8”，因为网上关于它的文章最丰富的。对于其他引擎，许多方法是相似的，但在垃圾收集上许多方面有所不同。</p>\n<p>当你需要底层的优化时，对引擎有深入了解将很有帮助。在熟悉了这门编程语言之后，把熟悉引擎作为下一步计划是明智之选。</p>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/garbage-collection#ke-da-xing-reachability\">https://zh.javascript.info/garbage-collection#ke-da-xing-reachability</a></p>\n', '2021-11-27 09:16:36', '2021-11-27 09:16:36');
INSERT INTO `t_blog` VALUES ('ac3475a0-5cc3-11ec-96d5-7933aca11ca0', '反转链表', 'JZ24 反转链表', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 5, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p>给定一个单链表的头结点pHead，长度为n，反转该链表后，返回新链表的表头。</p>\n<p>数据范围：1≤n≤1000</p>\n<p>要求：空间复杂度 O(1) ，时间复杂度 O(n) 。</p>\n<p>如当输入链表{1,2,3}时，</p>\n<p>经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。</p>\n<p>以上转换过程如下图所示：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112141635942.png\" alt=\"image-20211214163544874\" /></p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：{1,2,3}\n输出：{3,2,1}\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：{}\n输出：{}\n说明：空链表则输出空\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 暴力，先转数组，再转链表</h3>\n<ol>\n<li>先遍历链表，将链表转换为数组\n<ol>\n<li>使用<code>while</code>循环，因为是翻转的链表，构造数组时，直接先翻转好，使用<code>unshift</code></li>\n</ol>\n</li>\n<li>再通过数组，构建翻转后的链表\n<ol>\n<li>边界判断，如果数组长度为<code>0</code>，直接返回<code>null</code></li>\n<li>不为<code>0</code>，开始<code>for</code>循环遍历数组，构建新链表</li>\n</ol>\n</li>\n</ol>\n<pre><code class=\"language-js\">function ReverseList(pHead){\n    \n    // 1. 先转换为翻转好的数组\n    let tempArr = []\n    while(pHead){\n        tempArr.unshift(pHead.val)\n        pHead = pHead.next\n    }\n    \n    let len = tempArr.length\n    // 2. 如果数组长度为零，直接返回null\n    if(len === 0 ) return null \n    \n    // 3. 使用翻转好的数组开始构造链表\n    let newHead = new ListNode(tempArr[0]) // 等待返回的新头结点\n    let prevNode = newHead // 前一个节点，默认先是头节点\n    \n    // 从第二个节点开始遍历\n    for(let i = 1; i &lt; len; i++){\n        let currentNode = new ListNode(tempArr[i])\n        // 4. 如果是最后一个节点\n        if(i === len - 1 ) {\n            prevNode.next = currentNode\n            currentNode.next = null\n        }else {\n            // 5. 如果不是最后一个节点\n            prevNode.next = currentNode // 上一个节点的next指向把当前遍历的节点\n            prevNode = prevNode.next\n        }\n    }\n    return newHead\n}\n</code></pre>\n<h3>代码2 三个指针来回倒</h3>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112141739856.gif\" alt=\"aaa\" /></p>\n<p>使用三个指针</p>\n<ol>\n<li>prev = null</li>\n<li>current = Phead</li>\n<li>next = null</li>\n</ol>\n<p>使用while遍历，遍历时，遍历current</p>\n<ol>\n<li>先保存下一个节点 next = current.next</li>\n<li>然后把当前节点的next指向前一个节点（翻转链表的指向） current.next = prev</li>\n<li>把前一个节点prev指向当前的current，prev = current</li>\n<li>改变current，开始翻转下一个节点 current = next</li>\n</ol>\n<pre><code class=\"language-js\">function ReverseList(pHead){\n    if(!pHead) return null\n    \n    let current = pHead\n    let prev = null\n    let next = null\n    while(current){\n        next = current.next\n        current.next = prev\n        prev = current\n        \n        current = next\n    }   \n    return prev\n}\n</code></pre>\n<h3>代码3 递归</h3>\n<ul>\n<li>使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点</li>\n<li>此后，每次函数在返回的过程中，让当前结点的下一个结点的 next 指针指向当前节点。</li>\n<li>同时让当前结点的 next 指针指向NULL ，从而实现从链表尾部开始的局部反转</li>\n<li>当递归函数全部出栈后，链表反转完成。</li>\n</ul>\n<pre><code class=\"language-js\">function ReverseList(pHead){\n    // 递归的出口，遍历到最后一个节点时，返回\n    if(pHead === null || pHead.next === null){\n        return pHead\n    }\n    \n    // 每次递归都会保存当前的状态，比如{1,2,3}\n    // 第一次 1\n    // 第二次 2\n    // 第三次 3\n    // 遍历到3的时候，有返回值了，返回的就是最后一个节点\n    let vHead = ReverseList(pHead.next)\n    // 让当前节点下一个节点的next指向当前节点\n    pHead.next.next = pHead\n    // 同时让当前结点的 next 指针指向NULL ，从而实现从链表尾部开始的局部反转\n    pHead.next = null\n    \n    return vHead\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=23286&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\">JZ24 反转链表</a></p>\n', '2021-12-14 17:53:21', '2021-12-15 18:31:52');
INSERT INTO `t_blog` VALUES ('ae29d4d0-55a3-11ec-96d5-7933aca11ca0', 'Flag \"m\" — 多行模式', '通过 flag `/.../m` 可以开启多行模式。\n\n这仅仅会影响 `^` 和 `$` 锚符的行为。\n\n在多行模式下，它们不仅仅匹配文本的开始与结束，还匹配每一行的开始与结束。', '-1', 2, 'https://zh.javascript.info/regexp-multiline-mode', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 7, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>通过 flag <code>/.../m</code> 可以开启多行模式。</p>\n<p>这仅仅会影响 <code>^</code> 和 <code>$</code> 锚符的行为。</p>\n<p>在多行模式下，它们不仅仅匹配文本的开始与结束，还匹配每一行的开始与结束。</p>\n<h2>行的开头<code>^</code></h2>\n<p>在这个有多行文本的例子中，正则表达式 <code>/^\\d+/gm</code> 将匹配每一行的开头数字：</p>\n<pre><code class=\"language-js\">let str = `1st place: Winnie\n2nd place: Piglet\n33rd place: Eeyore`;\n\nconsole.log(str.match(/^\\d+/gm)); // [ \'1\', \'2\', \'33\' ]\n</code></pre>\n<p>没有 flag <code>/.../m</code> 时，仅仅是第一个数字被匹配到：</p>\n<pre><code class=\"language-js\">let str = `1st place: Winnie\n2nd place: Piglet\n33rd place: Eeyore`;\n\nconsole.log(str.match(/^\\d+/g)); // [ \'1\' ]\n</code></pre>\n<p>这是因为默认情况下，锚符 <code>^</code> 仅仅匹配文本的开头，在多行模式下，它匹配行的开头。</p>\n<p>正则表达式引擎将会在文本中查找以锚符 <code>^</code> 开始的字符串，我们找到之后继续匹配 <code>\\d+</code> 模式。</p>\n<h2>行的结尾<code>$</code></h2>\n<p>美元符 <code>$</code> 行为也相似。</p>\n<p>正则表达式 `\\w+$ 会找到每一行的最后一个单词：</p>\n<pre><code class=\"language-js\">let str = `1st place: Winnie\n2nd place: Piglet\n33rd place: Eeyore`;\n\nconsole.log(str.match(/\\w+$/gim)); // [ \'Winnie\', \'Piglet\', \'Eeyore\' ]\nconsole.log(str.match(/\\w+$/gi)); // [ \'Eeyore\' ]\n</code></pre>\n<p>没有 <code>/.../m</code> flag 的话，美元符 <code>$</code> 将会仅仅匹配整个文本的结尾，所以只有最后的一个单词会被找到。</p>\n<h2>锚符<code>^ $</code>对比<code>\\n</code></h2>\n<p>要寻找新的一行的话，我们不仅可以使用锚符 <code>^</code> 和 <code>$</code>，也可以使用换行符 <code>\\n</code>。</p>\n<p>它和锚符 <code>^</code> 和 <code>$</code> 的第一个不同点是它不像锚符那样，它会“消耗”掉 <code>\\n</code> 并且将其（<code>\\n</code>）加入到匹配结果中。</p>\n<p>举个例子，我们在下面的代码中用它来替代 <code>$</code>：</p>\n<pre><code class=\"language-js\">let str = `1st place: Winnie\n2nd place: Piglet\n33rd place: Eeyore`;\n\n// 用\\n匹配时，最后一个Eeyore就匹配不到了\nconsole.log(str.match(/\\w+\\n/gim)); // [ \'Winnie\\n\', \'Piglet\\n\' ]\n</code></pre>\n<p>这里，我们每次匹配到的时候都会被添加一个换行符。</p>\n<p>还有一个不同点——换行符 <code>\\n</code> 不会匹配字符串结尾。这就是为什么在上面的例子中 <code>Eeyore</code> 没有匹配到。</p>\n<p>所以，通常情况下使用锚符更棒，用它匹配出来的结果更加接近我们想要的结果。</p>\n<h2>总结</h2>\n<p><code>/xxxx/gim</code>，后面的标识符，<code>g</code>表示全文匹配，<code>i</code>表示不区分大小写，<code>m</code>表示开启多行模式。</p>\n<p>开启多行模式只会影响到锚点符号<code>^</code>和<code>$</code>，它俩原本是全文匹配字符串的开头和结尾，一旦开启多行模式后，它不仅匹配全文的开始和结束，还会匹配每一行的开始和结束。</p>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-multiline-mode\">https://zh.javascript.info/regexp-multiline-mode</a></p>\n', '2021-12-05 16:16:43', '2021-12-05 16:16:43');
INSERT INTO `t_blog` VALUES ('b1cd1a30-5d6d-11ec-96d5-7933aca11ca0', '链表中环的入口结点', 'JZ23 链表中环的入口结点', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 4, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。</p>\n<p>数据范围： n≤10000，1&lt;=结点值&lt;=10000</p>\n<p>要求：空间复杂度 O(1)，时间复杂度 O(n)</p>\n<p>例如，输入{1,2},{3,4,5}时，对应的环形链表如下图所示：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112151207328.png\" alt=\"image-20211215120753256\" /></p>\n<p>可以看到环的入口结点的结点值为3，所以返回结点值为3的结点。</p>\n<h3>输入描述：</h3>\n<p>输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表</p>\n<h3>返回值描述：</h3>\n<p>返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。</p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：\n{1,2},{3,4,5}\n返回值：\n3\n说明：\n返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即3\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：\n{1},{}\n返回值：\n&quot;null&quot;\n说明：\n没有环，返回对应编程语言的空结点，后台程序会打印&quot;null&quot;\n</code></pre>\n<p>示例3</p>\n<pre><code class=\"language-js\">输入：\n{},{2}\n返回值：\n2\n说明：\n环的部分只有一个结点，所以返回该环形链表入口结点，后台程序打印该结点对应的结点值，即2\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 使用哈希法</h3>\n<h4>题解</h4>\n<p>可以遍历整个链表，每遍历一个节点，就把当前节点保存在Set中，当遍历到某个节点时，其已经在Set中存在了，就说明这个节点是环的开始，即：</p>\n<ol>\n<li>遍历单链表的每个结点</li>\n<li>如果当前结点地址没有出现在set中，则存入set中</li>\n<li>否则，出现在set中，则当前结点就是环的入口结点</li>\n<li>整个单链表遍历完，若没出现在set中，则不存在环</li>\n</ol>\n<h4>代码</h4>\n<pre><code class=\"language-js\">function EntryNodeOfLoop(pHead){\n    // 声明一个set用来存储已经遍历过的节点\n    let linkset = new Set()\n    let loopNode = null // 返回的结果\n    \n    while(pHead){\n        // 若果set中已经有这个值了，说明它就是环的起始位置\n        if(linkset.has(pHead)){\n            loopNode = pHead\n            break\n        }\n        // 挨个遍历\n        linkset.add(pHead)\n        pHead = pHead.next\n    }\n    return loopNode\n}\n</code></pre>\n<h3>代码2 快慢指针法</h3>\n<p>这个是个定理，有环的链表中，</p>\n<p>快满指针都从表头开始</p>\n<ol>\n<li>快指针每次走两步，慢指针每次走一步，一定会在环中的某一个节点相遇（第一次相遇）</li>\n<li>在第一次相遇点上，将快指针挪至表头重新出发，二者都改为一次一步，下一次两个指针一定会在环口重新相遇（第二次相遇）。</li>\n</ol>\n<pre><code class=\"language-js\">/*\n设置 快、慢 指针\n	快指针走两步、慢指针走一步\n1. 假如有环，一定会相遇于环中的某点（结论1）\n2. 接着让两个指针分别从相遇点和链表头出发，两者都改为每次走一步，最终相遇于环入口(结论2)。\n*/\nfunction EntryNodeOfLoop(pHead)\n{\n    // 如果是空或者一个节点，且没有环，直接返回null\n    if(pHead === null || pHead.next ===null){\n        return null\n    }\n    \n    let fast = pHead // 快指针 \n    let slow = pHead // 满指针 \n    \n    while(fast){\n        fast = fast.next.next // 每次走两步\n        slow = slow.next // 每次走一步\n        \n        // 第一次相遇（结论1）一定会相遇在环的某一点\n        if(fast === slow){\n            fast = pHead // fast 从链表头从新出来，改为一次走一步\n            while(fast !== slow){\n                fast = fast.next\n                slow = slow.next\n            }\n            // 第二次相遇，（结论2）一定会在环口相遇\n            return fast\n        }\n    }\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=23449&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\">JZ23 链表中环的入口结点</a></p>\n', '2021-12-15 14:10:25', '2021-12-15 14:12:29');
INSERT INTO `t_blog` VALUES ('b384b510-3d8b-11ec-97a5-ef78eceb5d73', '优化关键渲染路径', '为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素:关键资源的数量、关键路径长度、关键字节的数量。', '-1', 2, 'https://developers.google.com/web/fundamentals/performance/critical-rendering-path/optimizing-critical-rendering-path', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 4, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素:</p>\n<ul>\n<li>关键资源的数量。</li>\n<li>关键路径长度。</li>\n<li>关键字节的数量。</li>\n</ul>\n<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。</p>\n<p>同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响: 某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。</p>\n<p>最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>\n<h2>优化步骤</h2>\n<p>**优化关键渲染路径的常规步骤如下: **</p>\n<ol>\n<li>对关键路径进行分析和特性描述: 资源数、字节数、长度。</li>\n<li>最大限度减少关键资源的数量: 删除它们，延迟它们的下载，将它们标记为异步等。</li>\n<li>优化关键字节数以缩短下载时间（往返次数）。</li>\n<li>优化其余关键资源的加载顺序: 您需要尽早下载所有关键资产，以缩短关键路径长度。</li>\n</ol>\n<p>下一节： <a href=\"http://www.bnbiye.cn/#/articleDetail/0a797310-3d8c-11ec-97a5-ef78eceb5d73\">优化首屏加载的规则和建议</a></p>\n', '2021-11-05 00:24:36', '2021-11-05 09:06:28');
INSERT INTO `t_blog` VALUES ('b3c57fd0-6083-11ec-b395-6d1b1a7579ec', '二叉树中和为某一值的路径(三)', 'JZ84 二叉树中和为某一值的路径(三)', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 1, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112191220494.png\" alt=\"image-20211219122042413\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112191220701.png\" alt=\"image-20211219122052659\" /></p>\n<h2>代码</h2>\n<h3>代码1 深度优先（dfs）遍历，把每个节点都进行一次深度优先遍历，找路径</h3>\n<pre><code class=\"language-js\">/*\n从根节点开始，对每个节点进行深度遍历\n*/\nfunction FindPath( root ,  sum ) {\n    if(!root) return 0\n    \n    let count = 0 // 默认是0条路径\n    \n    // 对每个节点进行深度遍历，找路径\n    dfs(root, sum)\n    \n    return count\n    \n    // 先遍历节点，然后对每个节点进行深度遍历 找符合结果的路径\n    function dfs(root, sum){\n        if(root === null) return;\n        \n        // 挨个节点遍历\n        find(root, sum)\n        dfs(root.left, sum)\n        dfs(root.right, sum)\n        \n    }\n    \n    // 对每个节点进行遍历 找路径\n    function find(root, sum){\n        if(root === null) return // 都遍历到头了，还是没有符合题意的\n        \n        sum -= root.val\n        \n        if(sum === 0) {\n            count++\n        }\n        \n        find(root.left, sum) \n        find(root.right, sum)\n    }\n}\n</code></pre>\n<p>时间复杂度O(n^2)：假如是一条链表，需要找 <code>n+(n-1)+(n-2)+...+2+1</code>，总共<code>(1+n)n/2</code>，所以时间复杂度是O(n^2)</p>\n<p>空间复杂度O(n)</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/965fef32cae14a17a8e86c76ffe3131f?tpId=13&amp;tqId=2277604&amp;ru=/practice/cf7e25aa97c04cc1a68c8f040e71fb84&amp;qru=/ta/coding-interviews/question-ranking\">JZ84 二叉树中和为某一值的路径(三)</a></p>\n', '2021-12-19 12:25:31', '2021-12-19 12:25:31');
INSERT INTO `t_blog` VALUES ('b51d3e10-3214-11ec-bd70-1746ca2eb62a', 'css盒模型', 'css盒子模型 标准盒模型 实际的宽高 = width + padding + border 怪异盒模型 实际的宽高 = width', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 4, 5, 5, 1, 2, 1, 'http://82.156.76.49:20517/upload/png/2021-10-21/9fcfc050-3214-11ec-bd70-1746ca2eb62a.png', '<h1>css盒子模型</h1>\n<h2>标准盒模型</h2>\n<p>实际的宽高 = <code>width + padding + border</code></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    .box {\n        width: 200px;\n        height: 200px;\n        background-color: green;\n        padding: 10px;\n        border: 10px solid red;\n        margin: 10px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d83494e131341e0972a899cf33ed42e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211021094904520.png\" /></p>\n<blockquote>\n<p>tip：中间内容区域被称为<code>content</code>，标准盒模型中设置的宽高，实际就是设置的<code>content</code>的宽高，假如我们设置了<code>width: 200px</code>，同时又设置了<code>padding</code>和<code>border</code>，那么实际盒子的宽度会加上<code>padding</code>和<code>border</code>的宽度</p>\n<p>最终导致的效果就是盒子被撑开了。</p>\n</blockquote>\n<h2>怪异盒模型</h2>\n<p><code>实际的宽高 = width</code></p>\n<p>当给盒子设置<code>box-sizing: border-box;</code>时，会将盒子模型变为怪异盒模型，不过很方便我们布局，因为实际设置的width就是最终盒子的宽度，不会随着设置border和padding的宽度而撑开盒子，但是内容区域的宽高会被挤压，这点应该注意</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    .box {\n        width: 200px;\n        height: 200px;\n        background-color: green;\n        padding: 10px;\n        border: 10px solid red;\n        margin: 10px;\n        box-sizing: border-box;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77bfeb92bbcb4a57a2b0f3e7ef704adf~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211021095739559.png\" /></p>\n<blockquote>\n<p>这里我们设置了宽度是<code>200px</code>，<code>padding</code>和<code>border</code>设置的都是<code>10px</code>，所以盒子的<code>content</code>区域就被压缩成了<code>160px</code>，但是整体盒子的宽高还是<code>200px</code>，并没有被撑开，这就是怪异盒模型</p>\n</blockquote>\n<p>这个属性用着爽，但是在IE8之前的浏览器并不兼容，Edge12之前也不兼容，使用的时候注意点（不过现在好像都不管这些老旧的浏览器了，直接用就好了）</p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c21488a352a44a64a1c93c7d7fd8159e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211021100347214.png\" /></p>\n<p>css属性兼容性查看网站 <a href=\"https://caniuse.com/\">https://caniuse.com/</a></p>\n', '2021-10-21 10:15:06', '2021-12-09 21:43:50');
INSERT INTO `t_blog` VALUES ('b86f6770-50ee-11ec-96d5-7933aca11ca0', 'js中的类型转换', '在js的运算中，经常涉及到数据类型的转换，有时候是显示转换，有时是隐式转换，本章就来捋一捋各种数据类型之间的转换规则。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 8, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>在js的运算中，经常涉及到数据类型的转换，有时候是显示转换，有时是隐式转换，本章就来捋一捋各种数据类型之间的转换规则。先看一道题：</p>\n<pre><code class=\"language-js\">let result = 100 + true + 21.2 + null + undefined + &quot;cheny&quot; + [] + null + 9 + false;\n// result应该是？\n</code></pre>\n<p>你知道最终的答案吗？</p>\n<p>最终会输出<code>\'NaNchenynull9false\'</code>，题目考察的知识点是数据类型隐式转换，想要做对这道题，我们必须了解 JavaScript 在转换的时候，会遵循哪些规则。</p>\n<h3>例子分析</h3>\n<p>上面的例子我们来一点点的分析，从左往右一点点的看（先来看为什么得到这个结果，具体的细节先不关注）：</p>\n<ol>\n<li>\n<p><code>100 + true</code>的结果是什么？</p>\n<p>这里的<code>true</code>会被隐式地转换为数字<code>1</code>，所以得到的结果为<code>101</code></p>\n</li>\n<li>\n<p><code>101 + 21.2 + null</code>的结果是什么？</p>\n<p><code>101 + 21.2</code>做正常的加法，得到<code>122.2</code>，<code>null</code>被隐式地转换为数字<code>0</code>，所以最终的结果是<code>122.2</code></p>\n</li>\n<li>\n<p><code>122.2 + undefined</code>的结果是什么？</p>\n<p><code>undefined</code>会尝试去转换为数字与<code>122.2</code>做加法，但是<code>undefined</code>无法转换为数字，会被隐式的转换为<code>NaN</code>，任何数字与<code>NaN</code>做加法都会返回<code>NaN</code>，所以最终的结果是<code>NaN</code></p>\n</li>\n<li>\n<p><code>NaN + &quot;cheny&quot;</code>的结果是什么？</p>\n<p>右侧是字符串<code>&quot;cheny&quot;</code>，所以左侧的<code>NaN</code>会被隐式的转换为字符串<code>&quot;NaN&quot;</code>，最后的结果是字符串拼接的结果，<code>&quot;NaNcheny&quot;</code></p>\n</li>\n<li>\n<p><code>&quot;NaNcheny&quot; + [] </code>的结果是什么？</p>\n<p><code>[]</code>空数组会被隐士的转换为空字符串<code>\'\'</code>，所以最终的结果仍为，<code>&quot;NaNcheny&quot;</code></p>\n</li>\n<li>\n<p><code>&quot;NaNcheny&quot; + null </code></p>\n<p><code>null</code>会隐式的转换为字符串<code>&quot;null&quot;</code>，所以最终的结果为，<code>&quot;NaNchenynull&quot;</code></p>\n</li>\n<li>\n<p><code>&quot;NaNchenynull&quot; + 9 + false</code></p>\n<p>数字<code>9</code>会被隐式的转换为字符串<code>&quot;9&quot;</code>，布尔<code>fasle</code>也会被隐式的转换为字符串<code>&quot;false&quot;</code>，所以最终的结果为，<code>&quot;NaNchenynull9false&quot;</code></p>\n</li>\n</ol>\n<p>所以输出的最终结果为：<code>&quot;NaNchenynull9false&quot;</code>。</p>\n<h2>基本类型之间的转换</h2>\n<h3>字符串string</h3>\n<p>基本类型转换为字符串是最明显的，我们可以使用<code>String(value)</code>显示的将一个值转换为字符串，比如：</p>\n<pre><code class=\"language-js\">let value = true;\nconsole.log(typeof value); // boolean\n\nvalue = String(value); // 现在，值是一个字符串形式的 &quot;true&quot;\nconsole.log(typeof value); // string\n</code></pre>\n<p>当在做加法运算时，如果左侧是一个字符串，右侧不是字符串时，会隐式的将右侧的值转换为字符串做拼接，比如</p>\n<pre><code class=\"language-js\">let str = \'abc\' + true\nconsole.log(str) // abctrue\nconsole.log(typeof str); // string\n</code></pre>\n<h4>小结</h4>\n<p>基本类型转<code>string</code>类型是比较明显的</p>\n<ol>\n<li>\n<p>undefined ➡ string</p>\n<pre><code class=\"language-js\">// undefined -&gt; &quot;undefined&quot;\n</code></pre>\n</li>\n<li>\n<p>null ➡ string</p>\n<pre><code class=\"language-js\">// null -&gt; &quot;null&quot;\n</code></pre>\n</li>\n<li>\n<p>number ➡ string</p>\n<pre><code class=\"language-js\">// 123 -&gt; &quot;123&quot;\n// 5.6 -&gt; &quot;5.6&quot;\n// 0 -&gt; &quot;0&quot;\n// -567 -&gt; &quot;-567&quot;\n</code></pre>\n</li>\n<li>\n<p>bigint ➡ string</p>\n<pre><code class=\"language-js\">// 123n -&gt; &quot;123&quot;\n// 5.6n -&gt; &quot;5.6&quot;\n// 0n -&gt; &quot;0&quot;\n// -567n -&gt; &quot;-567&quot;\n</code></pre>\n</li>\n<li>\n<p>boolean ➡ string</p>\n<pre><code class=\"language-js\">// true -&gt; &quot;true&quot;\n// false -&gt; &quot;false&quot;\n</code></pre>\n</li>\n<li>\n<p>symbol ➡ string</p>\n<pre><code class=\"language-js\">// Symbol() -&gt; &quot;Symbol()&quot;\n// Symbol(123) -&gt; &quot;Symbol(123)&quot;\n// Symbol(\'123\') -&gt; &quot;Symbol(\'123\')&quot;\n</code></pre>\n</li>\n</ol>\n<h3>数字number</h3>\n<p>在算术函数和表达式中，会自动进行 number 类型转换。</p>\n<p>比如，当把除法 <code>/</code> 用于非 number 类型：</p>\n<pre><code class=\"language-js\">let a = &quot;6&quot; / &quot;2&quot;\nconsole.log(a); // 3\nconsole.log(typeof a); // number\n\nlet b = &quot;abc&quot; / &quot;2&quot;\nconsole.log(b); // NaN\n</code></pre>\n<p>我们也可以使用 <code>Number(value)</code> 显式地将这个 <code>value</code> 转换为 number 类型。</p>\n<pre><code class=\"language-js\">let str = &quot;123&quot;;\nconsole.log(typeof str); // string\n\nlet num = Number(str); // 变成 number 类型 123\n\nconsole.log(typeof num); // number\n</code></pre>\n<p>当我们从 string 类型源（如文本表单）中读取一个值，但期望输入一个数字时，通常需要进行显式转换。</p>\n<p>如果该字符串不是一个有效的数字，转换的结果会是 <code>NaN</code>。例如：</p>\n<pre><code class=\"language-js\">let age = Number(&quot;an arbitrary string instead of a number&quot;);\n\nconsole.log(age); // NaN，转换失败\n</code></pre>\n<h4>小结</h4>\n<p>基本类型转<code>number</code>类型：</p>\n<ol>\n<li>\n<p>undefined ➡ number</p>\n<pre><code class=\"language-js\">// undefined -&gt; NaN\n</code></pre>\n</li>\n<li>\n<p>null ➡ number</p>\n<pre><code class=\"language-js\">// null -&gt; 0\n</code></pre>\n</li>\n<li>\n<p>string➡ number</p>\n<pre><code class=\"language-js\">// &quot;&quot; -&gt; 0\n// &quot;   &quot; -&gt; 0\n// &quot; 123&quot; -&gt; 123\n// &quot; 123 &quot; -&gt; 123\n// &quot; 123 4&quot; -&gt; NaN\n// &quot; 123a&quot; -&gt; NaN\n</code></pre>\n<p>去掉首尾空格后的纯数字字符串中含有的数字。如果剩余字符串为空，则转换结果为 <code>0</code>。否则，将会从剩余字符串中“读取”数字。当类型转换出现 error 时返回 <code>NaN</code>。</p>\n</li>\n<li>\n<p>bigint ➡ number</p>\n<pre><code class=\"language-js\">// 123n -&gt; 123\n// 5.6n -&gt; 5.6\n// 0n -&gt; 0\n// -567n -&gt; -567\n</code></pre>\n<p>注意：number的取值范围在<code>(-(2^53), 2^53)</code>之间，如果<code>bigint</code>的值在这个范围之外时转换为<code>number</code>，多余的位会被截断，因此我们应该谨慎进行此类转换，比如：</p>\n<pre><code class=\"language-js\">// 9007199254740992  2^53\n// 900719925474099222n\n// 900719925474099200\n// Number(900719925474099222n) -&gt; 900719925474099200\n</code></pre>\n</li>\n<li>\n<p>boolean ➡ number</p>\n<pre><code class=\"language-js\">// true -&gt; 1\n// false -&gt; 0\n</code></pre>\n</li>\n<li>\n<p>symbol ➡ number</p>\n<p>symbol类型无法转换位number，会报错。</p>\n<pre><code class=\"language-js\">// Number(Symbol()) -&gt; Uncaught TypeError: Cannot convert a Symbol value to a number\n</code></pre>\n</li>\n</ol>\n<blockquote>\n<p>👨请注意 <code>null</code> 和 <code>undefined</code> 在这有点不同：<code>null</code> 变成数字 <code>0</code>，<code>undefined</code> 变成 <code>NaN</code>。</p>\n</blockquote>\n<h3>布尔boolean</h3>\n<p>布尔（boolean）类型转换是最简单的一个。</p>\n<p>它发生在逻辑运算中（稍后我们将进行条件判断和其他类似的东西），但是也可以通过调用 Boolean(value) 显式地进行转换。</p>\n<p>转换规则如下：</p>\n<ul>\n<li>直观上为“空”的值（如 <code>0</code>、空字符串、<code>null</code>、<code>undefined</code> 和 <code>NaN</code>）将变为 <code>false</code>。</li>\n<li>其他值变成 <code>true</code>。</li>\n</ul>\n<p>比如：</p>\n<pre><code class=\"language-js\">console.log( Boolean(1) ); // true\nconsole.log( Boolean(0) ); // false\n\nconsole.log( Boolean(&quot;hello&quot;) ); // true\nconsole.log( Boolean(&quot;&quot;) ); // false\n</code></pre>\n<blockquote>\n<p>👦<strong>请注意：包含 0 的字符串</strong> <code>&quot;0&quot;</code> <strong>是</strong> <code>true</code></p>\n<pre><code class=\"language-js\">console.log( Boolean(&quot;0&quot;) ); // true\nconsole.log( Boolean(&quot; &quot;) ); // 空白，也是 true（任何非空字符串都是 true）\n</code></pre>\n</blockquote>\n<h4>小结</h4>\n<p>基本类型转<code>boolean</code>类型：</p>\n<ol>\n<li>\n<p>undefined ➡ boolean</p>\n<pre><code class=\"language-js\">// undefined -&gt; false\n</code></pre>\n</li>\n<li>\n<p>null ➡ boolean</p>\n<pre><code class=\"language-js\">// null -&gt; false\n</code></pre>\n</li>\n<li>\n<p>string➡ boolean</p>\n<pre><code class=\"language-js\">// &quot;&quot; -&gt; false\n// &quot; &quot; -&gt; true\n// &quot;0&quot; -&gt; true\n</code></pre>\n</li>\n<li>\n<p>number➡ boolean</p>\n<pre><code class=\"language-js\">// 0 -&gt; false\n// 1 -&gt; true\n// 2 -&gt; true\n// NaN -&gt; false\n</code></pre>\n<p>除了数值<code>0</code>转换位<code>boolean</code>时为<code>false</code>，其它<code>number</code>都为<code>true</code>，另外特殊记忆一下<code>NaN</code>，它变布尔时也返回<code>false</code>。</p>\n</li>\n<li>\n<p>bigint➡ boolean</p>\n<pre><code class=\"language-js\">// 0n -&gt; false\n// 1n -&gt; true\n// 2n -&gt; true\n</code></pre>\n</li>\n<li>\n<p>symbol ➡ number</p>\n<pre><code class=\"language-js\">// Symbol() -&gt; true\n// Symbol(123) -&gt; true\n</code></pre>\n<p><code>symbol</code>类型转<code>boolean</code>都为<code>true</code></p>\n</li>\n</ol>\n<h2>对象到原始值的转换</h2>\n<h3>转换规则</h3>\n<h4>Symbol.toPrimitive</h4>\n<p>对象到原始类型的转换其实跟它的<code>Symbol.toPrimitive</code>方法有关，该方法接收一个形参<code>hint</code>，有三种可能情况</p>\n<ol>\n<li>\n<p>hint === string</p>\n<p>当期望得到的值是一个字符串时，传入<code>Symbol.toPrimitive</code>方法形参<code>hint</code>的值就为<code>string</code>。</p>\n<p>比如：<code>alert(obj)</code>，会默认的隐式转换<code>obj</code>为字符串。或者将对象作为属性键，<code>anotherObj[obj] = 123</code>（因为对象的属性值只能为字符串或者<code>symbol</code>，当对象作为一个个属性时，会隐式转换为字符串）。</p>\n<pre><code class=\"language-js\">// 输出\nalert(obj);\n\n// 将对象作为属性键\nanotherObj[obj] = 123;\n</code></pre>\n</li>\n<li>\n<p>hint === number</p>\n<p>当期望得到的值是一个数字时，传入<code>Symbol.toPrimitive</code>方法形参<code>hint</code>的值就为<code>number</code>。</p>\n<p>比如：显示转换为某个对象为<code>number</code>，<code>Number(obj)</code>，或者数学运算<code>+obj</code>，将<code>obj</code>转换为<code>number</code>。再或者<code>&gt; &lt;</code>对对象进行比较时。</p>\n<pre><code class=\"language-js\">// 显式转换\nlet num = Number(obj);\n\n// 数学运算（除了二元加法）\nlet n = +obj; // 一元加法\nlet delta = date1 - date2;\n\n// 小于/大于的比较\nlet greater = user1 &gt; user2;\n</code></pre>\n</li>\n<li>\n<p>hint === default</p>\n<p>当期望得到的值不确定时，传入<code>Symbol.toPrimitive</code>方法形参<code>hint</code>的值就为<code>default</code>。</p>\n<p>比如：<code>+</code>运算符可以作为数值相加，也可以作为字符串拼接，<code>obj + obj</code>。另外在做<code>==</code>比较时，也会做类型转换，如果对象被用于与字符串、数字、或者<code>Symbol</code>比较时，到底进行哪种转换也不确定，因此此时的<code>hint</code>也是<code>default</code>。</p>\n<pre><code class=\"language-js\">// 二元加法使用默认 hint\nlet total = obj1 + obj2;\n\n// obj == number 使用默认 hint\nif (user == 1) { ... };\n</code></pre>\n<p>像 <code>&lt;</code> 和 <code>&gt;</code> 这样的小于/大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 “number” hint，而不是 “default”。这是历史原因。实际上，我们没有必要记住这些奇特的细节，除了一种情况（<code>Date</code> 对象）之外，所有内建对象都以和 <code>&quot;number&quot;</code> 相同的方式实现 <code>&quot;default&quot;</code> 转换。我们也可以这样做。</p>\n</li>\n</ol>\n<blockquote>\n<p>注意：没有<code>hint === boolean</code>的情况，所有对象在转换为<code>boolean</code>类型时，都会返回<code>true</code></p>\n<p>如果我们将 <code>&quot;default&quot;</code> 和 <code>&quot;number&quot;</code> 视为相同，就像大多数内建函数一样，那么就只有两种转换了。</p>\n</blockquote>\n<p><strong>为了进行转换，JavaScript 尝试查找并调用三个对象方法：</strong></p>\n<ol>\n<li>调用 <code>obj[Symbol.toPrimitive](hint)</code> —— 带有 symbol 键 <code>Symbol.toPrimitive</code>（系统 symbol）的方法，如果这个方法存在的话，</li>\n<li>否则，如果 hint 是 <code>&quot;string&quot;</code> —— 尝试 <code>obj.toString()</code> 和 <code>obj.valueOf()</code>，无论哪个存在。</li>\n<li>否则，如果 hint 是 <code>&quot;number&quot;</code> 或 <code>&quot;default&quot;</code> —— 尝试 <code>obj.valueOf()</code> 和 <code>obj.toString()</code>，无论哪个存在。</li>\n</ol>\n<h5>一个例子</h5>\n<pre><code class=\"language-js\">let user = {\n    name: &quot;John&quot;,\n    money: 1000,\n\n    [Symbol.toPrimitive](hint) {\n        console.log(`hint: ${hint}`);\n        return hint == &quot;string&quot; ? `{name: &quot;${this.name}&quot;}` : this.money;\n    }\n};\n\n// 转换演示：\n// hint string\nconsole.log(String(user)); // hint: string -&gt; {name: &quot;John&quot;}\n// hint number\nconsole.log(+user); // hint: number -&gt; 1000\n// hint default\nconsole.log(user + 500); // hint: default -&gt; 1500\n</code></pre>\n<p>上述例子中，有个对象<code>user</code>，手动实现了它的<code>Symbol.toPrimitive</code>方法，</p>\n<ol>\n<li><code>String(user)</code>，显示的将<code>user</code>转换为字符串，所以<code>hint === \'string\'</code>，调用<code>Symbol.toPrimitive</code>方法，最终返回字符串<code>{name: \'John\'}</code></li>\n<li><code>+user</code>，隐式地将转换转换为<code>number</code>，所以<code>hint === \'number\'</code>，调用<code>Symbol.toPrimitive</code>方法，返回<code>this.money</code>，所以输出数值<code>1000</code></li>\n<li><code>user + 500</code>，并不知道<code>user</code>的期望值，所以<code>hint === \'default\'</code>，调用<code>Symbol.toPrimitive</code>方法，返回<code>this.money</code>，所以输出数值<code>1500</code></li>\n</ol>\n<h4>toString/valueOf</h4>\n<p>那么，假如在上古时代，没有<code>Symbol</code>时，对象是按什么规则转换成原始类型的呢？其实是通过对象的两个方法实现转换的。<code>toString()和valueOf()</code>。</p>\n<p>如果没有 <code>Symbol.toPrimitive</code>，那么 JavaScript 将尝试找到它们，并且按照下面的顺序进行尝试：</p>\n<ul>\n<li>对于 “string” hint，<code>toString -&gt; valueOf</code>。</li>\n<li>其他情况，<code>valueOf -&gt; toString</code>。</li>\n</ul>\n<blockquote>\n<p>注意：这些方法必须返回一个原始值。如果 <code>toString</code> 或 <code>valueOf</code> 返回了一个对象，那么返回值会被忽略。</p>\n</blockquote>\n<p>默认情况下，普通对象具有 <code>toString</code> 和 <code>valueOf</code> 方法：</p>\n<ul>\n<li><code>toString</code> 方法返回一个字符串 <code>&quot;[object Object]&quot;</code>。</li>\n<li><code>valueOf</code> 方法返回对象自身。</li>\n</ul>\n<p>比如：</p>\n<pre><code class=\"language-js\">let user = { name: &quot;John&quot; };\n\nconsole.log(user.toString()); // [object Object]\nconsole.log(String(user)); // [object Object]\nconsole.log(user.valueOf() === user); // true\n</code></pre>\n<p>因为默认的<code>valueOf</code>返回的就是对象本身，所以我们可以忽略它，具体是为什么，那就是历史原因，咱也不知道，可以假装它不存在就行了。</p>\n<h5>一个小例子</h5>\n<pre><code class=\"language-js\">let user = {\n    name: &quot;John&quot;,\n    money: 1000,\n\n    // 对于 hint=&quot;string&quot;\n    toString() {\n        return `{name: &quot;${this.name}&quot;}`;\n    },\n\n    // 对于 hint=&quot;number&quot; 或 &quot;default&quot;\n    valueOf() {\n        return this.money;\n    }\n\n};\n\n// hint string\nconsole.log(String(user)); // toString -&gt; {name: &quot;John&quot;}\n// hint number\nconsole.log(+user); // valueOf -&gt; 1000\n// hint default\nconsole.log(user + 500); // valueOf -&gt; 1500\n</code></pre>\n<p>上面的找个例子中，并没有实现它的<code>Symbol.toPrimitive</code>，而是实现了它的<code>toString()和valueOf()</code>，所以，</p>\n<ol>\n<li>\n<p><code>String(user)</code>，当打印它的值时，显示转换为字符串，因此转换顺序为先<code>toString</code>，然后<code>valueOf</code>，调用<code>toString()</code>时，返回了基本类型<code>string</code>，其值为<code>\'{name: John}\'</code></p>\n<blockquote>\n<p>这里你可以尝试着将<code>toString</code>返回一个对象试试，最终会被忽略，走<code>valueOf</code>的返回值<code>1000</code></p>\n</blockquote>\n</li>\n<li>\n<p><code>+user</code>，隐式转换为<code>number</code>，先走<code>valueOf()</code>，再走<code>toString()</code>，因为<code>valueOf()</code>有原始类型的返回值<code>1000</code>，所以直接返回<code>1000</code></p>\n</li>\n<li>\n<p><code>user + 500</code>，并不知道需要将<code>user</code>转换为那种值，所以仍然先走<code>valueOf()</code>，再走<code>toString()</code>，因为<code>valueOf()</code>有原始类型的返回值<code>1000</code>，所以直接返回<code>1000</code></p>\n</li>\n</ol>\n<blockquote>\n<p>通常我们希望有一个“全能”的地方来处理所有原始转换。在这种情况下，我们可以只实现 <code>toString</code>，就像这样：</p>\n<pre><code class=\"language-js\">let user = {\n  name: &quot;John&quot;,\n\n  toString() {\n    return this.name;\n  }\n};\n\nconsole.log(String(user)); // toString -&gt; John\nconsole.log(user + 500); // toString -&gt; John500\n</code></pre>\n</blockquote>\n<h4>返回类型</h4>\n<p>关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 “hint” 的原始值。</p>\n<p>没有限制 <code>toString()</code> 是否返回字符串，或 <code>Symbol.toPrimitive</code> 方法是否为 hint “number” 返回数字。</p>\n<p>唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。</p>\n<blockquote>\n<p>❗<strong>历史原因</strong></p>\n<p>由于历史原因，如果 <code>toString</code> 或 <code>valueOf</code> 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 “error” 的概念。</p>\n<p>相反，<code>Symbol.toPrimitive</code> <strong>必须</strong> 返回一个原始值，否则就会出现 error。</p>\n</blockquote>\n<h4>进一步的转换</h4>\n<p>我们知道，许多运算符和函数执行类型转换，例如乘法 <code>*</code> 将操作数转换为数字。</p>\n<p>如果我们将对象作为参数传递，则会出现两个阶段：</p>\n<ol>\n<li>对象被转换为原始值（通过前面我们描述的规则）。</li>\n<li>如果生成的原始值的类型不正确，则继续进行转换。</li>\n</ol>\n<p>例如：</p>\n<pre><code class=\"language-js\">let obj = {\n  // toString 在没有其他方法的情况下处理所有转换\n  toString() {\n    return &quot;2&quot;;\n  }\n};\n\nconsole.log(obj * 2); // 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2。\n</code></pre>\n<ol>\n<li>乘法 <code>obj * 2</code> 首先将对象转换为原始值（字符串 “2”）。</li>\n<li>之后 <code>&quot;2&quot; * 2</code> 变为 <code>2 * 2</code>（字符串被转换为数字）。</li>\n</ol>\n<p>二元加法在同样的情况下会将其连接成字符串，因为它更愿意接受字符串：</p>\n<pre><code class=\"language-js\">let obj = {\n  toString() {\n    return &quot;2&quot;;\n  }\n};\n\nconsole.log(obj + 2); // 22（&quot;2&quot; + 2）被转换为原始值字符串 =&gt; 级联\n</code></pre>\n<h3>一些小例子</h3>\n<h4>例子1：对象转<code>string</code></h4>\n<pre><code class=\"language-js\">// String([]) === \'\'\n// String([\'\']) === \'\'\n// String([1,2,3]) === \'1,2,3\'\n// String([1,,3]) === \'1,,3\'\n// String([1,undefined,3]) === \'1,,3\'\n// String([1,null,3]) === \'1,,3\'\n// String([1,\'\',3]) === \'1,,3\'\n\n// String({}) === \'[object Object]\'\n// String({name: \'John\'}) === \'[object Object]\'\n</code></pre>\n<h4>例子2 对象转<code>number</code></h4>\n<p>其实也是先转成<code>string</code>，然后通过<code>string</code>转<code>number</code></p>\n<pre><code class=\"language-js\">console.log(Number([])); // 0\nconsole.log(Number([\'\'])); // 0\nconsole.log(Number([\' \'])); // 0\nconsole.log(Number([1, 2, 3])); // NaN\n\nconsole.log(Number({})) // NaN\n</code></pre>\n<h2>总结</h2>\n<p>js中有显示类型转换和隐式类型转换</p>\n<ol>\n<li>显示类型转换：比如<code>String(value)、Number(value)、Boolean(value)</code>等显示的将目标值转换为期望的类型。</li>\n<li>隐式类型转换：比如js中的一些运算，<code>\'abc\' + 123</code>，会隐式的将<code>123</code>转换为字符串<code>\'123\'</code>，然后再进行字符串拼接。</li>\n</ol>\n<p>类型转换规则</p>\n<ol>\n<li>\n<p>基本类型之间的转换</p>\n<ol>\n<li>\n<p>转换为<code>string</code></p>\n<p>比较简单，<code>true-&gt;\'true\'</code>、<code>0-&gt;\'0\'</code>、<code>undefined=&gt;\'undefined\'、Symbol(123)-&gt;\'Symbol(123)\'</code>等</p>\n</li>\n<li>\n<p>转换为<code>number</code></p>\n<p>字符串转<code>number</code>时，会去除两边的空格，然后看中间的值是否可以转换成<code>number</code>，如果去除完前后的空格后为空字符串，那就转换为<code>0</code>，如果不能转换为数值，就转换为<code>NaN</code>。</p>\n<blockquote>\n<p>注意：<code>bigint</code>转<code>number</code>时要注意下精度，如果超出了<code>number</code>的存储范围，会被截断一部分。<code>numer</code>的取值返回在<code>(-2^53, 2^53)</code>之间。</p>\n<p><code>symbol</code>类型无法转换为<code>number</code>。</p>\n<p><code>boolean</code>的<code>true</code>变<code>1</code>，<code>false</code>变<code>0</code>。</p>\n<p>另外需要特殊记一下<code>undefined</code>和<code>null</code>，<code>undefined</code>会转换成<code>NaN</code>，<code>null</code>会变为<code>0</code></p>\n</blockquote>\n</li>\n<li>\n<p>转换为<code> boolean</code></p>\n<p><code>undefined、null、0、\'\'、NaN</code>变<code>boolean</code>时为<code>false</code>，其余的都为<code>true</code>。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>对象到原始值之间的转换</p>\n<p>转换规则如下：</p>\n<ol>\n<li>\n<p>有<code>Symbol.toPrimitive</code>方法时，按照该方法转换</p>\n<ol>\n<li>\n<p>当需要转换为<code>string</code>时，<code>hint === string</code></p>\n</li>\n<li>\n<p>当需要转换为<code>number</code>时， <code>hint === number</code></p>\n</li>\n<li>\n<p>当需要转换的类型值不确定时，<code>hint === default</code></p>\n<blockquote>\n<p><code>hint === number</code>与 <code>hint === default</code>其实可以看成相同的一类，</p>\n<p>也就是说如果不走<code>hint === string</code>的转换逻辑，那就直接走<code>hint === number||default</code>的逻辑。</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li>\n<p>当没有<code>Symbol.toPrimitive</code>方法时，遵循下面的转换规则，会去找对象的<code>toString</code>和<code>valueOf</code>方法</p>\n<ol>\n<li>当需要转换为<code>string</code>时，即<code>hint === string</code>，先找<code>toString</code>，再找<code>valueOf</code></li>\n<li>当需要转换为别的类型时，即<code>hint === number || defalut</code>，先找<code>valueOf</code>，再找<code>toString</code></li>\n</ol>\n<blockquote>\n<p>❗注意：在<code>Symbol.toPrimitive</code>中的转换规则里，如果返回值不是原始类型，会直接报错，<code>TypeError: Cannot convert object to primitive value</code>。而当没有<code>Symbol.toPrimitive</code>时，<code>toString</code>或者<code>valueOf</code>的返回值如果不是原始类型会直接忽略。</p>\n<p>另外，数字和字符串都可以使用<code>&gt; &lt;</code>进行比较，这时走的<code>hint === number</code>，是历史遗留下来的，记住就行了。比如：</p>\n<ul>\n<li>\n<p>当有<code>Symbol.toPrimitive</code>时</p>\n<pre><code class=\"language-js\">let a = {\n    [Symbol.toPrimitive](hint) {\n        console.log(`hint: ${hint}`);\n        return hint === \'string\' ? \'hello\' : 123\n    }\n}\n\nlet b = {\n    [Symbol.toPrimitive](hint) {\n        console.log(`hint: ${hint}`);\n        return hint === \'string\' ? \'hello\' : 456\n    }\n}\n\nconsole.log(a &lt; b);\n// hint: number\n// hint: number\n// true 因为 123 &lt; 456\n</code></pre>\n</li>\n<li>\n<p>当没有Symbol.toPrimitive`时</p>\n<pre><code class=\"language-js\">let a = {\n    toString() {\n        return \'hello\'\n    },\n    valueOf() {\n        console.log(\'hint: number\');\n        return 123\n    }\n}\n\nlet b = {\n    toString() {\n        return \'hello\'\n    },\n    valueOf() {\n        console.log(\'hint: number\');\n        return 456\n    }\n}\n\n// 走number时，先找valueOf 再找toString\nconsole.log(a &lt; b);\n// hint: number\n// hint: number\n// true 因为 123 &lt; 456\n</code></pre>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<p>在实践中，为了便于进行日志记录或调试，对于所有能够返回一种“可读性好”的对象的表达形式的转换，只实现以 <code>obj.toString()</code> 作为全能转换的方法就够了。</p>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6956170676327677966#heading-0\">https://juejin.cn/post/6956170676327677966#heading-0</a></p>\n<p><a href=\"https://zh.javascript.info/type-conversions\">https://zh.javascript.info/type-conversions</a></p>\n<p><a href=\"https://zh.javascript.info/object-toprimitive\">https://zh.javascript.info/object-toprimitive</a></p>\n', '2021-11-29 16:31:16', '2021-11-29 16:31:16');
INSERT INTO `t_blog` VALUES ('b94be010-2d94-11ec-ba0f-810bb435395b', 'vue2基础，都在这了', 'vue的基础都在这了，基础语法；常用特性，计算/过滤/侦听属性等等；组件化开发，插槽使用，组件传参；前端交互，axios、fetch；路由使用，路由的传参和配置等等', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 24, 5, 1, 2, 1, 'http://82.156.76.49:20517/upload/png/2021-10-15/e80fc4c0-2d94-11ec-ba0f-810bb435395b.png', '<h2>Section1 Vue模板语法</h2>\n<h3>Vue 是什么？</h3>\n<ul>\n<li><strong>Vue (读音 /vjuː/，类似于 <strong>view</strong>) 是一套用于构建用户界面的渐进式框架</strong></li>\n<li>vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合</li>\n</ul>\n<h3>使用Vue将helloworld  渲染到页面上</h3>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6488cfd2aad641388a212528562a03ee~tplv-k3u1fbpfcp-watermark.image?\" alt=\"1.png\" /></p>\n<h3>指令</h3>\n<ul>\n<li>本质就是自定义属性</li>\n<li>Vue中指定都是以 v- 开头</li>\n</ul>\n<h3>v-cloak</h3>\n<ul>\n<li>防止页面加载时出现闪烁问题</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style&gt;\n    [v-cloak]{\n      display: none;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div v-cloak&gt;{{msg}}&lt;/div&gt;\n  &lt;/div&gt;\n \n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n  /*\n    v-cloak指令的用法\n    1、提供样式\n      [v-cloak]{\n        display: none;\n      }\n    2、在插值表达式所在的标签中添加v-cloak指令\n\n    背后的原理：先通过样式隐藏内容，然后在内存中进行值的替换，替换好之后再显示最终的结果\n  */     \n    const vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'hello cheny\'\n      }\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>v-text</h3>\n<ul>\n<li>v-text指令用于将数据填充到标签中，作用于插值表达式类似，但是没有闪动问题</li>\n<li>是双向绑定的，值改变后，前端会刷新</li>\n<li>如果数据中有HTML标签会将html标签一并输出，<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/172b0cee33164fb7ac97cea046ea212d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"4.png\" /></li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n  &lt;!--  \n    注意:在指令中不要写插值语法  直接写对应的变量名称 \n    在 v-text 中 赋值的时候不要在写 插值语法\n    一般属性中不加 {{}}  直接写 对应 的数据名 \n  --&gt;\n    &lt;div v-text=&quot;msg&quot;&gt;&lt;/div&gt;\n    &lt;div v-text=&quot;msg2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    const vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'hello cheny\',\n        msg2: \'&lt;h1&gt;aaaa&lt;/h1&gt;\'\n      }\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>v-html</h3>\n<ul>\n<li>用法和v-text 相似  但是他可以将HTML片段填充到标签中</li>\n<li>可能有安全问题, 一般只在可信任内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上</li>\n<li>它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div v-html=&quot;msg&quot;&gt;&lt;/div&gt;\n    &lt;div v-html=&quot;msg2&quot;&gt;&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    const vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'hello cheny\',\n        msg2: \'&lt;h1&gt;aaaa&lt;/h1&gt;\'\n      }\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>v-pre</h3>\n<ul>\n<li>显示原始信息跳过编译过程，是啥样还是啥样。</li>\n<li>跳过这个元素和它的子元素的编译过程。</li>\n<li><strong>一些静态的内容不需要编译加这个指令可以加快渲染</strong></li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;span v-pre&gt;{{ this will not be compiled }}&lt;/span&gt;    \n    &lt;!--  显示的是{{ this will not be compiled }}  --&gt;\n    &lt;span v-pre&gt;{{msg}}&lt;/span&gt;  \n    &lt;!--   即使data里面定义了msg这里仍然是显示的{{msg}}  --&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    const vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'hello cheny\'\n      }\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3><strong>v-once</strong></h3>\n<ul>\n<li>执行一次性的插值【当数据改变时，插值处的内容不会继续更新】</li>\n</ul>\n<p>对比：</p>\n<blockquote>\n<p><strong>使用插值表达式{{}}时、或v-text时、或v-html时</strong>：当改变变量值时，页面也会随时刷新，双向绑定。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdb3e9ff35724ddf949e1684798a9b48~tplv-k3u1fbpfcp-watermark.image?\" alt=\"2.png\" /></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f63500dfffe74578ad7099107dd84c31~tplv-k3u1fbpfcp-watermark.image?\" alt=\"3.png\" /></p>\n<p><strong>使用v-once时</strong>：数据是只渲染一次，数值改变后，不会刷新页面。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90c4ac23cec24b12858cd3d49bf9b7ed~tplv-k3u1fbpfcp-watermark.image?\" alt=\"6.png\" /></p>\n</blockquote>\n<h3>双向数据绑定 v-model</h3>\n<ul>\n<li>当数据发生变化的时候，视图也就发生变化</li>\n<li>当视图发生变化的时候，数据也会跟着同步变化</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;{{msg}}&lt;/div&gt;\n    &lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n/*\n  双向数据绑定\n  1、从页面到数据\n  2、从数据到页面\n*/\n    const vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'hello cheny\'\n      }\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/676046d08c7e4bd09c174997e87a94f4~tplv-k3u1fbpfcp-watermark.image?\" alt=\"7.png\" /></p>\n<p>其实本质就是 v-bind和事件的混用，输入框输入值时，会触发input事件，input事件一旦触发，就改变当前的value值，而value值使用v-bind动态绑定，下面有一个案例。</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;{{msg}}&lt;/div&gt;\n    &lt;input type=&quot;text&quot; :value=&quot;msg&quot; @input=\'handle\'&gt;\n    &lt;input type=&quot;text&quot; :value=&quot;msg&quot; @input=\'handle\'&gt;\n    &lt;input type=&quot;text&quot; v-model=\'msg\'&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      v-model指令的本质\n\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'hello\'\n      },\n      methods: {\n        handle(e){\n          // 使用输入域中的最新的数据覆盖原来的数据\n          this.msg = e.target.value;\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>mvvm</h3>\n<ul>\n<li>MVC 是后端的分层开发概念； MVVM是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM ViewModel</li>\n<li>m   model\n<ul>\n<li>数据层   Vue  中 数据层 都放在 data 里面</li>\n</ul>\n</li>\n<li>v   view     视图\n<ul>\n<li>Vue  中  view      即 我们的HTML页面</li>\n</ul>\n</li>\n<li>vm   （view-model）     控制器     将数据和视图层建立联系\n<ul>\n<li>vm 即  Vue 的实例  就是 vm</li>\n</ul>\n</li>\n</ul>\n<h3>v-on</h3>\n<ul>\n<li>用来绑定事件的</li>\n<li>形式如：v-on:click  缩写为 @click;</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;{{num}}&lt;/div&gt;\n    &lt;div&gt;\n      &lt;button v-on:click=\'num++\'&gt;点击1&lt;/button&gt;\n      &lt;button @click=\'num++\'&gt;点击2&lt;/button&gt;\n      &lt;!-- 上面两种方式不可取 --&gt;\n      &lt;!-- \n        开发中许多事件处理逻辑会很复杂，所以不应该把处理逻辑直接写在v-on中\n       --&gt;\n      &lt;button @click=\'handle\'&gt;点击3&lt;/button&gt;\n      &lt;button @click=\'handle()\'&gt;点击4&lt;/button&gt;\n      &lt;!-- 这里虽然写的是handle()，但并不会调用，点击时才会调用，括号里可以传参数 --&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    const vm = new Vue({\n      el: \'#app\',\n      data: {\n        num: 0,\n      },// 注意点： 这里不要忘记加逗号 \n      // methods  中 主要是定义一些函数\n      methods: {\n        handle(){\n          // 这里的this是Vue的实例对象\n          console.log(this === vm)\n          // 在函数中 想要使用data里面的数据 一定要加this\n          this.num++\n        }\n      }\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>v-on事件函数中传入参数</h3>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;{{num}}&lt;/div&gt;\n    &lt;div&gt;\n      &lt;!-- 如果事件直接绑定函数名称，那么默认会传递事件对象作为事件函数的第一个参数 --&gt;\n      &lt;button @click=&quot;handle1&quot;&gt;点击1&lt;/button&gt;\n      &lt;!-- \n        如果是事件绑定函数调用，那么要想传递事件参数，必须放在最后一位\n        并且事件对象的名称必须是$event\n       --&gt;\n      &lt;button @click=&quot;handle2( \'aa\', \'bb\', $event )&quot;&gt;点击2&lt;/button&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    const vm = new Vue({\n      el: \'#app\',\n      data: {\n        num: 0\n      },\n      methods: {\n        handle1(e){\n          console.log(e.target.innerHTML)\n        },\n        handle2(p1,p2,e){\n          console.log(p1,p2)\n          console.log(e.target.innerHTML)\n          this.num++\n        }\n      }\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>事件修饰符</h3>\n<p>参考：<a href=\"https://cn.vuejs.org/v2/guide/events.html#%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6\">官网</a></p>\n<ul>\n<li>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。</li>\n<li>Vue 不推荐我们操作DOM    为了解决这个问题，Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong></li>\n<li>修饰符是由<code>.</code>开头的指令后缀来表示的</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!-- 阻止单击事件继续传播 --&gt;\n&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;\n\n&lt;!-- 提交事件不再重载页面 --&gt;\n&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;\n\n&lt;!-- 修饰符可以串联   即阻止冒泡也阻止默认事件 --&gt;\n&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;\n\n&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;\n&lt;!-- 即事件不是从内部元素触发的 --&gt;\n&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;\n\n使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。\n</code></pre>\n<h3>按键修饰符</h3>\n<ul>\n<li>在做项目中有时会用到键盘事件，在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;\n&lt;input v-on:keyup.13=&quot;submit&quot;&gt;\n\n&lt;!-- -当点击enter 时调用 `vm.submit()` --&gt;\n&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;\n\n&lt;!--当点击enter或者space时  时调用 `vm.alertMe()`   --&gt;\n&lt;input type=&quot;text&quot; v-on:keyup.enter.space=&quot;alertMe&quot; &gt;\n\n常用的按键修饰符\n.enter =&gt;    enter键\n.tab =&gt; tab键\n.delete (捕获“删除”和“退格”按键) =&gt;  删除键\n.esc =&gt; 取消键\n.space =&gt;  空格键\n.up =&gt;  上\n.down =&gt;  下\n.left =&gt;  左\n.right =&gt;  右\n\n&lt;script&gt;\n	var vm = new Vue({\n        el:&quot;#app&quot;,\n        methods: {\n              submit:function(){},\n              alertMe:function(){},\n        }\n    })\n\n&lt;/script&gt;\n</code></pre>\n<h3>自定义按键修饰符别名</h3>\n<ul>\n<li>在Vue中可以通过<code>config.keyCodes</code>自定义按键修饰符别名</li>\n<li><code>e.keyCode</code>可以获取到键盘对应的值。<code>a</code>键对应数值<code>65</code></li>\n<li>下面的例子中，按<code>a</code>键就会出发事件<code>handle</code></li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;input type=&quot;text&quot; v-on:keyup.aaa=\'handle\' v-model=\'info\'&gt;\n  &lt;/div&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      事件绑定-自定义按键修饰符\n      规则：自定义按键修饰符名字是自定义的，但是对应的值必须是按键对应event.keyCode值\n    */\n    Vue.config.keyCodes.aaa = 65\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        info: \'\'\n      },\n      methods: {\n        handle: function(e){\n          console.log(e.keyCode)\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>v-bind</h3>\n<ul>\n<li>v-bind 指令被用来响应地更新 HTML 属性</li>\n<li><code>v-bind:href</code>    可以缩写为    <code>:href</code></li>\n</ul>\n<pre><code class=\"language-html\">&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt;\n    &lt;a :href=&quot;url&quot;&gt;百度1&lt;/a&gt;\n    &lt;button v-on:click=\'handle\'&gt;切换&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      属性绑定\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        url: \'http://www.baidu.com\'\n      },\n      methods: {\n        handle: function(){\n          // 修改URL地址\n          this.url = \'http://www.jd.com\';\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<h4>绑定对象</h4>\n<ul>\n<li>我们可以给v-bind:class 一个对象，以动态地切换class。</li>\n<li>注意：v-bind:class指令可以与普通的class特性共存</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style type=&quot;text/css&quot;&gt;\n    .active {\n      border: 1px solid red;\n      width: 100px;\n      height: 100px;\n    }\n    .error {\n      background-color: orange;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div :class=&quot;{active: isActive, error: isError}&quot;&gt;\n      测试样式\n    &lt;/div&gt;\n    &lt;button @click=\'handle\'&gt;切换&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      样式绑定\n\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        isActive: true,\n        isError: true\n      },\n      methods: {\n        handle: function(){\n          // 控制isActive的值在true和false之间进行切换\n          this.isActive = !this.isActive;\n          this.isError = !this.isError;\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4>绑定class</h4>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style type=&quot;text/css&quot;&gt;\n    .active {\n      border: 1px solid red;\n      width: 100px;\n      height: 100px;\n    }\n    .error {\n      background-color: orange;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div :class=\'[activeClass, errorClass]\'&gt;测试样式&lt;/div&gt;\n    &lt;button @click=\'handle\'&gt;切换&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      样式绑定\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        activeClass: \'active\',\n        errorClass: \'error\'\n      },\n      methods: {\n        handle: function(){\n          this.activeClass = \'\';\n          this.errorClass = \'\';\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4>绑定对象和绑定数组 区别与三个细节用法</h4>\n<p>区别：</p>\n<ul>\n<li>绑定对象的时候 对象的属性 即要渲染的类名 对象的属性值对应的是 data 中的数据</li>\n<li>绑定数组的时候数组里面存的是data 中的数据</li>\n</ul>\n<p>三个小细节：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style type=&quot;text/css&quot;&gt;\n    .active {\n      border: 1px solid red;\n      width: 100px;\n      height: 100px;\n    }\n    .error {\n      background-color: orange;\n    }\n    .test {\n      color: blue;\n    }\n    .base {\n      font-size: 28px;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div :class=\'[activeClass, errorClass, {test: isTest}]\'&gt;测试样式&lt;/div&gt;\n    &lt;div :class=\'arrClasses\'&gt;测试样式&lt;/div&gt;\n    &lt;div :class=\'objClasses\'&gt;&lt;/div&gt;\n    &lt;div class=&quot;base&quot; :class=\'objClasses\'&gt;测试样式&lt;/div&gt;\n\n    &lt;button v-on:click=\'handle\'&gt;切换&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      样式绑定相关语法细节：\n      1、对象绑定和数组绑定可以结合使用\n      2、class绑定的值可以简化操作\n      3、默认的class如何处理？默认的class会保留\n      \n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        activeClass: \'active\',\n        errorClass: \'error\',\n        isTest: true,\n        arrClasses: [\'active\',\'error\', \'test\', \'base\'],\n        objClasses: {\n          active: true,\n          error: true,\n          test: true\n        }\n      },\n      methods: {\n        handle: function(){\n          this.isTest = !this.isTest;\n          this.objClasses.error = !this.objClasses.error;\n          this.objClasses.test = !this.objClasses.test;\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4>绑定style</h4>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div :style=\'{border: borderStyle, width: widthStyle, height: heightStyle}\'&gt;&lt;/div&gt;\n    &lt;div :style=\'objStyles\'&gt;&lt;/div&gt;\n    &lt;div :style=\'[objStyles, overrideStyles]\'&gt;&lt;/div&gt;\n    &lt;button @click=\'handle\'&gt;切换&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      样式绑定之内联样式Style：\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        borderStyle: \'1px solid blue\',\n        widthStyle: \'100px\',\n        heightStyle: \'200px\',\n        objStyles: {\n          border: \'1px solid green\',\n          width: \'200px\',\n          height: \'100px\'\n        },\n        overrideStyles: {\n          border: \'5px solid orange\',\n          backgroundColor: \'blue\'\n        }\n      },\n      methods: {\n        handle: function(){\n          this.heightStyle = \'100px\';\n          this.objStyles.width = \'100px\';\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>分支结构</h3>\n<h4>v-if 使用场景</h4>\n<ul>\n<li>1- 多个元素 通过条件判断展示或者隐藏某个元素。或者多个元素</li>\n<li>2- 进行两个视图之间的切换</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div v-if=\'score&gt;=90\'&gt;优秀&lt;/div&gt;\n    &lt;div v-else-if=\'score&lt;90&amp;&amp;score&gt;=80\'&gt;良好&lt;/div&gt;\n    &lt;div v-else-if=\'score&lt;80&amp;&amp;score&gt;60\'&gt;一般&lt;/div&gt;\n    &lt;div v-else&gt;比较差&lt;/div&gt;\n    &lt;div v-show=\'flag\'&gt;测试v-show&lt;/div&gt;\n    &lt;button @click=\'handle\'&gt;点击&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      分支结构\n\n      v-show的原理：控制元素样式是否显示 display:none\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        score: 10,\n        flag: false\n      },\n      methods: {\n        handle: function(){\n          this.flag = !this.flag\n          this.score = 90\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4>v-show 和 v-if的区别</h4>\n<ul>\n<li>v-show本质就是标签display设置为none，控制隐藏\n<ul>\n<li>v-show只编译一次，后面其实就是控制css，而v-if不停的销毁和创建，故v-show性能更好一点。</li>\n</ul>\n</li>\n<li>v-if是动态的向DOM树内添加或者删除DOM元素\n<ul>\n<li>v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件</li>\n</ul>\n</li>\n</ul>\n<h3>循环结构</h3>\n<h4>v-for</h4>\n<ul>\n<li>用于循环的数组里面的值可以是对象，也可以是普通元素</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  \n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;水果列表&lt;/div&gt;\n    &lt;ul&gt;\n      &lt;li v-for=\'item in fruits\'&gt;{{item}}&lt;/li&gt;\n      &lt;li v-for=\'(item, index) in fruits\'&gt;{{item + \'---\' + index}}&lt;/li&gt;\n      &lt;li :key=\'item.id\' v-for=\'(item, index) in myFruits\'&gt;\n        &lt;span&gt;{{item.ename}}&lt;/span&gt;\n        &lt;span&gt;-----&lt;/span&gt;\n        &lt;span&gt;{{item.cname}}&lt;/span&gt;\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      循环结构-遍历数组\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        fruits: [\'apple\', \'orange\', \'banana\'],\n        myFruits: [{\n          id: 1,\n          ename: \'apple\',\n          cname: \'苹果\'\n        },{\n          id: 2,\n          ename: \'orange\',\n          cname: \'橘子\'\n        },{\n          id: 3,\n          ename: \'banana\',\n          cname: \'香蕉\'\n        }]\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ul>\n<li><strong>不推荐</strong>同时使用 <code>v-if</code> 和 <code>v-for</code></li>\n<li>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!--  循环结构-遍历对象\n		v 代表   对象的value\n		k  代表对象的 键 \n		i  代表索引	\n	---&gt; \n     &lt;div v-if=\'v==13\' v-for=\'(v,k,i) in obj\'&gt;{{v + \'---\' + k + \'---\' + i}}&lt;/div&gt;\n\n&lt;script&gt;\n new Vue({\n  el: \'#example-1\',\n  data: {\n    items: [\n      { message: \'Foo\' },\n      { message: \'Bar\' }\n    ]，\n    obj: {\n        uname: \'zhangsan\',\n        age: 13,\n        gender: \'female\'\n    }\n  }\n})\n&lt;/script&gt;\n</code></pre>\n<ul>\n<li>key 的作用\n<ul>\n<li><strong>key来给每个节点做一个唯一标识</strong></li>\n<li><strong>key的作用主要是为了高效的更新虚拟DOM</strong></li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-html\">&lt;ul&gt;\n  &lt;li v-for=&quot;item in items&quot; :key=&quot;item.id&quot;&gt;...&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h2>Section2 常用特性</h2>\n<h3>表单基本操作</h3>\n<ul>\n<li>\n<p>获取单选框中的值</p>\n<ul>\n<li>通过v-model</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!-- \n		1、 两个单选框需要同时通过v-model 双向绑定 一个值 \n        2、 每一个单选框必须要有value属性  且value 值不能一样 \n		3、 当某一个单选框选中的时候 v-model  会将当前的 value值 改变 data 中的 数据\n\n		gender 的值就是选中的值，我们只需要实时监控他的值就可以了\n	--&gt;\n   &lt;input type=&quot;radio&quot; id=&quot;male&quot; value=&quot;1&quot; v-model=\'gender\'&gt;\n   &lt;label for=&quot;male&quot;&gt;男&lt;/label&gt;\n\n   &lt;input type=&quot;radio&quot; id=&quot;female&quot; value=&quot;2&quot; v-model=\'gender\'&gt;\n   &lt;label for=&quot;female&quot;&gt;女&lt;/label&gt;\n\n&lt;script&gt;\n    new Vue({\n         data: {\n             // 默认会让当前的 value 值为 2 的单选框选中\n                gender: 2,  \n            },\n    })\n\n&lt;/script&gt;\n</code></pre>\n</li>\n<li>\n<p>获取复选框中的值</p>\n<ul>\n<li>通过v-model</li>\n<li>和获取单选框中的值一样</li>\n<li>复选框 <code>checkbox</code> 这种的组合时   data 中的 hobby 我们要定义成数组 否则无法实现多选</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!-- \n		1、 复选框需要同时通过v-model 双向绑定 一个值 \n        2、 每一个复选框必须要有value属性  且value 值不能一样 \n		3、 当某一个单选框选中的时候 v-model  会将当前的 value值 改变 data 中的 数据\n\n		hobby 的值就是选中的值，我们只需要实时监控他的值就可以了\n	--&gt;\n\n&lt;div&gt;\n   &lt;span&gt;爱好：&lt;/span&gt;\n   &lt;input type=&quot;checkbox&quot; id=&quot;ball&quot; value=&quot;1&quot; v-model=\'hobby\'&gt;\n   &lt;label for=&quot;ball&quot;&gt;篮球&lt;/label&gt;\n   &lt;input type=&quot;checkbox&quot; id=&quot;sing&quot; value=&quot;2&quot; v-model=\'hobby\'&gt;\n   &lt;label for=&quot;sing&quot;&gt;唱歌&lt;/label&gt;\n   &lt;input type=&quot;checkbox&quot; id=&quot;code&quot; value=&quot;3&quot; v-model=\'hobby\'&gt;\n   &lt;label for=&quot;code&quot;&gt;写代码&lt;/label&gt;\n &lt;/div&gt;\n&lt;script&gt;\n    new Vue({\n         data: {\n                // 默认会让当前的 value 值为 2 和 3 的复选框选中\n                hobby: [\'2\', \'3\'],\n            },\n    })\n&lt;/script&gt;\n</code></pre>\n</li>\n<li>\n<p>获取下拉框和文本框中的值</p>\n<ul>\n<li>通过v-model</li>\n</ul>\n<pre><code class=\"language-html\">&lt;div&gt;\n      &lt;span&gt;职业：&lt;/span&gt;\n       &lt;!--\n			1、 需要给select  通过v-model 双向绑定 一个值 \n            2、 每一个option  必须要有value属性  且value 值不能一样 \n		    3、 当某一个option选中的时候 v-model  会将当前的 value值 改变 data 中的 数据\n		     occupation 的值就是选中的值，我们只需要实时监控他的值就可以了\n		--&gt;\n       &lt;!-- multiple  多选 --&gt;\n      &lt;select v-model=\'occupation\' multiple&gt;\n          &lt;option value=&quot;0&quot;&gt;请选择职业...&lt;/option&gt;\n          &lt;option value=&quot;1&quot;&gt;教师&lt;/option&gt;\n          &lt;option value=&quot;2&quot;&gt;软件工程师&lt;/option&gt;\n          &lt;option value=&quot;3&quot;&gt;律师&lt;/option&gt;\n      &lt;/select&gt;\n         &lt;!-- textarea 是 一个双标签   不需要绑定value 属性的  --&gt;\n        &lt;textarea v-model=\'desc\'&gt;&lt;/textarea&gt;\n  &lt;/div&gt;\n&lt;script&gt;\n    new Vue({\n         data: {\n                // 默认会让当前的 value 值为 2 和 3 的下拉框选中\n                 occupation: [\'2\', \'3\'],\n             	 desc: \'nihao\'\n            },\n    })\n&lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n<h3>表单修饰符</h3>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;!-- \n      如果不加 .number修饰符，获取的age值默认是一个字符串，做叫法运算时还需转换一下，\n      但是加完 .number修饰符后，获得的数值直接就是一个数字类型\n    --&gt;\n    &lt;input type=&quot;number&quot; v-model.number=\'age\'&gt;\n    &lt;!-- \n      .trim会默认去除输入框里的前后空格\n      中间的不会去除\n     --&gt;\n    &lt;input type=&quot;text&quot; v-model.trim=\'info\'&gt;\n    &lt;!-- \n      .lazy会把input事件，变成change事件\n      原本每次都会触发的input事件，加上 .lazy 修饰符后，\n      只有当在失去焦点 或者 按下回车键时才更新\n     --&gt;\n    &lt;input type=&quot;text&quot; v-model.lazy=\'msg\'&gt;\n    &lt;div&gt;{{msg}}&lt;/div&gt;\n    &lt;button @click=\'handle\'&gt;点击&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      表单域修饰符\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        age: \'\',\n        info: \'\',\n        msg: \'\'\n      },\n      methods: {\n        handle: function(){\n          console.log(this.age + 13)\n          console.log(this.info.length)\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>自定义指令</h3>\n<ul>\n<li>内置指令不能满足我们特殊的需求</li>\n<li>Vue允许我们自定义指令</li>\n</ul>\n<h4>Vue.directive  注册全局指令</h4>\n<pre><code class=\"language-html\">&lt;!-- \n  使用自定义的指令，只需在对用的元素中，加上\'v-\'的前缀形成类似于内部指令\'v-if\'，\'v-text\'的形式。 \n--&gt;\n&lt;input type=&quot;text&quot; v-focus&gt;\n&lt;script&gt;\n// 注意点： \n//   1、 在自定义指令中  如果以驼峰命名的方式定义 如  Vue.directive(\'focusA\',function(){}) \n//   2、 在HTML中使用的时候 只能通过 v-focus-a 来使用 \n    \n// 注册一个全局自定义指令 v-focus\nVue.directive(\'focus\', {\n  	// 当绑定元素插入到 DOM 中。 其中 el为dom元素\n  	inserted: function (el) {\n    		// 聚焦元素\n    		el.focus();\n 	}\n});\nnew Vue({\n　　el:\'#app\'\n});\n&lt;/script&gt;\n</code></pre>\n<h4>Vue.directive  注册全局指令 带参数</h4>\n<pre><code class=\"language-html\">&lt;input type=&quot;text&quot; v-color=\'msg\'&gt;\n &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      自定义指令-带参数\n      bind - 只调用一次，在指令第一次绑定到元素上时候调用\n\n    */\n    Vue.directive(\'color\', {\n      // bind声明周期, 只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置\n      // el 为当前自定义指令的DOM元素  \n      // binding 为自定义的函数形参   通过自定义属性传递过来的值 存在 binding.value 里面\n      bind: function(el, binding){\n        // 根据指令的参数设置背景色\n        // console.log(binding.value.color)\n        el.style.backgroundColor = binding.value.color;\n      }\n    });\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: {\n          color: \'blue\'\n        }\n      }\n    });\n  &lt;/script&gt;\n</code></pre>\n<h4>自定义指令 局部指令</h4>\n<ul>\n<li>局部指令，需要定义在  directives 的选项   用法和全局用法一样</li>\n<li>局部指令只能在当前组件里面使用</li>\n<li>当全局指令和局部指令同名时以局部指令为准</li>\n</ul>\n<pre><code class=\"language-html\">&lt;input type=&quot;text&quot; v-color=\'msg\'&gt;\n &lt;input type=&quot;text&quot; v-focus&gt;\n &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      自定义指令-局部指令\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: {\n          color: \'red\'\n        }\n      },\n   	  //局部指令，需要定义在  directives 的选项\n      directives: {\n        color: {\n          bind: function(el, binding){\n            el.style.backgroundColor = binding.value.color;\n          }\n        },\n        focus: {\n          inserted: function(el) {\n            el.focus();\n          }\n        }\n      }\n    });\n  &lt;/script&gt;\n</code></pre>\n<h4>自定义指令 钩子函数</h4>\n<p>参考：<a href=\"https://cn.vuejs.org/v2/guide/custom-directive.html\">官网</a></p>\n<p>暂时直接使用<code>inserted</code>或者<code>bind</code>，两个差不多，别的先不了解太深入了。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7392277c75c644eb8a092d4628c198dd~tplv-k3u1fbpfcp-watermark.image?\" alt=\"8.png\" /></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6cc8cbb6a7241dea650b5e2465aa359~tplv-k3u1fbpfcp-watermark.image?\" alt=\"9.png\" /></p>\n<h3>计算属性   computed</h3>\n<ul>\n<li>模板中放入太多的逻辑会让模板过重且难以维护  使用计算属性可以让模板更加的简洁</li>\n<li><strong>计算属性是基于它们的响应式依赖进行缓存的</strong></li>\n<li>computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;{{msg}}&lt;/div&gt;\n    &lt;div&gt;{{reverseString}}&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      计算属性\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'Nihao\'\n      },\n      computed: {\n        reverseString: function(){\n          return this.msg.split(\'\').reverse().join(\'\');\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0ddc4b8de174132a7a22b2324c6bd46~tplv-k3u1fbpfcp-watermark.image?\" alt=\"10.png\" /></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eef72be5b4d444b9d3954c66cc8584d~tplv-k3u1fbpfcp-watermark.image?\" alt=\"11.png\" /></p>\n<h3>computed与methods的区别</h3>\n<blockquote>\n<p>computed里计算得到的属性值，如果重复使用，只会计算一次，其他的都是从缓存中拿到的。</p>\n<p>而方法里返回的值是没有缓存的，每次使用都会重复计算。</p>\n<p>这样如果某个返回值多次使用的话，使用方法的话就会多出很多时间去做一件事，效率慢。</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;div id=&quot;app&quot;&gt;\n     &lt;!--  \n        当多次调用 reverseString  的时候 \n        只要里面的 num 值不改变 他会把第一次计算的结果直接返回\n		直到data 中的num值改变 计算属性才会重新发生计算\n     --&gt;\n    &lt;div&gt;{{reverseString}}&lt;/div&gt;\n    &lt;div&gt;{{reverseString}}&lt;/div&gt;\n     &lt;!-- 调用methods中的方法的时候  他每次会重新调用 --&gt;\n    &lt;div&gt;{{reverseMessage()}}&lt;/div&gt;\n    &lt;div&gt;{{reverseMessage()}}&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      计算属性与方法的区别:计算属性是基于依赖进行缓存的，而方法不缓存\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'Nihao\',\n        num: 100\n      },\n      methods: {\n        reverseMessage: function(){\n          console.log(\'methods\')\n          return this.msg.split(\'\').reverse().join(\'\');\n        }\n      },\n      //computed  属性 定义 和 data 已经 methods 平级 \n      computed: {\n        //  reverseString   这个是我们自己定义的名字 \n        reverseString: function(){\n          console.log(\'computed\')\n          var total = 0;\n          //  当data 中的 num 的值改变的时候  reverseString  会自动发生计算  \n          for(var i=0;i&lt;=this.num;i++){\n            total += i;\n          }\n          // 这里一定要有return 否则 调用 reverseString 的 时候无法拿到结果    \n          return total;\n        }\n      }\n    });\n  &lt;/script&gt;\n</code></pre>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1ef41cc284d44a99f548bf6bfc50da5~tplv-k3u1fbpfcp-watermark.image?\" alt=\"12.png\" /></p>\n<h3>侦听器   watch</h3>\n<ul>\n<li>使用watch来响应数据的变化</li>\n<li>一般用于异步或者开销较大的操作</li>\n<li>watch 中的属性 一定是data 中 已经存在的数据</li>\n<li><strong>当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听</strong></li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;\n      &lt;span&gt;用户名：&lt;/span&gt;\n      &lt;span&gt;\n        &lt;input type=&quot;text&quot; v-model.lazy=\'uname\'&gt;\n      &lt;/span&gt;\n      &lt;span&gt;{{tip}}&lt;/span&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*      \n      侦听器\n      1、采用侦听器监听用户名的变化\n      2、调用后台接口进行验证\n      3、根据验证的结果调整提示信息\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        uname: \'\',\n        tip: \'\'\n      },\n      methods: {\n        checkName: function(uname) {\n          // 调用接口，但是可以使用定时任务的方式模拟接口调用\n          var that = this;\n          setTimeout(function(){\n            // 模拟接口调用\n            if(uname == \'admin\') {\n              that.tip = \'用户名已经存在，请更换一个\';\n            }else{\n              that.tip = \'用户名可以使用\';\n            }\n          }, 2000);\n        }\n      },\n      watch: {\n        uname: function(val){\n          // 调用后台接口验证用户名的合法性\n          this.checkName(val);\n          // 修改提示信息\n          this.tip = \'正在验证...\';\n        }\n      }\n    });\n\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>过滤器</h3>\n<ul>\n<li>Vue.js允许自定义过滤器，可被用于一些常见的文本格式化。</li>\n<li>过滤器可以用在两个地方：双花括号插值和v-bind表达式。</li>\n<li>过滤器应该被添加在JavaScript表达式的尾部，由“管道”符号指示</li>\n<li>支持级联操作</li>\n<li>过滤器不改变真正的<code>data</code>，而只是改变渲染的结果，并返回过滤后的版本</li>\n<li>全局注册时是filter，没有s的。而局部过滤器是filters，是有s的</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;input type=&quot;text&quot; v-model=\'msg\'&gt;\n    &lt;div&gt;{{msg | upper}}&lt;/div&gt;\n    &lt;div&gt;{{msg | upper | lower}}&lt;/div&gt;\n    &lt;div :abc=\'msg | upper\'&gt;测试数据&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      过滤器\n      1、可以用与插值表达式和属性绑定\n      2、支持级联操作\n    */\n    // Vue.filter(\'upper\', function(val) {\n    //   return val.charAt(0).toUpperCase() + val.slice(1);\n    // });\n    Vue.filter(\'lower\', function(val) {\n      return val.charAt(0).toLowerCase() + val.slice(1);\n    });\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'\'\n      },\n      filters: {\n        upper: function(val) {\n          return val.charAt(0).toUpperCase() + val.slice(1);\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>过滤器中传递参数</h3>\n<p>工具函数：</p>\n<pre><code class=\"language-js\">/**\n* 对日期进行格式化，\n* @param date要格式化的日期\n* @param format 进行格式化的模式字符串\n*	支持的模式字母有：\n*	y：年，\n*	M：年中的用份（1-12），\n*	d：月份中的天（1-31），\n*	h：小时（0-23），\n*	m：分（0-59），\n*	s：秒（0-59），\n*	S：毫秒（0-999），\n*	q：季度（1-4）\n* @return String\n* @author yanis.wang\n* @see http://yaniswang.com/frontend/2013/02/16/dateformat-performance/\n*/\nfunction dateFormat(date, format) {\n    if (typeof date === &quot;string&quot;) {\n        var mts = date.match(/(\\/Date\\((\\d+)\\)\\/)/);\n        if (mts &amp;&amp; mts.length &gt;= 3) {\n            date = parseInt(mts[2]);\n        }\n    }\n    date = new Date(date);\n    if (!date || date.toUTCString() == &quot;Invalid Date&quot;) {\n        return &quot;&quot;;\n    }\n    var map = {\n        &quot;M&quot;: date.getMonth() + 1, //月份 \n        &quot;d&quot;: date.getDate(), //日 \n        &quot;h&quot;: date.getHours(), //小时 \n        &quot;m&quot;: date.getMinutes(), //分 \n        &quot;s&quot;: date.getSeconds(), //秒 \n        &quot;q&quot;: Math.floor((date.getMonth() + 3) / 3), //季度 \n        &quot;S&quot;: date.getMilliseconds() //毫秒 \n    };\n\n    format = format.replace(/([yMdhmsqS])+/g, function(all, t) {\n        var v = map[t];\n        if (v !== undefined) {\n            if (all.length &gt; 1) {\n                v = \'0\' + v;\n                v = v.substr(v.length - 2);\n            }\n            return v;\n        } else if (t === \'y\') {\n            return (date.getFullYear() + \'\').substr(4 - all.length);\n        }\n        return all;\n    });\n    return format;\n}\n</code></pre>\n<p>过滤器参数传递示例代码：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;{{date | format(\'yyyy-MM-dd hh:mm:ss\')}}&lt;/div&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      过滤器案例：格式化日期\n      \n    */\n    // Vue.filter(\'format\', function(value, arg) {\n    //   if(arg == \'yyyy-MM-dd\') {\n    //     var ret = \'\';\n    //     ret += value.getFullYear() + \'-\' + (value.getMonth() + 1) + \'-\' + value.getDate();\n    //     return ret;\n    //   }\n    //   return value;\n    // })\n    Vue.filter(\'format\', function(value, arg) {\n      function dateFormat(date, format) {...}\n      return dateFormat(value, arg);\n    })\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        date: new Date()\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>生命周期</h3>\n<ul>\n<li>事物从出生到死亡的过程</li>\n<li>Vue实例从创建 到销毁的过程 ，这些过程中会伴随着一些函数的自调用。我们称这些函数为钩子函数</li>\n</ul>\n<h4>常用的 钩子函数</h4>\n<table>\n<thead>\n<tr>\n<th>生命周期</th>\n<th>说名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>beforeCreate</td>\n<td>（1） 在实例初始化之后，数据观测和事件配置之前被调用 此时data 和 methods 以及页面的DOM结构都没有初始化   什么都做不了；（2）在实例初始化之后，数据观测（data observer）和event/watcher 事件配置之前被调用。</td>\n</tr>\n<tr>\n<td>created</td>\n<td>（1）在实例创建完成后被立即调用此时data 和 methods已经可以使用  但是页面还没有渲染出来；（2）在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测（data observer）），属性和方法的运算，watch/event事件回调。然而，挂载阶段还没开始，$el属性目前不可见。</td>\n</tr>\n<tr>\n<td>beforeMount</td>\n<td>（1）在挂载开始之前被调用   此时页面上还看不到真实数据 只是一个模板页面而已；（2）在挂载开始之前被调用：相关的渲染函数首次被调用</td>\n</tr>\n<tr>\n<td>mounted</td>\n<td>（1）el被新创建的vm.<span class=\"language-math\">el替换，并挂载到实例上去之后调用该钩子。  数据已经真实渲染到页面上  在这个钩子函数里面我们可以使用一些第三方的插件；（2）e1被新创建的vm.</span>e1替换，挂载成功</td>\n</tr>\n<tr>\n<td>beforeUpdate</td>\n<td>数据更新时调用，发生在虚拟DOM打补丁之前。   页面上数据还是旧的；</td>\n</tr>\n<tr>\n<td>updated</td>\n<td>由于数据更改导致的虚拟DOM重新渲染和打补丁，在这之后会调用该钩子。 页面上数据已经替换成最新的。</td>\n</tr>\n<tr>\n<td>beforeDestroy</td>\n<td>实例销毁之前调用</td>\n</tr>\n<tr>\n<td>destroyed</td>\n<td>实例销毁后调用</td>\n</tr>\n</tbody>\n</table>\n<p>另外补充两个：</p>\n<blockquote>\n<p>activated：被 keep-alive 缓存的组件激活时调用。<strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n<p>deactivated：被 keep-alive 缓存的组件停用时调用。<strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n<p>errorCaptured：2.5.0+ 新增，当捕获一个来自子孙组件的错误时被调用。</p>\n</blockquote>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5ec33dc8b9f4083877fd77bd58b1014~tplv-k3u1fbpfcp-watermark.image?\" alt=\"13.png\" /></p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;{{msg}}&lt;/div&gt;\n    &lt;button @click=\'update\'&gt;更新&lt;/button&gt;\n    &lt;button @click=\'destroy\'&gt;销毁&lt;/button&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      Vue实例的生命周期\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        msg: \'生命周期\'\n      },\n      methods: {\n        update: function(){\n          this.msg = \'hello\';\n        },\n        destroy: function(){\n          this.$destroy();\n        }\n      },\n      beforeCreate: function(){\n        console.log(\'beforeCreate\');\n      },\n      created: function(){\n        console.log(\'created\');\n      },\n      beforeMount: function(){\n        console.log(\'beforeMount\');\n      },\n      mounted: function(){\n        console.log(\'mounted\');\n      },\n      beforeUpdate: function(){\n        console.log(\'beforeUpdate\');\n      },\n      updated: function(){\n        console.log(\'updated\');\n      },\n      beforeDestroy: function(){\n        console.log(\'beforeDestroy\');\n      },\n      destroyed: function(){\n        console.log(\'destroyed\');\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>页面初次渲染时，会触发 beforeCreate、created、beforeMount、mounted</p>\n<p>当数据更新时，触发beforeUpdate、updated</p>\n<p>当实例销毁时，（调用this.$destroy()方法），触发beforeDestroy、destroyed</p>\n<p>实例销毁后，所有的生命周期都失效，已经不存在了。</p>\n</blockquote>\n<h3>数组变异方法</h3>\n<ul>\n<li>在 Vue 中，直接修改对象属性的值无法触发响应式。当你直接修改了对象属性的值，你会发现，只有数据改了，但是页面内容并没有改变</li>\n<li>变异数组方法即保持数组方法原有功能不变的前提下对其进行功能拓展</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><code>push()</code></th>\n<th>往数组最后面添加一个元素，成功返回当前数组的长度</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>pop()</code></td>\n<td>删除数组的最后一个元素，成功返回删除元素的值</td>\n</tr>\n<tr>\n<td><code>shift()</code></td>\n<td>删除数组的第一个元素，成功返回删除元素的值</td>\n</tr>\n<tr>\n<td><code>unshift()</code></td>\n<td>往数组最前面添加一个元素，成功返回当前数组的长度</td>\n</tr>\n<tr>\n<td><code>splice()</code></td>\n<td>有三个参数，第一个是想要删除的元素的下标（必选），第二个是想要删除的个数（必选），第三个是删除 后想要在原位置替换的值</td>\n</tr>\n<tr>\n<td><code>sort()</code></td>\n<td>sort()  使数组按照字符编码默认从小到大排序,成功返回排序后的数组</td>\n</tr>\n<tr>\n<td><code>reverse()</code></td>\n<td>reverse()  将数组倒序，成功返回倒序后的数组</td>\n</tr>\n</tbody>\n</table>\n<h3>替换数组</h3>\n<ul>\n<li>不会改变原始数组，但总是返回一个新数组</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>filter</th>\n<th>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>concat</td>\n<td>concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组</td>\n</tr>\n<tr>\n<td>slice</td>\n<td>slice() 方法可从已有的数组中返回选定的元素。该方法并不会修改数组，而是返回一个子数组</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>**注意：**无论是编译方法、还是替换数组中的方法，vue都已经把这些基础的方法改造成了双向绑定，可以直接使用，但是如果直接按索引修改数值并且还需要双向绑定，就需要使用vue提供的下面的两种方法。</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;\n      &lt;span&gt;\n        &lt;input type=&quot;text&quot; v-model=\'fname\'&gt;\n        &lt;button @click=\'add\'&gt;添加&lt;/button&gt;\n        &lt;button @click=\'del\'&gt;删除&lt;/button&gt;\n        &lt;button @click=\'change\'&gt;替换&lt;/button&gt;\n        &lt;button @click=\'test\'&gt;直接修改数组&lt;/button&gt;\n      &lt;/span&gt;\n    &lt;/div&gt;\n    &lt;ul&gt;\n      &lt;li :key=\'index\' v-for=\'(item,index) in list\'&gt;{{item}}&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      Vue数组操作\n      1、变异方法：会影响数组的原始数据的变化。\n      2、替换数组：不会影响原始的数组数据，而是形成一个新的数组。\n    */\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        fname: \'\',\n        list: [\'apple\',\'orange\',\'banana\']\n      },\n      methods: {\n        add: function(){\n          this.list.push(this.fname);\n        },\n        del: function(){\n          this.list.pop();\n        },\n        change: function(){\n          this.list = this.list.slice(0,2);\n        },\n        /**\n         * 这种直接修改索引的方式并不会触发双向绑定，\n         * 数据虽然修改了，但实际上页面的数据并不会更新\n         */ \n        test: function(){\n          this.list[0] = \'cheny\'\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</blockquote>\n<h3>动态数组响应式数据</h3>\n<blockquote>\n<p>如果按照索引直接修改数组里的值，是不会触发双向绑定的。</p>\n<p>比如下面的例子，在浏览器运行后，在控制台直接修改<code>list</code>中的值，数据发现已经修改了，但是并没有触发双向绑定。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75544970560b40cfbd1304f10965b547~tplv-k3u1fbpfcp-watermark.image?\" alt=\"14.png\" /></p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;ul&gt;\n      &lt;li :key=\'index\' v-for=\'(item,index) in list\'&gt;{{item}}&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        list: [\'apple\',\'orange\',\'banana\']\n      },\n      methods: {}\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</blockquote>\n<p>对于上面的问题，vue提供了两种方式修改</p>\n<pre><code class=\"language-js\">Vue.set（vm.items，indexOfltem，newValue）\nvm.$set（vm.items，indexOfltem，newValue）\n① 参数一表示要处理的数组名称\n② 参数二表示要处理的数组的索引\n③ 参数三表示要处理的数组的值\n</code></pre>\n<blockquote>\n<p>方法1：<code>Vue.set（vm.items，indexOfltem，newValue）</code></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23e750e4628e409a84f50160d7564a07~tplv-k3u1fbpfcp-watermark.image?\" alt=\"15.png\" /></p>\n<p>方法2：<code>vm.$set（vm.items，indexOfltem，newValue）</code></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bd983c64c19a473da2c5bb2e016c0208~tplv-k3u1fbpfcp-watermark.image?\" alt=\"16.png\" /></p>\n</blockquote>\n<h2>Section3 组件化开发</h2>\n<h3>组件</h3>\n<ul>\n<li>组件 (Component) 是 Vue.js 最强大的功能之一</li>\n<li>组件可以扩展 HTML 元素，封装可重用的代</li>\n</ul>\n<h3>组件注册</h3>\n<h4>全局注册</h4>\n<ul>\n<li><code>Vue.component(\'组件名称\', { })</code>     第1个参数是标签名称，第2个参数是一个选项对象</li>\n<li><strong>全局组件</strong>注册后，任何<strong>vue实例</strong>都可以用</li>\n</ul>\n<h5>组件基础用法</h5>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;!-- 注册一次，多次使用 --&gt;\n    &lt;button-counter&gt;&lt;/button-counter&gt;\n    &lt;button-counter&gt;&lt;/button-counter&gt;\n    &lt;button-counter&gt;&lt;/button-counter&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      组件注册\n    */\n    Vue.component(\'button-counter\', {\n      data: function(){\n        return {\n          count: 0\n        }\n      },\n      template: \'&lt;button @click=&quot;handle&quot;&gt;点击了{{count}}次&lt;/button&gt;\',\n      methods: {\n        handle: function(){\n          this.count += 1;\n        }\n      }\n    })\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        \n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h5>组件注意事项</h5>\n<blockquote>\n<ol>\n<li>组件参数的data值必须是函数，同时这个函数要求返回一个对象</li>\n<li>组件模板必须是单个根元素，通常使用一个单独的div包裹一下</li>\n<li>组件模板的内容可以是模板字符串</li>\n<li>组件可以重复使用多次。因为data中返回的是一个对象，所以每个组件中的数据是私有的，即每个实例可以维护一份被返回对象的独立的拷贝</li>\n<li>如果使用驼峰式命名组件，那么在使用组件的时候，只能在<strong>字符串模板</strong>中用驼峰的方式使用组件</li>\n<li>在<strong>字符串模板</strong>中可以使用驼峰的方式使用组件</li>\n<li>但是在普通的标签模板中，必须使用短横线的方式使用组件</li>\n</ol>\n<pre><code class=\"language-html\">&lt;div id=&quot;app&quot;&gt;\n     &lt;!-- \n		4、  组件可以重复使用多次 \n	      因为data中返回的是一个对象所以每个组件中的数据是私有的\n		  即每个实例可以维护一份被返回对象的独立的拷贝   \n	--&gt; \n    &lt;button-counter&gt;&lt;/button-counter&gt;\n    &lt;button-counter&gt;&lt;/button-counter&gt;\n    &lt;button-counter&gt;&lt;/button-counter&gt;\n      &lt;!-- 8、必须使用短横线的方式使用组件 --&gt;\n     &lt;hello-world&gt;&lt;/hello-world&gt;\n  &lt;/div&gt;\n\n&lt;script type=&quot;text/javascript&quot;&gt;\n	//5  如果使用驼峰式命名组件，那么在使用组件的时候，只能在字符串模板中用驼峰的方式使用组件，\n    // 7、但是在普通的标签模板中，必须使用短横线的方式使用组件\n     Vue.component(\'HelloWorld\', {\n      data: function(){\n        return {\n          msg: \'HelloWorld\'\n        }\n      },\n      template: \'&lt;div&gt;{{msg}}&lt;/div&gt;\'\n    });\n    \n    \n    \n    Vue.component(\'button-counter\', {\n      // 1、组件参数的data值必须是函数 \n      // 同时这个函数要求返回一个对象  \n      data: function(){\n        return {\n          count: 0\n        }\n      },\n      //  2、组件模板必须是单个根元素\n      //  3、组件模板的内容可以是模板字符串  \n      template: `\n        &lt;div&gt;\n          &lt;button @click=&quot;handle&quot;&gt;点击了{{count}}次&lt;/button&gt;\n          &lt;button&gt;测试123&lt;/button&gt;\n			#  6 在字符串模板中可以使用驼峰的方式使用组件	\n		   &lt;HelloWorld&gt;&lt;/HelloWorld&gt;\n        &lt;/div&gt;\n      `,\n      methods: {\n        handle: function(){\n          this.count += 2;\n        }\n      }\n    })\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        \n      }\n    });\n  &lt;/script&gt;\n</code></pre>\n</blockquote>\n<h4>局部注册</h4>\n<ul>\n<li>只能在当前注册它的vue实例中使用</li>\n</ul>\n<pre><code class=\"language-html\">&lt;div id=&quot;app&quot;&gt;\n      &lt;my-component&gt;&lt;/my-component&gt;\n  &lt;/div&gt;\n\n\n&lt;script&gt;\n    // 定义组件的模板\n    var Child = {\n      template: \'&lt;div&gt;A custom component!&lt;/div&gt;\'\n    }\n    new Vue({\n      //局部注册组件  \n      components: {\n        // &lt;my-component&gt; 将只在父模板可用  一定要在实例上注册了才能在html文件中使用\n        \'my-component\': Child\n      }\n    })\n &lt;/script&gt;\n</code></pre>\n<h3>Vue 调试工具</h3>\n<h4>方法一：github上下载</h4>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/45cfd05e37684f038d5f23c141c411b5~tplv-k3u1fbpfcp-watermark.image?\" alt=\"17.png\" /></p>\n<p>打开链接后是Vue devtools的github仓库，按照里面的使用方法操作一下。</p>\n<blockquote>\n<p>1、git clone https://github.com/vuejs/vue-devtools.git</p>\n<p>2、cd  vue-devtools</p>\n<p>3、npm install --registry=https://registry.npm.taobao.org</p>\n<p>4、npm run build</p>\n<p>5、chrome中找到 更多工具 / 扩展程序 选项，勾选 开发者模式，然后点击 加载已解压的扩展程序，选择vue-devtools\\shells\\chrome，确认</p>\n</blockquote>\n<p>会遇到很多恶心的问题，好兄弟，自求多福（抱拳/33\\）。</p>\n<h4>方法二：<strong>建议直接从Google应用商店下载 Vue.js devtools（推荐）</strong></h4>\n<p>下载方法自行百度。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81e7362475bb473ba2d39181a0af82cf~tplv-k3u1fbpfcp-watermark.image?\" alt=\"18.png\" /></p>\n<p>下载完之后还需要配置几个地方。</p>\n<blockquote>\n<ol>\n<li><strong>右键插件图标，选择<code>管理扩展程序</code>，勾选允许访问文件网址，另外记得开启开发者模式。</strong></li>\n</ol>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37c28bcbccf14b8fb0ce328868efeaf5~tplv-k3u1fbpfcp-watermark.image?\" alt=\"19.png\" /></p>\n</blockquote>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0745a60a7cdc4d61bfae94f9d9d1e4c0~tplv-k3u1fbpfcp-watermark.image?\" alt=\"23.png\" /></p>\n<blockquote>\n<ol start=\"2\">\n<li><strong>在C盘搜索，插件的id，这个id是插件下载之后自己生成的，可以在<code>管理扩展程序</code>页面中找到</strong></li>\n</ol>\n</blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1b1211395ee49f49be9de211b2aa24c~tplv-k3u1fbpfcp-watermark.image?\" alt=\"20.png\" /></p>\n<blockquote>\n<ol start=\"3\">\n<li><strong>在C盘中搜索这个id，会搜索到一个以这个id命名的文件夹，在里面可以找到插件的配置文件，<code>manifest.json</code></strong></li>\n</ol>\n</blockquote>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a15868a79624ee197cb94529af2ee1b~tplv-k3u1fbpfcp-watermark.image?\" alt=\"21.png\" /></p>\n<blockquote>\n<ol start=\"4\">\n<li><strong>修改配置文件<code>manifest.json</code>中的<code>persistent</code>字段，改为<code>true</code>，如果不改的话在F12控制台中不会显示插件，装了个寂寞</strong></li>\n</ol>\n<pre><code class=\"language-json\">{\n   &quot;background&quot;: {\n      &quot;persistent&quot;: true,\n      ...\n   },\n   ...\n}\n</code></pre>\n<ol start=\"5\">\n<li>成功安装效果如下。</li>\n</ol>\n</blockquote>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d299d11b650b438a9201e0137930d5a3~tplv-k3u1fbpfcp-watermark.image?\" alt=\"22.png\" /></p>\n<blockquote>\n<ol start=\"6\">\n<li>测试代码。</li>\n</ol>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n  &lt;style type=&quot;text/css&quot;&gt;\n    .root {\n      background-color: orange;\n    }\n    .second {\n      background-color: lightgreen;\n    }\n    .third {\n      background-color: lightblue;\n    }\n  &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot; class=&quot;root&quot;&gt;\n    &lt;div&gt;{{root}}&lt;/div&gt;\n    &lt;second-com&gt;&lt;/second-com&gt;\n    &lt;second-com&gt;&lt;/second-com&gt;\n  &lt;/div&gt;\n  &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    /*\n      Vue调试工具安装与基本使用\n    */\n    Vue.component(\'second-com\',{\n      data: function(){\n        return {\n          second: \'二级组件\'\n        }\n      },\n      template: `&lt;div class=\'second\'&gt;\n        &lt;div&gt;{{second}}&lt;/div&gt;\n        &lt;third-com&gt;&lt;/third-com&gt;\n        &lt;third-com&gt;&lt;/third-com&gt;\n        &lt;third-com&gt;&lt;/third-com&gt;\n      &lt;/div&gt;`\n    });\n    Vue.component(\'third-com\',{\n      data: function(){\n        return {\n          third: \'三级组件\'\n        }\n      },\n      template: \'&lt;div class=&quot;third&quot;&gt;&lt;div&gt;{{third}}&lt;/div&gt;&lt;/div&gt;\'\n    });\n\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        root: \'顶层组件\'\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n</blockquote>\n<h3>Vue组件之间传值</h3>\n<h4>父组件向子组件传值</h4>\n<ul>\n<li>父组件发送的形式是以属性的形式绑定值到子组件身上。</li>\n<li>然后子组件用属性props接收</li>\n<li>在props中使用驼峰形式，模板中需要使用短横线的形式。字符串形式的模板中没有这个限制。</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;{{pmsg}}&lt;/div&gt;\n    &lt;!-- 1、props中使用驼峰，模板中就得使用短横线 --&gt;\n    &lt;menu-item :menu-title=\'ptitle\'&gt;&lt;/menu-item&gt;\n  &lt;/div&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      父组件向子组件传值-props属性名规则\n    */\n    Vue.component(\'third-com\', {\n      props: [\'testTile\'],\n      template: \'&lt;div&gt;{{testTile}}&lt;/div&gt;\'\n    });\n    Vue.component(\'menu-item\', {\n      props: [\'menuTitle\'],\n      // 2、字符串模板中没有1中的限制，驼峰也行\n      template: \'&lt;div&gt;{{menuTitle}}&lt;third-com testTile=&quot;hello&quot;&gt;&lt;/third-com&gt;&lt;/div&gt;\'\n    });\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        pmsg: \'父组件中内容\',\n        ptitle: \'动态绑定属性\'\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4>子组件向父组件传值</h4>\n<ul>\n<li>子组件用<code>$emit()</code>触发事件</li>\n<li><code>$emit()</code>  第一个参数为 自定义的事件名称     第二个参数为需要传递的数据</li>\n<li>父组件用v-on 监听子组件的事件</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;div id=&quot;app&quot;&gt;\n    &lt;div :style=\'{fontSize: fontSize + &quot;px&quot;}\'&gt;{{pmsg}}&lt;/div&gt;\n      &lt;!-- 2 父组件用v-on 监听子组件的事件\n		这里 enlarge-text  是从 $emit 中的第一个参数对应   handle 为对应的事件处理函数	\n	--&gt;	\n    &lt;menu-item :parr=\'parr\' @enlarge-text=\'handle($event)\'&gt;&lt;/menu-item&gt;\n  &lt;/div&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      子组件向父组件传值-携带参数\n    */\n    \n    Vue.component(\'menu-item\', {\n      props: [\'parr\'],\n      template: `\n        &lt;div&gt;\n          &lt;ul&gt;\n            &lt;li :key=\'index\' v-for=\'(item,index) in parr\'&gt;{{item}}&lt;/li&gt;\n          &lt;/ul&gt;\n			###  1、子组件用$emit()触发事件\n			### 第一个参数为 自定义的事件名称   第二个参数为需要传递的数据  \n          &lt;button @click=\'$emit(&quot;enlarge-text&quot;, 5)\'&gt;扩大父组件中字体大小5px&lt;/button&gt;\n          &lt;button @click=\'$emit(&quot;enlarge-text&quot;, 10)\'&gt;扩大父组件中字体大小10px&lt;/button&gt;\n          &lt;button @click=\'enlargeFontHandle\'&gt;enlargeFontHandle&lt;/button&gt;\n        &lt;/div&gt;\n      `,\n      methods: {\n        enlargeFontHandle: function() {\n          console.log(\'enlargeFontHandle\')\n          this.$emit(\'enlarge-text\',100)\n        }\n      }\n    });\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        pmsg: \'父组件中内容\',\n        parr: [\'apple\',\'orange\',\'banana\'],\n        fontSize: 10\n      },\n      methods: {\n        handle: function(val){\n          // 扩大字体大小\n          console.log(val)\n          this.fontSize += val;\n        }\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4>兄弟之间的传递</h4>\n<blockquote>\n<p>如果两个组件是兄弟组件，可以使用公用的父组件作为一个媒介，通过父组件来传递参数，但是这样有个弊端，当嵌套的层级很深的时候，就需要一层一层的往上找，非常麻烦，这时候就可以借助事件中心来传递参数。</p>\n</blockquote>\n<ul>\n<li>兄弟之间传递数据需要借助于事件中心，通过事件中心传递数据\n<ul>\n<li>提供事件中心    var hub = new Vue()</li>\n</ul>\n</li>\n<li>传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)</li>\n<li>接收数据方，通过mounted(){} 钩子中  触发hub.$on()方法名</li>\n<li>销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据</li>\n</ul>\n<pre><code class=\"language-html\">&lt;div id=&quot;app&quot;&gt;\n    &lt;div&gt;父组件&lt;/div&gt;\n    &lt;div&gt;\n      &lt;button @click=\'handle\'&gt;销毁事件&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;test-tom&gt;&lt;/test-tom&gt;\n    &lt;test-jerry&gt;&lt;/test-jerry&gt;\n  &lt;/div&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      兄弟组件之间数据传递\n    */\n    //1、 提供事件中心\n    var hub = new Vue();\n\n    Vue.component(\'test-tom\', {\n      data: function(){\n        return {\n          num: 0\n        }\n      },\n      template: `\n        &lt;div&gt;\n          &lt;div&gt;TOM:{{num}}&lt;/div&gt;\n          &lt;div&gt;\n            &lt;button @click=\'handle\'&gt;点击&lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      `,\n      methods: {\n        handle: function(){\n          //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)   触发兄弟组件的事件\n          hub.$emit(\'jerry-event\', 2);\n        }\n      },\n      mounted: function() {\n       // 3、接收数据方，通过mounted(){} 钩子中  触发hub.$on(方法名\n        hub.$on(\'tom-event\', (val) =&gt; {\n          this.num += val;\n        });\n      }\n    });\n    Vue.component(\'test-jerry\', {\n      data: function(){\n        return {\n          num: 0\n        }\n      },\n      template: `\n        &lt;div&gt;\n          &lt;div&gt;JERRY:{{num}}&lt;/div&gt;\n          &lt;div&gt;\n            &lt;button @click=\'handle\'&gt;点击&lt;/button&gt;\n          &lt;/div&gt;\n        &lt;/div&gt;\n      `,\n      methods: {\n        handle: function(){\n          //2、传递数据方，通过一个事件触发hub.$emit(方法名，传递的数据)   触发兄弟组件的事件\n          hub.$emit(\'tom-event\', 1);\n        }\n      },\n      mounted: function() {\n        // 3、接收数据方，通过mounted(){} 钩子中  触发hub.$on()方法名\n        hub.$on(\'jerry-event\', (val) =&gt; {\n          this.num += val;\n        });\n      }\n    });\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        \n      },\n      methods: {\n        handle: function(){\n          //4、销毁事件 通过hub.$off()方法名销毁之后无法进行传递数据  \n          hub.$off(\'tom-event\');\n          hub.$off(\'jerry-event\');\n        }\n      }\n    });\n  &lt;/script&gt;\n</code></pre>\n<h3>组件插槽</h3>\n<ul>\n<li>组件的最大特性就是复用性，而用好插槽能大大提高组件的可复用能力</li>\n</ul>\n<h4>匿名插槽</h4>\n<pre><code class=\"language-html\">&lt;div id=&quot;app&quot;&gt;\n    &lt;!-- 这里的所有组件标签中嵌套的内容会替换掉slot  如果不传值 则使用 slot 中的默认值  --&gt;  \n    &lt;alert-box&gt;有bug发生&lt;/alert-box&gt;\n    &lt;alert-box&gt;有一个警告&lt;/alert-box&gt;\n    &lt;alert-box&gt;&lt;/alert-box&gt;\n  &lt;/div&gt;\n\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      组件插槽：父组件向子组件传递内容\n    */\n    Vue.component(\'alert-box\', {\n      template: `\n        &lt;div&gt;\n          &lt;strong&gt;ERROR:&lt;/strong&gt;\n		# 当组件渲染的时候，这个 &lt;slot&gt; 元素将会被替换为“组件标签中嵌套的内容”。\n		# 插槽内可以包含任何模板代码，包括 HTML\n          &lt;slot&gt;默认内容&lt;/slot&gt;\n        &lt;/div&gt;\n      `\n    });\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        \n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4>具名插槽</h4>\n<ul>\n<li>具有名字的插槽</li>\n<li>使用<code> &lt;slot&gt;</code> 中的 &quot;name&quot; 属性绑定元素</li>\n</ul>\n<pre><code class=\"language-html\">&lt;div id=&quot;app&quot;&gt;\n    &lt;base-layout&gt;\n       &lt;!-- 2、 通过slot属性来指定, 这个slot的值必须和下面slot组件得name值对应上\n				如果没有匹配到 则放到匿名的插槽中   --&gt; \n      &lt;p slot=\'header\'&gt;标题信息&lt;/p&gt;\n      &lt;p&gt;主要内容1&lt;/p&gt;\n      &lt;p&gt;主要内容2&lt;/p&gt;\n      &lt;p slot=\'footer\'&gt;底部信息信息&lt;/p&gt;\n    &lt;/base-layout&gt;\n\n    &lt;base-layout&gt;\n      &lt;!-- 注意点：template临时的包裹标签最终不会渲染到页面上     --&gt;  \n      &lt;template slot=\'header\'&gt;\n        &lt;p&gt;标题信息1&lt;/p&gt;\n        &lt;p&gt;标题信息2&lt;/p&gt;\n      &lt;/template&gt;\n      &lt;p&gt;主要内容1&lt;/p&gt;\n      &lt;p&gt;主要内容2&lt;/p&gt;\n      &lt;template slot=\'footer\'&gt;\n        &lt;p&gt;底部信息信息1&lt;/p&gt;\n        &lt;p&gt;底部信息信息2&lt;/p&gt;\n      &lt;/template&gt;\n    &lt;/base-layout&gt;\n  &lt;/div&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      具名插槽\n    */\n    Vue.component(\'base-layout\', {\n      template: `\n        &lt;div&gt;\n          &lt;header&gt;\n			###	1、 使用 &lt;slot&gt; 中的 &quot;name&quot; 属性绑定元素 指定当前插槽的名字\n            &lt;slot name=\'header\'&gt;&lt;/slot&gt;\n          &lt;/header&gt;\n          &lt;main&gt;\n            &lt;slot&gt;&lt;/slot&gt;\n          &lt;/main&gt;\n          &lt;footer&gt;\n			###  注意点： \n			###  具名插槽的渲染顺序，完全取决于模板，而不是取决于父组件中元素的顺序\n            &lt;slot name=\'footer\'&gt;&lt;/slot&gt;\n          &lt;/footer&gt;\n        &lt;/div&gt;\n      `\n    });\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        \n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h4>作用域插槽</h4>\n<ul>\n<li>父组件对子组件加工处理</li>\n<li>既可以复用子组件的slot，又可以使slot内容不一致</li>\n<li>父组件使用<code>slot-scope=\'slotProps\'</code>获得了子组件插槽中的数据，这样就可以通过父组件控制子组件中的样式了，子组件完成后就不用动了，非常方便。</li>\n</ul>\n<pre><code class=\"language-html\">&lt;div id=&quot;app&quot;&gt;\n    &lt;!-- \n		1、当我们希望li 的样式由外部使用组件的地方定义，因为可能有多种地方要使用该组件，\n		但样式希望不一样 这个时候我们需要使用作用域插槽 \n		\n	--&gt;  \n    &lt;fruit-list :list=\'list\'&gt;\n       &lt;!-- 2、 父组件中使用了&lt;template&gt;元素,而且包含scope=&quot;slotProps&quot;,\n			slotProps在这里只是临时变量   \n		---&gt; 	\n      &lt;template slot-scope=\'slotProps\'&gt;\n        &lt;strong v-if=\'slotProps.info.id==3\' class=&quot;current&quot;&gt;\n            {{slotProps.info.name}}		         \n         &lt;/strong&gt;\n        &lt;span v-else&gt;{{slotProps.info.name}}&lt;/span&gt;\n      &lt;/template&gt;\n    &lt;/fruit-list&gt;\n  &lt;/div&gt;\n  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;\n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      作用域插槽\n    */\n    Vue.component(\'fruit-list\', {\n      props: [\'list\'],\n      template: `\n        &lt;div&gt;\n          &lt;li :key=\'item.id\' v-for=\'item in list\'&gt;\n			###  3、 在子组件模板中,&lt;slot&gt;元素上有一个类似props传递数据给组件的写法msg=&quot;xxx&quot;,\n			###   插槽可以提供一个默认内容，如果父组件没有为这个插槽提供了内容，会显示默认的内容。\n					如果父组件为这个插槽提供了内容，则默认的内容会被替换掉\n            &lt;slot :info=\'item\'&gt;{{item.name}}&lt;/slot&gt;\n          &lt;/li&gt;\n        &lt;/div&gt;\n      `\n    });\n    var vm = new Vue({\n      el: \'#app\',\n      data: {\n        list: [{\n          id: 1,\n          name: \'apple\'\n        },{\n          id: 2,\n          name: \'orange\'\n        },{\n          id: 3,\n          name: \'banana\'\n        }]\n      }\n    });\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2>Section4 前端交互</h2>\n<h3>接口调用方式</h3>\n<ul>\n<li>原生ajax</li>\n<li>基于jQuery的ajax</li>\n<li>fetch</li>\n<li>axios</li>\n</ul>\n<h3>URL格式</h3>\n<h4>传统形式的URL</h4>\n<blockquote>\n<p>格式：<code>schema://host:port/path?query#fragment</code></p>\n<ol>\n<li>schema：协议。例如http、https、ftp等</li>\n<li>host：域名或者IP地址</li>\n<li>port：端口，http默认端口80，可以省略</li>\n<li>path：路径，例如/abc/a/b/c</li>\n<li>query：查询参数，例如uname=lisi&amp;age=12</li>\n<li>fragment：锚点（哈希Hash），用于定位页面的某个位置</li>\n</ol>\n<p>符合规则的URL：</p>\n<ul>\n<li><code>http://www.baidu.com</code></li>\n<li><code>http://www.baidu.com/java/web</code></li>\n<li><code>http://www.baidu.com/java/web?flag=1</code></li>\n<li><code>http://www.baidu.com/java/web?flag=1#function</code></li>\n</ul>\n</blockquote>\n<h4>Restful形式的URL</h4>\n<blockquote>\n<p>HTTP请求方式：</p>\n<ul>\n<li>GET 查询</li>\n<li>POST 添加</li>\n<li>PUT 修改</li>\n<li>DELETE 删除</li>\n</ul>\n<p>符合规则的URL地址：</p>\n<ul>\n<li><code>http://www.hello.com/books</code> GET</li>\n<li><code>http://www.hello.com/books</code> POST</li>\n<li><code>http://www.hello.com/books/123</code> PUTE</li>\n<li><code>http://www.hello.com/books/123</code> DELETE</li>\n</ul>\n</blockquote>\n<h3>回调地狱</h3>\n<blockquote>\n<p>每次请求接口都是异步的，如果同时需要请求多个接口，每个接口之间有相互依赖关系，为了达到效果，就会产生嵌套关系</p>\n<p>这种层层嵌套的代码，很不容易维护。下面通过代码演示了一下回调嵌套逻辑。</p>\n<pre><code class=\"language-js\">$.ajax({\n      url: \'http://localhost:3000/test/a\',\n      success: function(data) {\n        console.log(data)\n        $.ajax({\n          url: \'http://localhost:3000/test/b\',\n          success: function(data) {\n            console.log(data)\n            $.ajax({\n              url: \'http://localhost:3000/test/c\',\n              success: function(data) {\n                console.log(data)\n              }\n            });\n          }\n        });\n      }\n    });\n</code></pre>\n</blockquote>\n<h3>promise</h3>\n<ul>\n<li>主要解决异步深层嵌套的问题</li>\n<li>promise 提供了简洁的API  使得异步操作更加容易</li>\n</ul>\n<pre><code class=\"language-html\">&lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n     1. Promise基本使用\n           我们使用new来构建一个Promise  Promise的构造函数接收一个参数，是函数，并且传入两个参数：		   resolve，reject， 分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数\n    */\n\n\n    var p = new Promise(function(resolve, reject){\n      //2. 这里用于实现异步任务  setTimeout\n      setTimeout(function(){\n        var flag = false;\n        if(flag) {\n          //3. 正常情况\n          resolve(\'hello\');\n        }else{\n          //4. 异常情况\n          reject(\'出错了\');\n        }\n      }, 100);\n    });\n    //  5 Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数 \n    //  在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了  \n    p.then(function(data){\n      console.log(data)\n    },function(info){\n      console.log(info)\n    });\n  &lt;/script&gt;\n</code></pre>\n<h3>基于Promise发送Ajax请求</h3>\n<pre><code class=\"language-html\">&lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      基于Promise发送Ajax请求\n    */\n    function queryData(url) {\n     #   1.1 创建一个Promise实例\n      var p = new Promise(function(resolve, reject){\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function(){\n          if(xhr.readyState != 4) return;\n          if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) {\n            # 1.2 处理正常的情况\n            resolve(xhr.responseText);\n          }else{\n            # 1.3 处理异常情况\n            reject(\'服务器错误\');\n          }\n        };\n        xhr.open(\'get\', url);\n        xhr.send(null);\n      });\n      return p;\n    }\n	# 注意：  这里需要开启一个服务 \n    # 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了\n    queryData(\'http://localhost:3000/data\')\n      .then(function(data){\n        console.log(data)\n        #  1.4 想要继续链式编程下去 需要 return  \n        return queryData(\'http://localhost:3000/data1\');\n      })\n      .then(function(data){\n        console.log(data);\n        return queryData(\'http://localhost:3000/data2\');\n      })\n      .then(function(data){\n        console.log(data)\n      });\n  &lt;/script&gt;\n</code></pre>\n<h3>Promise  基本API</h3>\n<h4>实例方法</h4>\n<h5>.then()</h5>\n<ul>\n<li>得到异步任务正确的结果</li>\n</ul>\n<h5>.catch()</h5>\n<ul>\n<li>获取异常信息</li>\n</ul>\n<h5>.finally()</h5>\n<ul>\n<li>成功与否都会执行（不是正式标准）</li>\n</ul>\n<h4>静态方法</h4>\n<h5>.all()</h5>\n<ul>\n<li><code>Promise.all</code>方法接受一个数组作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用<code>Promise.resolve</code>转换为一个promise)。它的状态由这三个promise实例决定</li>\n</ul>\n<h5>.race()</h5>\n<ul>\n<li><code>Promise.race</code>方法同样接受一个数组作参数。当p1, p2, p3中有一个实例的状态发生改变（变为<code>fulfilled</code>或<code>rejected</code>），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数</li>\n</ul>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;title&gt;Document&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  \n  &lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      Promise常用API-对象方法\n    */\n    // console.dir(Promise)\n    function queryData(url) {\n      return new Promise(function(resolve, reject){\n        var xhr = new XMLHttpRequest();\n        xhr.onreadystatechange = function(){\n          if(xhr.readyState != 4) return;\n          if(xhr.readyState == 4 &amp;&amp; xhr.status == 200) {\n            // 处理正常的情况\n            resolve(xhr.responseText);\n          }else{\n            // 处理异常情况\n            reject(\'服务器错误\');\n          }\n        };\n        xhr.open(\'get\', url);\n        xhr.send(null);\n      });\n    }\n\n    var p1 = queryData(\'http://localhost:3000/a1\');\n    var p2 = queryData(\'http://localhost:3000/a2\');\n    var p3 = queryData(\'http://localhost:3000/a3\');\n    // 全成功了就会走then方法中，假如有一个错误就会到catch中\n    // Promise.all([p1,p2,p3]).then(function(result){\n    //   // result中的值与[p1,p2,p3]返回值一一对应\n    //   console.log(result)\n    // }).catch(err=&gt;{\n    //   console.log(err, \'aaa\')\n    // })\n\n    // 假如有一个成功，就会走then方法，全部失败了，就会走catch方法\n    Promise.race([p1,p2,p3]).then(function(result){\n      console.log(result)\n    }).catch(err=&gt;{\n      console.log(err, \'bbb\')\n    })\n  &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>fetch</h3>\n<ul>\n<li>Fetch API是新的ajax解决方案 Fetch会返回Promise</li>\n<li><strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</li>\n<li>fetch(url, options).then(）</li>\n</ul>\n<pre><code class=\"language-html\">&lt;script type=&quot;text/javascript&quot;&gt;\n    /*\n      Fetch API 基本用法\n      	fetch(url).then()\n     	第一个参数请求的路径   Fetch会返回Promise   所以我们可以使用then 拿到请求成功的结果 \n    */\n    fetch(\'http://localhost:3000/fdata\').then(function(data){\n      // text()方法属于fetchAPI的一部分，它返回一个Promise实例对象，用于获取后台返回的数据\n      return data.text();\n    }).then(function(data){\n      //   在这个then里面我们能拿到最终的数据  \n      console.log(data);\n    })\n  &lt;/script&gt;\n</code></pre>\n<h4>fetch API  中的 HTTP  请求</h4>\n<ul>\n<li>fetch(url, options).then(）</li>\n<li>HTTP协议，它给我们提供了很多的方法，如POST，GET，DELETE，UPDATE，PATCH和PUT\n<ul>\n<li>默认的是 GET 请求</li>\n<li>需要在 options 对象中 指定对应的 method       method:请求使用的方法</li>\n<li>post 和 普通 请求的时候 需要在options 中 设置  请求头 headers   和  body</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-html\">&lt;script type=&quot;text/javascript&quot;&gt;\n        /*\n              Fetch API 调用接口传递参数\n        */\n       #1.1 GET参数传递 - 传统URL  通过url  ？ 的形式传参 \n        fetch(\'http://localhost:3000/books?id=123\', {\n            	# get 请求可以省略不写 默认的是GET \n                method: \'get\'\n            })\n            .then(function(data) {\n            	# 它返回一个Promise实例对象，用于获取后台返回的数据\n                return data.text();\n            }).then(function(data) {\n            	# 在这个then里面我们能拿到最终的数据  \n                console.log(data)\n            });\n\n      #1.2  GET参数传递  restful形式的URL  通过/ 的形式传递参数  即  id = 456 和id后台的配置有关   \n        fetch(\'http://localhost:3000/books/456\', {\n            	# get 请求可以省略不写 默认的是GET \n                method: \'get\'\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n\n       #2.1  DELETE请求方式参数传递      删除id  是  id=789\n        fetch(\'http://localhost:3000/books/789\', {\n                method: \'delete\'\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n\n       #3 POST请求传参\n        fetch(\'http://localhost:3000/books\', {\n                method: \'post\',\n            	# 3.1  传递数据 \n                body: \'uname=lisi&amp;pwd=123\',\n            	#  3.2  设置请求头 \n                headers: {\n                    \'Content-Type\': \'application/x-www-form-urlencoded\'\n                }\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n\n       # POST请求传参\n        fetch(\'http://localhost:3000/books\', {\n                method: \'post\',\n                body: JSON.stringify({\n                    uname: \'张三\',\n                    pwd: \'456\'\n                }),\n                headers: {\n                    \'Content-Type\': \'application/json\'\n                }\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n\n        # PUT请求传参     修改id 是 123 的 \n        fetch(\'http://localhost:3000/books/123\', {\n                method: \'put\',\n                body: JSON.stringify({\n                    uname: \'张三\',\n                    pwd: \'789\'\n                }),\n                headers: {\n                    \'Content-Type\': \'application/json\'\n                }\n            })\n            .then(function(data) {\n                return data.text();\n            }).then(function(data) {\n                console.log(data)\n            });\n    &lt;/script&gt;\n</code></pre>\n<h4>fetchAPI 中 响应格式</h4>\n<ul>\n<li>用fetch来获取数据，如果响应正常返回，我们首先看到的是一个response对象，其中包括返回的一堆原始字节，这些字节需要在收到后，需要我们通过调用方法将其转换为相应格式的数据，比如<code>JSON</code>，<code>BLOB</code>或者<code>TEXT</code>等等</li>\n</ul>\n<pre><code class=\"language-js\">/*\n      Fetch响应结果的数据格式\n    */\n    fetch(\'http://localhost:3000/json\').then(function(data){\n      // return data.json();   //  将获取到的数据使用 json 转换对象\n      return data.text(); //  //  将获取到的数据 转换成字符串 \n    }).then(function(data){\n      // console.log(data.uname)\n      // console.log(typeof data)\n      var obj = JSON.parse(data);\n      console.log(obj.uname,obj.age,obj.gender)\n    })\n</code></pre>\n<h4>koa2后台接口测试代码</h4>\n<p><code>package.json</code></p>\n<pre><code class=\"language-json\">{\n  &quot;name&quot;: &quot;myapi&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;description&quot;: &quot;&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;keywords&quot;: [],\n  &quot;author&quot;: &quot;&quot;,\n  &quot;license&quot;: &quot;ISC&quot;,\n  &quot;dependencies&quot;: {\n    &quot;koa&quot;: &quot;^2.13.1&quot;,\n    &quot;koa-bodyparser&quot;: &quot;^4.3.0&quot;,\n    &quot;koa-router&quot;: &quot;^10.0.0&quot;,\n    &quot;koa2-cors&quot;: &quot;^2.0.6&quot;\n  }\n}\n</code></pre>\n<p><code>index.js</code></p>\n<pre><code class=\"language-js\">const Koa = require(\'koa\')\nconst Router = require(\'koa-router\')\nconst cors = require(\'koa2-cors\')\nconst bodyParser = require(\'koa-bodyparser\')\nconst app = new Koa()\n\n\napp.use(cors()); //全部允许跨域\n\n// 使用ctx.body解析中间件\napp.use(bodyParser())\n\n\n\nlet home = new Router()\n\nfunction wait(time){\n  return new Promise((resolve, reject)=&gt;{\n    setTimeout(()=&gt;{\n      resolve(\'ok\')\n    },time)\n  })\n}\n\n// 配置路由\nhome.get(\'/\', async (ctx)=&gt;{\n  ctx.body = \'hello cheny\'\n} )\nhome.get(\'/a1\', async (ctx)=&gt;{\n  let res = await wait(1000)\n  // 假如这里有个错误\n  // let a  = null\n  // a.test = \'aaa\'\n\n  ctx.body = res + \' hello 噗嗤1\'\n} )\nhome.get(\'/a2\', async (ctx)=&gt;{\n  let res = await wait(2000)\n  // 假如这里有个错误\n  // let a  = null\n  // a.test = \'aaa\'\n\n  ctx.body = res + \' hello 噗嗤2\'\n\n} )\nhome.get(\'/a3\', async (ctx)=&gt;{\n  let res = await wait(3000)\n  // 假如这里有个错误\n  // let a  = null\n  // a.test = \'aaa\'\n  ctx.body = res + \' hello 噗嗤3\'\n} )\n\nhome.get(\'/fdata\', async (ctx)=&gt;{\n  ctx.body = \' hello Fetch !\'\n} )\n\nhome.get(\'/books\', async (ctx)=&gt;{\n  // get参数获取\n  ctx.body = ctx.request.query\n} )\n\nhome.get(\'/books/:id\', async (ctx)=&gt;{\n  // restful参数接收\n  console.log(\'get\')\n  ctx.body = ctx.params.id\n} )\n\nhome.delete(\'/books/:id\', async (ctx)=&gt;{\n  // restful参数接收\n  console.log(\'delete\')\n  ctx.body = ctx.params.id\n} )\n\nhome.post(\'/books\', async (ctx)=&gt;{\n  // post参数获取 koa-bodyparser中间件\n  ctx.body = ctx.request.body\n} )\n\nhome.put(\'/books/:id\', async (ctx)=&gt;{\n  // post参数获取 koa-bodyparser中间件\n  console.log(ctx.params.id)\n  ctx.body = ctx.request.body\n} )\n\nhome.put(\'/books\', async (ctx)=&gt;{\n  // post参数获取 koa-bodyparser中间件\n  console.log(\'aaaa\')\n  ctx.body = ctx.request.body\n} )\n\nhome.get(\'/json\', async (ctx)=&gt;{\n  ctx.body = {\n    uname: \'lisi\',\n    age: 13,\n    gender: \'male\'\n  }\n} )\n\n\n// 子路由2\nlet page = new Router()\npage.get(\'/a\', (ctx)=&gt;{\n  ctx.body = \'hello a!\'\n}).get(\'/b\', async ( ctx )=&gt;{\n  ctx.body = \'helloworld b!\'\n}).get(\'/c\', async ( ctx )=&gt;{\n  ctx.body = \'helloworld c!\'\n})\n\n\n\n\n// 装载路由\nlet router = new Router()\nrouter.use(home.routes(), home.allowedMethods())\nrouter.use(\'/test\', page.routes(), page.allowedMethods())\n\napp.use(router.routes()).use(router.allowedMethods())\n\napp.listen(3000, ()=&gt;{\n  console.log(\'server start 3000\')\n})\n</code></pre>\n<h3>axios</h3>\n<ul>\n<li>基于promise用于浏览器和node.js的http客户端</li>\n<li>支持浏览器和node.js</li>\n<li>支持promise</li>\n<li>能拦截请求和响应</li>\n<li>自动转换JSON数据</li>\n<li>能转换请求和响应数据</li>\n</ul>\n<h4>axios基础用法</h4>\n<ul>\n<li>get和 delete请求传递参数\n<ul>\n<li>通过传统的url  以 ? 的形式传递参数</li>\n<li>restful 形式传递参数</li>\n<li>通过params  形式传递参数</li>\n</ul>\n</li>\n<li>post  和 put  请求传递参数\n<ul>\n<li>通过选项传递参数</li>\n<li>通过 URLSearchParams  传递参数</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\"># 1. 发送get 请求 \n	axios.get(\'http://localhost:3000/adata\').then(function(ret){ \n      #  拿到 ret 是一个对象      所有的对象都存在 ret 的data 属性里面\n      // 注意data属性是固定的用法，用于获取后台的实际数据\n      // console.log(ret.data)\n      console.log(ret)\n    })\n	# 2.  get 请求传递参数\n    # 2.1  通过传统的url  以 ? 的形式传递参数\n	axios.get(\'http://localhost:3000/axios?id=123\').then(function(ret){\n      console.log(ret.data)\n    })\n    # 2.2  restful 形式传递参数 \n    axios.get(\'http://localhost:3000/axios/123\').then(function(ret){\n      console.log(ret.data)\n    })\n	# 2.3  通过params  形式传递参数 \n    axios.get(\'http://localhost:3000/axios\', {\n      params: {\n        id: 789\n      }\n    }).then(function(ret){\n      console.log(ret.data)\n    })\n	#3 axios delete 请求传参     传参的形式和 get 请求一样\n    axios.delete(\'http://localhost:3000/axios\', {\n      params: {\n        id: 111\n      }\n    }).then(function(ret){\n      console.log(ret.data)\n    })\n\n	# 4  axios 的 post 请求\n    # 4.1  通过选项传递参数\n    axios.post(\'http://localhost:3000/axios\', {\n      uname: \'lisi\',\n      pwd: 123\n    }).then(function(ret){\n      console.log(ret.data)\n    })\n	# 4.2  通过 URLSearchParams  传递参数 \n    var params = new URLSearchParams();\n    params.append(\'uname\', \'zhangsan\');\n    params.append(\'pwd\', \'111\');\n    axios.post(\'http://localhost:3000/axios\', params).then(function(ret){\n      console.log(ret.data)\n    })\n\n 	#5  axios put 请求传参   和 post 请求一样 \n    axios.put(\'http://localhost:3000/axios/123\', {\n      uname: \'lisi\',\n      pwd: 123\n    }).then(function(ret){\n      console.log(ret.data)\n    })\n</code></pre>\n<h4>axios 全局配置</h4>\n<pre><code class=\"language-js\">#  配置公共的请求头 \naxios.defaults.baseURL = \'https://api.example.com\';\n#  配置 超时时间\naxios.defaults.timeout = 2500;\n#  配置公共的请求头\naxios.defaults.headers.common[\'Authorization\'] = AUTH_TOKEN;\n# 配置公共的 post 的 Content-Type\naxios.defaults.headers.post[\'Content-Type\'] = \'application/x-www-form-urlencoded\';\n</code></pre>\n<h4>axios 拦截器</h4>\n<ul>\n<li>请求拦截器\n<ul>\n<li>请求拦截器的作用是在请求发送前进行一些操作\n<ul>\n<li>例如在每个请求体里加上token，统一做了处理如果以后要改也非常容易</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>响应拦截器\n<ul>\n<li>响应拦截器的作用是在接收到响应后进行一些操作\n<ul>\n<li>例如在服务器返回登录状态失效，需要重新登录的时候，跳转到登录页</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"language-js\"># 1. 请求拦截器 \n	axios.interceptors.request.use(function(config) {\n      console.log(config.url)\n      # 1.1  任何请求都会经过这一步   在发送请求之前做些什么   \n      config.headers.mytoken = \'nihao\';\n      # 1.2  这里一定要return   否则配置不成功  \n      return config;\n    }, function(err){\n       #1.3 对请求错误做点什么    \n      console.log(err)\n    })\n	#2. 响应拦截器 \n    axios.interceptors.response.use(function(res) {\n      #2.1  在接收响应做些什么  \n      var data = res.data;\n      return data;\n    }, function(err){\n      #2.2 对响应错误做点什么  \n      console.log(err)\n    })\n</code></pre>\n<h3>async  和 await</h3>\n<ul>\n<li>async作为一个关键字放到函数前面\n<ul>\n<li>任何一个<code>async</code>函数都会隐式返回一个<code>promise</code></li>\n</ul>\n</li>\n<li><code>await</code>关键字只能在使用<code>async</code>定义的函数中使用\n<ul>\n<li>​    await后面可以直接跟一个 Promise实例对象</li>\n<li>​     await函数不能单独使用</li>\n</ul>\n</li>\n<li><strong>async/await 让异步代码看起来、表现起来更像同步代码</strong></li>\n</ul>\n<pre><code class=\"language-js\"># 1.  async 基础用法\n    # 1.1 async作为一个关键字放到函数前面\n	async function queryData() {\n      # 1.2 await关键字只能在使用async定义的函数中使用      await后面可以直接跟一个 Promise实例对象\n      var ret = await new Promise(function(resolve, reject){\n        setTimeout(function(){\n          resolve(\'nihao\')\n        },1000);\n      })\n      // console.log(ret.data)\n      return ret;\n    }\n	# 1.3 任何一个async函数都会隐式返回一个promise   我们可以使用then 进行链式编程\n    queryData().then(function(data){\n      console.log(data)\n    })\n\n	#2.  async    函数处理多个异步函数\n    axios.defaults.baseURL = \'http://localhost:3000\';\n\n    async function queryData() {\n      # 2.1  添加await之后 当前的await 返回结果之后才会执行后面的代码   \n      \n      var info = await axios.get(\'async1\');\n      #2.2  让异步代码看起来、表现起来更像同步代码\n      var ret = await axios.get(\'async2?info=\' + info.data);\n      return ret.data;\n    }\n\n    queryData().then(function(data){\n      console.log(data)\n    })\n</code></pre>\n<h2>Section5 前端路由</h2>\n<h3>前端路由模拟 window.onhashchange事件</h3>\n<blockquote>\n<ul>\n<li>\n<p>前端<code>a</code>标签的href属性，指向外部链接或者内部链接。比如<code>&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt; </code>，点击后会直接跳转到外部页面</p>\n</li>\n<li>\n<p>当使用以<code>#</code>开头的链接时，就是跳转到内部的锚点。比如<code>&lt;a href=&quot;#aa&quot;&gt;锚点&lt;/a&gt;</code>，点击后会直接定位在当前<code>html</code>页面某个<code>id</code>为<code>aa</code>的元素下。</p>\n</li>\n<li>\n<p>当路径变化时，其实就是页面路径的hash值变化了，所有变化的状态都会被<code>window.onhashchange</code>事件监听到，所以就可以根据这个做文章，模拟前端路由。</p>\n<pre><code class=\"language-js\">&lt;script&gt;\n    // 监听 window 的 onhashchange 事件，根据获取到的最新的 hash 值，切换要显示的组件的名称\n    window.onhashchange = function() {\n        // 通过 location.hash 获取到最新的 hash 值\n        console.log(location.hash);\n      }\n  &lt;/script&gt;\n</code></pre>\n</li>\n</ul>\n</blockquote>\n<p>测试代码：</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 导入 vue 文件 --&gt;\n    &lt;script src=&quot;./lib/vue_2.5.22.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 被 vue 实例控制的 div 区域 --&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;!-- 切换组件的超链接 --&gt;\n      &lt;a href=&quot;#/zhuye&quot;&gt;主页&lt;/a&gt; \n      &lt;a href=&quot;#/keji&quot;&gt;科技&lt;/a&gt; \n      &lt;a href=&quot;#/caijing&quot;&gt;财经&lt;/a&gt;\n      &lt;a href=&quot;#/yule&quot;&gt;娱乐&lt;/a&gt;\n\n      &lt;!-- 根据 :is 属性指定的组件名称，把对应的组件渲染到 component 标签所在的位置 --&gt;\n      &lt;!-- 可以把 component 标签当做是【组件的占位符】 --&gt;\n      &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      // #region 定义需要被切换的 4 个组件\n      // 主页组件\n      const zhuye = {\n        template: \'&lt;h1&gt;主页信息&lt;/h1&gt;\'\n      }\n\n      // 科技组件\n      const keji = {\n        template: \'&lt;h1&gt;科技信息&lt;/h1&gt;\'\n      }\n\n      // 财经组件\n      const caijing = {\n        template: \'&lt;h1&gt;财经信息&lt;/h1&gt;\'\n      }\n\n      // 娱乐组件\n      const yule = {\n        template: \'&lt;h1&gt;娱乐信息&lt;/h1&gt;\'\n      }\n      // #endregion\n\n      // #region vue 实例对象\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          comName: \'zhuye\'\n        },\n        // 注册私有组件\n        components: {\n          zhuye,\n          keji,\n          caijing,\n          yule\n        }\n      })\n      // #endregion\n\n      // 监听 window 的 onhashchange 事件，根据获取到的最新的 hash 值，切换要显示的组件的名称\n      window.onhashchange = function() {\n        // 通过 location.hash 获取到最新的 hash 值\n        console.log(location.hash);\n        switch(location.hash.slice(1)){\n          case \'/zhuye\':\n            vm.comName = \'zhuye\'\n          break\n          case \'/keji\':\n            vm.comName = \'keji\'\n          break\n          case \'/caijing\':\n            vm.comName = \'caijing\'\n          break\n          case \'/yule\':\n            vm.comName = \'yule\'\n          break\n        }\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h3>Vue Router</h3>\n<h4>基本使用</h4>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 导入 vue 文件 --&gt;\n    &lt;script src=&quot;./lib/vue_2.5.22.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./lib/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 被 vm 实例所控制的区域 --&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;router-link to=&quot;/user&quot;&gt;User&lt;/router-link&gt;\n      &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt;\n\n      &lt;!-- 路由占位符 --&gt;\n      &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      const User = {\n        template: \'&lt;h1&gt;User 组件&lt;/h1&gt;\'\n      }\n\n      const Register = {\n        template: \'&lt;h1&gt;Register 组件&lt;/h1&gt;\'\n      }\n\n      // 创建路由实例对象\n      const router = new VueRouter({\n        // 所有的路由规则\n        routes: [\n          { path: \'/user\', component: User },\n          { path: \'/register\', component: Register }\n        ]\n      })\n\n      // 创建 vm 实例对象\n      const vm = new Vue({\n        // 指定控制的区域\n        el: \'#app\',\n        data: {},\n        // 挂载路由实例对象\n        // router: router\n        router\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<ul>\n<li><code>&lt;router-view&gt;&lt;/router-view&gt;</code>是一个占位符，切换过来的组件会直接渲染至这个地方</li>\n<li><code>&lt;router-link to=&quot;/user&quot;&gt;User&lt;/router-link&gt;</code>，其实就是一个<code>a</code>标签，渲染成<code>html</code>就是这个样子<code>&lt;a href=&quot;#/user&quot; class=&quot;&quot;&gt;User&lt;/a&gt;</code></li>\n<li>\n<pre><code class=\"language-js\">// 创建路由实例对象\nconst router = new VueRouter({\n    // 所有的路由规则\n    routes: [\n        { path: \'/user\', component: User },\n        { path: \'/register\', component: Register }\n    ]\n})\n</code></pre>\n</li>\n</ul>\n</blockquote>\n<h4>路由重定向</h4>\n<pre><code class=\"language-js\">// 创建路由实例对象\nconst router = new VueRouter({\n    // 所有的路由规则\n    routes: [\n        { path: \'/\', redirect: \'/user\'},\n        { path: \'/user\', component: User },\n        { path: \'/register\', component: Register }\n    ]\n})\n</code></pre>\n<blockquote>\n<p><code>{ path: \'/\', redirect: \'/user\'},</code>，当路径是<code>/</code>时，会直接重定向到<code>/user</code>路径下，所以就会把<code>User</code>组件渲染出来</p>\n</blockquote>\n<h4>路由嵌套</h4>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 导入 vue 文件 --&gt;\n    &lt;script src=&quot;./lib/vue_2.5.22.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./lib/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 被 vm 实例所控制的区域 --&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;router-link to=&quot;/user&quot;&gt;User&lt;/router-link&gt;\n      &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt;\n\n      &lt;!-- 路由占位符 --&gt;\n      &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      const User = {\n        template: \'&lt;h1&gt;User 组件&lt;/h1&gt;\'\n      }\n\n      const Register = {\n        template: `&lt;div&gt;\n          &lt;h1&gt;Register 组件&lt;/h1&gt;\n          &lt;hr/&gt;\n\n          &lt;!-- 子路由链接 --&gt;\n          &lt;router-link to=&quot;/register/tab1&quot;&gt;tab1&lt;/router-link&gt;\n          &lt;router-link to=&quot;/register/tab2&quot;&gt;tab2&lt;/router-link&gt;\n\n          &lt;!-- 子路由的占位符 --&gt;\n          &lt;router-view /&gt;\n        &lt;div&gt;`\n      }\n\n      const Tab1 = {\n        template: \'&lt;h3&gt;tab1 子组件&lt;/h3&gt;\'\n      }\n\n      const Tab2 = {\n        template: \'&lt;h3&gt;tab2 子组件&lt;/h3&gt;\'\n      }\n\n      // 创建路由实例对象\n      const router = new VueRouter({\n        // 所有的路由规则\n        routes: [\n          { path: \'/\', redirect: \'/user\'},\n          { path: \'/user\', component: User },\n          // children 数组表示子路由规则\n          { \n            path: \'/register\', \n            redirect: \'/register/tab1\',\n            component: Register, \n            children: [\n            { path: \'/register/tab1\', component: Tab1 },\n            { path: \'/register/tab2\', component: Tab2 }] \n          }\n        ]\n      })\n\n      // 创建 vm 实例对象\n      const vm = new Vue({\n        // 指定控制的区域\n        el: \'#app\',\n        data: {},\n        // 挂载路由实例对象\n        // router: router\n        router\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>配置子路直接在路由下加个children参数</p>\n<pre><code class=\"language-js\">const router = new VueRouter({\n    // 所有的路由规则\n    routes: [\n        { path: \'/\', redirect: \'/user\'},\n        { path: \'/user\', component: User },\n        // children 数组表示子路由规则\n        { \n            path: \'/register\', \n            redirect: \'/register/tab1\',\n            component: Register, \n            children: [\n                { path: \'/register/tab1\', component: Tab1 },\n                { path: \'/register/tab2\', component: Tab2 }] \n        }\n    ]\n})\n</code></pre>\n<p>注意：子路由的前缀因该和父路由保持一致，比如这里的父路由是<code>/register</code>，所以子路由就应该是<code>/register/xxx</code>，对应起来</p>\n<p>另外对应的父组件里，为了显示子组件，也需要配置一个占位符<code>&lt;router-view /&gt;</code>，如下</p>\n<pre><code class=\"language-js\">const Register = {\n        template: `&lt;div&gt;\n          &lt;h1&gt;Register 组件&lt;/h1&gt;\n          &lt;hr/&gt;\n\n          &lt;!-- 子路由链接 --&gt;\n          &lt;router-link to=&quot;/register/tab1&quot;&gt;tab1&lt;/router-link&gt;\n          &lt;router-link to=&quot;/register/tab2&quot;&gt;tab2&lt;/router-link&gt;\n\n          &lt;!-- 子路由的占位符 --&gt;\n          &lt;router-view /&gt;\n        &lt;div&gt;`\n      }\n</code></pre>\n</blockquote>\n<h4>动态路由匹配</h4>\n<h5>路由后面接收参数：方式一</h5>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 导入 vue 文件 --&gt;\n    &lt;script src=&quot;./lib/vue_2.5.22.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./lib/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 被 vm 实例所控制的区域 --&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/2&quot;&gt;User2&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/3&quot;&gt;User3&lt;/router-link&gt;\n      &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt;\n\n      &lt;!-- 路由占位符 --&gt;\n      &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      const User = {\n        template: \'&lt;h1&gt;User 组件 -- 用户id为: {{$route.params.id}}&lt;/h1&gt;\'\n      }\n\n      const Register = {\n        template: \'&lt;h1&gt;Register 组件&lt;/h1&gt;\'\n      }\n\n      // 创建路由实例对象\n      const router = new VueRouter({\n        // 所有的路由规则\n        routes: [\n          { path: \'/\', redirect: \'/register\'},\n          { path: \'/user/:id\', component: User },\n          { path: \'/register\', component: Register }\n        ]\n      })\n\n      // 创建 vm 实例对象\n      const vm = new Vue({\n        // 指定控制的区域\n        el: \'#app\',\n        data: {},\n        // 挂载路由实例对象\n        // router: router\n        router\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>router-link的写法：<code>&lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;</code></p>\n<p>路由的写法：<code>{ path: \'/user/:id\', component: User }</code></p>\n<p>参数接收的方法：</p>\n<p>​	直接在模板页面里接收：<code>{{$route.params.id}}</code></p>\n</blockquote>\n<h5>路由后面接收参数：方式二</h5>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 导入 vue 文件 --&gt;\n    &lt;script src=&quot;./lib/vue_2.5.22.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./lib/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 被 vm 实例所控制的区域 --&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/2&quot;&gt;User2&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/3&quot;&gt;User3&lt;/router-link&gt;\n      &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt;\n\n      &lt;!-- 路由占位符 --&gt;\n      &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      const User = {\n        props: [\'id\'],\n        template: \'&lt;h1&gt;User 组件 -- 用户id为: {{id}}&lt;/h1&gt;\'\n      }\n\n      const Register = {\n        template: \'&lt;h1&gt;Register 组件&lt;/h1&gt;\'\n      }\n\n      // 创建路由实例对象\n      const router = new VueRouter({\n        // 所有的路由规则\n        routes: [\n          { path: \'/\', redirect: \'/user\'},\n          { path: \'/user/:id\', component: User, props: true },\n          { path: \'/register\', component: Register }\n        ]\n      })\n\n      // 创建 vm 实例对象\n      const vm = new Vue({\n        // 指定控制的区域\n        el: \'#app\',\n        data: {},\n        // 挂载路由实例对象\n        // router: router\n        router\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>router-link的写法：<code>&lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;</code></p>\n<p>路由的写法：<code>{ path: \'/user/:id\', component: User, props: true }</code></p>\n<p>​	这里的<code>props: true</code>表示开启<code>props</code>接收参数。</p>\n<p>参数接收的方法：</p>\n<p>​	在组件的props中声明字段：<code>props: [\'id\']</code></p>\n<p>​	然后直接在页面中接收：<code>{{id}}</code></p>\n</blockquote>\n<h5>路由后面接收参数：方式三</h5>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 导入 vue 文件 --&gt;\n    &lt;script src=&quot;./lib/vue_2.5.22.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./lib/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 被 vm 实例所控制的区域 --&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/2&quot;&gt;User2&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/3&quot;&gt;User3&lt;/router-link&gt;\n      &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt;\n\n      &lt;!-- 路由占位符 --&gt;\n      &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      const User = {\n        props: [\'id\', \'uname\', \'age\'],\n        template: \'&lt;h1&gt;User 组件 -- 用户id为: {{id}} -- 姓名为:{{uname}} -- 年龄为：{{age}}&lt;/h1&gt;\'\n      }\n\n      const Register = {\n        template: \'&lt;h1&gt;Register 组件&lt;/h1&gt;\'\n      }\n\n      // 创建路由实例对象\n      const router = new VueRouter({\n        // 所有的路由规则\n        routes: [\n          { path: \'/\', redirect: \'/user\'},\n          { path: \'/user/:id\', component: User, props: { uname: \'lisi\', age: 20 } },\n          { path: \'/register\', component: Register }\n        ]\n      })\n\n      // 创建 vm 实例对象\n      const vm = new Vue({\n        // 指定控制的区域\n        el: \'#app\',\n        data: {},\n        // 挂载路由实例对象\n        // router: router\n        router\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>router-link的写法：<code>&lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;</code></p>\n<p>路由的写法：<code>{ path: \'/user/:id\', component: User, props: { uname: \'lisi\', age: 20 } }</code></p>\n<p>​	这里的<code>props</code>接收的是一个对象，</p>\n<p>参数接收的方法：</p>\n<p>​	在组件的props中声明字段：<code>props: [\'id\', \'uname\', \'age\'],</code></p>\n<p>​	然后直接在页面中接收：<code>&lt;h1&gt;User 组件 -- 用户id为: {{id}} -- 姓名为:{{uname}} -- 年龄为：{{age}}&lt;/h1&gt;</code></p>\n<p>​		<strong>这里的<code>id</code>是接收不到的，虽然在props里也声明了，但是由于接收的是一个对象，不是布尔值了，所以接收不到，如果想接收到，可以换方式四接收，传入一个函数。</strong></p>\n</blockquote>\n<h5>路由后面接收参数：方式四</h5>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 导入 vue 文件 --&gt;\n    &lt;script src=&quot;./lib/vue_2.5.22.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./lib/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 被 vm 实例所控制的区域 --&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/2&quot;&gt;User2&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/3&quot;&gt;User3&lt;/router-link&gt;\n      &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt;\n\n      &lt;!-- 路由占位符 --&gt;\n      &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      const User = {\n        props: [\'id\', \'uname\', \'age\'],\n        template: \'&lt;h1&gt;User 组件 -- 用户id为: {{id}} -- 姓名为:{{uname}} -- 年龄为：{{age}}&lt;/h1&gt;\'\n      }\n\n      const Register = {\n        template: \'&lt;h1&gt;Register 组件&lt;/h1&gt;\'\n      }\n\n      // 创建路由实例对象\n      const router = new VueRouter({\n        // 所有的路由规则\n        routes: [\n          { path: \'/\', redirect: \'/user\' },\n          {\n            path: \'/user/:id\',\n            component: User,\n            props: route =&gt; ({ uname: \'zs\', age: 20, id: route.params.id })\n          },\n          { path: \'/register\', component: Register }\n        ]\n      })\n\n      // 创建 vm 实例对象\n      const vm = new Vue({\n        // 指定控制的区域\n        el: \'#app\',\n        data: {},\n        // 挂载路由实例对象\n        // router: router\n        router\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>router-link的写法：<code>&lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;</code></p>\n<p>路由的写法：<code>{ path: \'/user/:id\', component: User, props: route =&gt; ({ uname: \'zs\', age: 20, id: route.params.id }) }</code></p>\n<p>​	这里的<code>props</code>接收的是一个带返回值的函数，</p>\n<p>参数接收的方法：</p>\n<p>​	在组件的props中声明字段：<code>props: [\'id\', \'uname\', \'age\'],</code></p>\n<p>​	然后直接在页面中接收：<code>&lt;h1&gt;User 组件 -- 用户id为: {{id}} -- 姓名为:{{uname}} -- 年龄为：{{age}}&lt;/h1&gt;</code></p>\n<p>​		<strong>这样就把所有的参数都接收到了。</strong></p>\n</blockquote>\n<h4>路由参数可选可不选</h4>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 导入 vue 文件 --&gt;\n    &lt;script src=&quot;./lib/vue_2.5.22.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./lib/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 被 vm 实例所控制的区域 --&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/2&quot;&gt;User2&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/3&quot;&gt;User3&lt;/router-link&gt;\n      &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt;\n\n      &lt;!-- 路由占位符 --&gt;\n      &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      const User = {\n        template: \'&lt;h1&gt;User 组件 -- 用户id为: {{$route.params.id}}&lt;/h1&gt;\'\n      }\n\n      const Register = {\n        template: \'&lt;h1&gt;Register 组件&lt;/h1&gt;\'\n      }\n\n      // 创建路由实例对象\n      const router = new VueRouter({\n        // 所有的路由规则\n        routes: [\n          { path: \'/\', redirect: \'/register\'},\n          { path: \'/user/:id?\', component: User },\n          { path: \'/register\', component: Register }\n        ]\n      })\n\n      // 创建 vm 实例对象\n      const vm = new Vue({\n        // 指定控制的区域\n        el: \'#app\',\n        data: {},\n        // 挂载路由实例对象\n        // router: router\n        router\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>router-link的写法：<code>&lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;</code></p>\n<p>路由的写法：<code>{ path: \'/user/:id?\', component: User }</code></p>\n<p>参数接收的方法：</p>\n<p>​	直接在模板页面里接收：<code>{{$route.params.id}}</code></p>\n<p>​	这时候，假如不传id，也是可以跳转到<code>/user</code>路径下的</p>\n</blockquote>\n<h4>命名路由</h4>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; /&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;!-- 导入 vue 文件 --&gt;\n    &lt;script src=&quot;./lib/vue_2.5.22.js&quot;&gt;&lt;/script&gt;\n    &lt;script src=&quot;./lib/vue-router_3.0.2.js&quot;&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- 被 vm 实例所控制的区域 --&gt;\n    &lt;div id=&quot;app&quot;&gt;\n      &lt;router-link to=&quot;/user/1&quot;&gt;User1&lt;/router-link&gt;\n      &lt;router-link to=&quot;/user/2&quot;&gt;User2&lt;/router-link&gt;\n      &lt;router-link :to=&quot;{ name: \'user\', params: {id: 3} }&quot;&gt;User3&lt;/router-link&gt;\n      &lt;router-link to=&quot;/register&quot;&gt;Register&lt;/router-link&gt;\n\n      &lt;!-- 路由占位符 --&gt;\n      &lt;router-view&gt;&lt;/router-view&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      const User = {\n        props: [\'id\', \'uname\', \'age\'],\n        template: \'&lt;h1&gt;User 组件 -- 用户id为: {{id}} -- 姓名为:{{uname}} -- 年龄为：{{age}}&lt;/h1&gt;\'\n      }\n\n      const Register = {\n        template: \'&lt;h1&gt;Register 组件&lt;/h1&gt;\'\n      }\n\n      // 创建路由实例对象\n      const router = new VueRouter({\n        // 所有的路由规则\n        routes: [\n          { path: \'/\', redirect: \'/user\' },\n          {\n            // 命名路由\n            name: \'user\',\n            path: \'/user/:id\',\n            component: User,\n            props: route =&gt; ({ uname: \'zs\', age: 20, id: route.params.id })\n          },\n          { path: \'/register\', component: Register }\n        ]\n      })\n\n      // 创建 vm 实例对象\n      const vm = new Vue({\n        // 指定控制的区域\n        el: \'#app\',\n        data: {},\n        // 挂载路由实例对象\n        // router: router\n        router\n      })\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<blockquote>\n<p>router-link的写法：<code>&lt;router-link :to=&quot;{ name: \'user\', params: {id: 3} }&quot;&gt;User3&lt;/router-link&gt;</code></p>\n<p>命名路由的写法：</p>\n<pre><code class=\"language-js\">// 创建路由实例对象\n  const router = new VueRouter({\n    // 所有的路由规则\n    routes: [\n      { path: \'/\', redirect: \'/user\' },\n      {\n        // 命名路由\n        name: \'user\',\n        path: \'/user/:id\',\n        component: User,\n        props: route =&gt; ({ uname: \'zs\', age: 20, id: route.params.id })\n      },\n      { path: \'/register\', component: Register }\n    ]\n  })\n</code></pre>\n</blockquote>\n<h4>编程式导航</h4>\n<p>（1）直接按照路径跳转</p>\n<pre><code class=\"language-js\">this.$router.push(\'/register\')\n</code></pre>\n<p>（2）带参数跳转 路由上的地址是：<code>#/register?name=cheny&amp;gender=man</code></p>\n<pre><code class=\"language-js\">this.$router.push({\n  path: \'/register\',\n  query: {\n    name: \'cheny\',\n    gender: \'man\'\n  }\n})\n</code></pre>\n<p>（3）根据路由名字跳转 路由上的地址是：<code>#/info/cheny</code></p>\n<pre><code class=\"language-js\">// 传对象跳转\nthis.$router.push({\n  name: \'info\',\n  params: {\n    id: \'cheny\'\n  }\n})\n// 或者，直接拼参数\nthis.$router.push(`/info/${id}`)\n\n// 注意\nconst router = new VueRouter({\n  routes: [\n    {\n      path: \'/info/:id\',\n      name: \'info\',\n      component: Info,\n    },\n  ]\n})\n</code></pre>\n<p>（4）返回上一页</p>\n<pre><code class=\"language-js\">// 在浏览器记录中前进一步，等同于 history.forward()\nthis.$router.go(1)\n\n// 后退一步记录，等同于 history.back()\nthis.$router.go(-1)\n\n// 前进 3 步记录\nthis.$router.go(3)\n\n// 如果 history 记录不够用，那就默默地失败呗\nthis.$router.go(-100)\nthis.$router.go(100)\n</code></pre>\n<blockquote>\n<p>注意：<strong>如果提供了 <code>path</code>，<code>params</code> 会被忽略</strong></p>\n<p>即：<code>path</code>与<code>query</code>是一对的。<code>name</code>与<code>params</code>是一对的。</p>\n<ul>\n<li>当使用<code>params</code>传参时，路径是<code>/user/123</code>这样的，需要配置路由<code>/user/:id</code></li>\n<li>当使用<code>query</code>传参时，路径是<code>/user?uname=cheny&amp;gender=male</code></li>\n<li>想要接收参数是，在页面直接<code>this.$route.params</code>或者<code>this.$route.query</code>都能找到。</li>\n</ul>\n</blockquote>\n<h2>总结</h2>\n<ul>\n<li>在第一小节中，将vue2的基础语法过了一遍，通篇比较基础，介绍了vue的渲染、指令、双向绑定、事件、基础语句等等。</li>\n<li>在第二小节中，介绍了vue2的常用特性，计算属性、侦听器、过滤器、声明周期。</li>\n<li>在第三小节中，介绍了vue2的组件化开发方式，组件的注册，插槽的使用，组件之间的相互传参，另外扩充了如何安装vue的调试工具。</li>\n<li>在第四小节中，介绍了vue2开发中常用的接口请求方式，axios，fetch、其中axios是比较常用的了，又简单介绍了promise、async、await的使用方法</li>\n<li>在第五小节中，介绍了vue2路由的基本使用方法，包括路由的配置、传参、编程式导航等</li>\n</ul>\n<p>示例代码地址：https://gitee.com/hrbust_cheny/note_code/tree/master/vue2/vue2%E5%9F%BA%E7%A1%80</p>\n', '2021-10-15 16:48:52', '2021-12-09 21:54:42');
INSERT INTO `t_blog` VALUES ('baf99490-55ab-11ec-96d5-7933aca11ca0', '词边界：\\b', '词边界 `\\b` 是一种检查，就像 `^` 和 `$` 一样。\n\n当正则表达式引擎（实现搜索正则表达式的程序模块）遇到 `\\b` 时，它会检查字符串中的位置是否是词边界。', '-1', 2, 'https://zh.javascript.info/regexp-boundary', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 3, 0, 2, 2, 1, '', '<h2>前言</h2>\n<p>词边界 <code>\\b</code> 是一种检查，就像 <code>^</code> 和 <code>$</code> 一样。</p>\n<p>当正则表达式引擎（实现搜索正则表达式的程序模块）遇到 <code>\\b</code> 时，它会检查字符串中的位置是否是词边界。</p>\n<h2>词边界<code>\\b</code></h2>\n<p>有三种不同的位置可作为词边界：</p>\n<ul>\n<li>在字符串开头，如果第一个字符是单词字符 <code>\\w</code>。</li>\n<li>在字符串中的两个字符之间，其中一个是单词字符 <code>\\w</code>，另一个不是。</li>\n<li>在字符串末尾，如果最后一个字符是单词字符 <code>\\w</code>。</li>\n</ul>\n<h2>一个小例子</h2>\n<p>例如，可以在 <code>Hello, Java!</code> 中找到匹配 <code>\\bJava\\b</code> 的单词，其中 <code>Java</code> 是一个独立的单词，而在 <code>Hello, JavaScript!</code> 中则不行。</p>\n<pre><code class=\"language-js\">console.log(&quot;Hello, Java!&quot;.match(/\\bJava\\b/)); // [ \'Java\', index: 7, input: \'Hello, Java!\', groups: undefined ]\nconsole.log(&quot;Hello, JavaScript!&quot;.match(/\\bJava\\b/)); // null\n</code></pre>\n<p>在字符串 <code>Hello, Java!</code> 中，以下位置对应于 <code>\\b</code>：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112051624292.png\" alt=\"image-20211205162448165\" /></p>\n<p>因此，它与模式 <code>\\bHello\\b</code> 相匹配，因为：</p>\n<ol>\n<li>字符串的开头符合第一种检查 <code>\\b</code>。</li>\n<li>然后匹配了单词 <code>Hello</code>。</li>\n<li>然后与 <code>\\b</code> 再次匹配，因为我们在 <code>o</code> 和一个空格之间。</li>\n</ol>\n<pre><code class=\"language-js\">// 匹配的四个空位置就是上图中四个箭头指的地方，\\b并匹配的是位置，并不是字符\nconsole.log(&quot;Hello, Java!&quot;.match(/\\b/g)); // [ \'\', \'\', \'\', \'\' ]\n</code></pre>\n<p>模式 <code>\\bJava\\b</code> 也同样匹配。但 <code>\\bHell\\b</code>（因为 <code>l</code> 之后没有词边界）和 <code>Java!\\b</code>（因为感叹号不是单词 <code>\\w</code>，所以其后没有词边界）却不匹配。</p>\n<p>如下：</p>\n<pre><code class=\"language-js\">console.log(&quot;Hello, Java!&quot;.match(/\\bHello\\b/)); // [ \'Hello\', index: 0, input: \'Hello, Java!\', groups: undefined ]\nconsole.log(&quot;Hello, Java!&quot;.match(/\\bJava\\b/));  // [ \'Java\', index: 7, input: \'Hello, Java!\', groups: undefined ]\nconsole.log(&quot;Hello, Java!&quot;.match(/\\bHell\\b/));  // null\nconsole.log(&quot;Hello, Java!&quot;.match(/\\bJava!\\b/)); // null\n// 稍作更改就能匹配，最后一个是单词 a 所以会匹配到a\\b\nconsole.log(&quot;Hello, Java&quot;.match(/\\bJava\\b/)); // [ \'Java\', index: 7, input: \'Hello, Java\', groups: undefined ]\n</code></pre>\n<p><code>\\b</code> 既可以用于单词，也可以用于数字。</p>\n<p>例如，模式 <code>\\b\\d\\d\\b</code> 查找独立的两位数。换句话说，它查找的是两位数，其周围是与 <code>\\w</code> 不同的字符，例如空格或标点符号（或文本开头/结尾）。</p>\n<pre><code class=\"language-js\">console.log(&quot;1 23 456 78&quot;.match(/\\b\\d\\d\\b/g)); // [ \'23\', \'78\' ]\nconsole.log(&quot;12,34,56&quot;.match(/\\b\\d\\d\\b/g)); // [ \'12\', \'34\', \'56\' ]\n</code></pre>\n<blockquote>\n<p><strong>词边界 <code>\\b</code> 不适用于非拉丁字母</strong></p>\n<p>词边界测试 <code>\\b</code> 检查位置的一侧是否匹配 <code>\\w</code>，而另一侧则不匹配 “<code>\\w</code>”。</p>\n<p>但是，<code>\\w</code> 表示拉丁字母 <code>a-z</code>（或数字或下划线），因此此检查不适用于其他字符，如西里尔字母（cyrillic letters）或象形文字（hieroglyphs）。</p>\n</blockquote>\n<h2>总结</h2>\n<p><code>\\b</code>匹配的是一个位置，类似于<code>^ $</code>匹配的是文本的开头或结尾一样。</p>\n<p>匹配到<code>\\b</code>的位置，包含下面几种情况</p>\n<ol>\n<li>字符串的开头，然后第一个字符是个单词符<code>\\w</code></li>\n<li>在字符串的中间，其中一个是单词字符<code>\\w</code>，另一个不是。</li>\n<li>在字符串的末尾，如果最后一个字符是单词符<code>\\w</code></li>\n</ol>\n<p>注意：词边界测试<code>\\b</code>检查的是一侧是否匹配<code>\\w</code>，而另一侧不匹配<code>\\w</code>。但是<code>\\w</code>表示拉丁字母<code>a-z</code>（或数字或下划线），因此它不适用于其他字符，如西里尔字母（cyrillic letters）或象形文字（hieroglyphs）。</p>\n<pre><code class=\"language-js\">let regexp1 = /\\p{sc=Han}/gu; // returns Chinese hieroglyphs\nlet regexp2 = /\\p{sc=Cyrillic}/gu; // returns 西里尔字符 \n\nlet str = `Hello Привет 你好 123 _456`;\n\nconsole.log(str.match(regexp1)); // [ \'你\', \'好\' ]\nconsole.log(str.match(regexp2)); // [ \'П\', \'р\', \'и\', \'в\', \'е\', \'т\' ]\n\n// 1. 词边界测试，测试 a-zA-Z 生效\nconsole.log(str.match(/\\b\\w+\\b/));\n/*\n[\n  \'Hello\',\n  index: 0,\n  input: \'Hello Привет 你好 123 _456\',\n  groups: undefined\n]\n*/\n\n// 2. 词边界测试，测试 数字 生效\nconsole.log(str.match(/\\b\\d+\\b/));\n/*\n[\n  \'123\',\n  index: 16,\n  input: \'Hello Привет 你好 123 _456\',\n  groups: undefined\n]\n*/\n\n// 3. 词边界测试，测试 下划线 生效\nconsole.log(str.match(/\\b_\\d+\\b/));\n/*\n[\n  \'_456\',\n  index: 20,\n  input: \'Hello Привет 你好 123 _456\',\n  groups: undefined\n]\n*/\n\n// 4. 词边界测试，测试 西里尔字符Cyrillic 不生效\nconsole.log(str.match(/\\b\\p{sc=Cyrillic}+\\b/u)); // null\nconsole.log(str.match(/\\p{sc=Cyrillic}+/u)); // Привет\n/*\n[\n  \'Привет\',\n  index: 6,\n  input: \'Hello Привет 你好 123 _456\',\n  groups: undefined\n]\n*/\n\n// 5. 词边界测试，测试 象形文字hieroglyphs 不生效\nconsole.log(str.match(/\\b\\p{sc=Han}+\\b/u)); // null\nconsole.log(str.match(/\\p{sc=Han}+/u)); // 你好\n/*\n[\n  \'你好\',\n  index: 13,\n  input: \'Hello Привет 你好 123 _456\',\n  groups: undefined\n]\n*/\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-boundary\">https://zh.javascript.info/regexp-boundary</a></p>\n', '2021-12-05 17:14:20', '2021-12-05 17:14:20');
INSERT INTO `t_blog` VALUES ('c0bfbad0-5c81-11ec-96d5-7933aca11ca0', '对象的深拷贝与浅拷贝', '浅拷贝有很多种方法，扩展运算符、`Object.assign`方法，直接`for in` 遍历拷贝。\n\n深拷贝需要使用递归，需要额外考虑一些特殊情况，比如扩展对象`Date|RegExp`的拷贝，还有可能会遇到循环引用，该如何解决。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 2, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>浅拷贝有很多种方法，扩展运算符、<code>Object.assign</code>方法，直接<code>for in</code> 遍历拷贝。</p>\n<p>深拷贝需要使用递归，需要额外考虑一些特殊情况，比如扩展对象<code>Date|RegExp</code>的拷贝，还有可能会遇到循环引用，该如何解决。</p>\n<h2>浅拷贝</h2>\n<p>使用<code>for in</code>来遍历对象，需要注意下面几点：</p>\n<ol>\n<li>for in 会遍历到继承过来的属性，所以使用<code>hasOwnProperty</code>判断一下，只拷贝自己本身的属性</li>\n<li>本例中只考虑到了数组和普通对象，使用了<code>instanceof</code>判断传递过来的值</li>\n</ol>\n<pre><code class=\"language-js\">// 只考虑对象类型\nfunction shallowCopy(obj) {\n    if (typeof obj !== \'object\') return\n\n    let newObject = obj instanceof Array ? [] : {}\n\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObject[key] = obj[key]\n        }\n    }\n\n    return newObject\n}\n</code></pre>\n<h2>深拷贝</h2>\n<h3>简单版</h3>\n<p>只考虑普通对象，不考虑内置对象和函数。</p>\n<p>使用递归，赋值时在判断一下类型。</p>\n<pre><code class=\"language-js\">function deepClone(obj) {\n    if (typeof obj !== \'object\') return;\n    let newObj = obj instanceof Array ? [] : {};\n\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = typeof obj[key] === \'object\' ? deepClone(obj[key]) : obj[key];\n        }\n    }\n\n    return newObj\n}\n</code></pre>\n<h3>复杂版</h3>\n<p>基于简单版的基础上，还考虑了内置对象比如 Date、RegExp 等对象和函数以及解决了循环引用的问题。</p>\n<pre><code class=\"language-js\">const isObject = (target) =&gt; {\n    return (typeof target === \'object\' || typeof target === \'function\') &amp;&amp; target !== null\n}\n\nfunction deepClone(target, map = new WeakMap()) {\n    if (map.get(target)) { // 如果这个对象已经在map里保存过了，说明碰到了循环引用，直接返回\n        return target\n    }\n\n    // 获取当前值的构造函数，获取它的类型\n    let constructor = target.constructor\n    // 检测当前对象target是否是正则、日期格式对象匹配\n    if (/^(RegExp|Date)$/i.test(constructor.name)) {\n        // 如果匹配了，创建一个新的特殊对象的实例\n        return new constructor(target)\n    }\n\n    if (isObject(target)) {\n        map.set(target, true) // 为循环引用做标记\n        const cloneTarget = Array.isArray(target) ? [] : {}\n\n        for (let prop in target) {\n            if (target.hasOwnProperty(prop)) {\n                cloneTarget[prop] = deepClone(target[prop], map)\n            }\n        }\n\n        return cloneTarget\n    } else {\n        return target\n    }\n}\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>\n<p>浅拷贝时：</p>\n<ol>\n<li>\n<p>判断传递过来的是数组还是对象，可以使用下面几种方法</p>\n<ol>\n<li><code>Array.isArray()</code> 判断是否是数组</li>\n<li><code>target instanceof Array</code> 判断原型</li>\n<li><code>Object.prototype.toString.call(target) ===\'[object Array]\'</code> 打印输出</li>\n</ol>\n</li>\n<li>\n<p>使用<code>for in</code>遍历对象时，继承属性也会被遍历出来，所以在赋值时，可以使用<code>Object.prototype.hasOwnProperty</code>判断一下是否是自己的属性</p>\n</li>\n<li>\n<p>深拷贝时，有可能会出现循环引用的情况，可以在递归的时候传递一个<code>weakMap</code>，记录下已经遍历过的对象，当再次遇到时，直接返回结果即可。</p>\n</li>\n<li>\n<p>判断传递的对象是否是扩展对象<code>Date|RegExp</code>，可以使用它们的<code>constructor</code>属性，比如：</p>\n<p><code>/^(RegExp|Date)$/i.test(constructor.name)</code></p>\n</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6946022649768181774#heading-9\">https://juejin.cn/post/6946022649768181774#heading-9</a></p>\n', '2021-12-14 10:01:29', '2021-12-14 10:01:29');
INSERT INTO `t_blog` VALUES ('c69fa070-5018-11ec-96d5-7933aca11ca0', '数据类型', '说一下js的几种数据类型。\n\n当这样问自己的时候，发现并不能很流利的回答出来，学了这么久的js，可真是太不扎实了，本篇文章就对这个问题做个梳理，简单的总结一下。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 3, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>说一下js的几种数据类型。</p>\n<p>当这样问自己的时候，发现并不能很流利的回答出来，学了这么久的js，可真是太不扎实了，本篇文章就对这个问题做个梳理，简单的总结一下。</p>\n<h2>所有数据类型</h2>\n<h3>记忆方法</h3>\n<p>我会这样去记忆：</p>\n<ol>\n<li>\n<p>基本类型</p>\n<p><code>undefined、null</code></p>\n<p><code>string number bigint</code></p>\n<p><code>boolean</code></p>\n<p><code>symbol</code></p>\n</li>\n<li>\n<p>引用类型</p>\n<p><code>object、function</code></p>\n</li>\n</ol>\n<blockquote>\n<p>为什么按上面这样列呢？其实是按照<code>typeof</code>运算符的返回值记忆的。不过<code>typeof null</code>并不会返回<code>null</code>，而是会返回<code>object</code>，这个特殊记一下。另外还有一个<code>NaN</code>，它是<code>not a number</code>的缩写，虽然它不是数值，但是使用<code>typeof NaN</code>做运算时，仍会返回<code>number</code>，这个也需要特殊记忆一下。然后就是<code>function</code>，它实际上也是一个<code>object</code></p>\n<p><code>typeof</code> 的使用 参考另一篇文章：<a href=\"http://bnbiye.cn/#/articleDetail/d44e8580-48e1-11ec-96d5-7933aca11ca0\">typeof</a></p>\n</blockquote>\n<h3>undefined</h3>\n<p>什么时候会返回<code>undefined</code>呢？</p>\n<ol>\n<li>\n<p>访问声明，但未初始化的变量</p>\n<pre><code class=\"language-js\">let aaa\nconsole.log(aaa) // undefined\n</code></pre>\n</li>\n<li>\n<p>访问对象不存在的属性</p>\n<pre><code class=\"language-js\">let bbb = {}\nconsole.log(bbb.a); // undefined\n</code></pre>\n</li>\n<li>\n<p>访问没有被显示传值的函数参数</p>\n<pre><code class=\"language-js\">(function (a) {\n    console.log(a); // undefined\n})()\n</code></pre>\n</li>\n<li>\n<p>访问任何被设置为<code>undefined</code>值的变量</p>\n<pre><code class=\"language-js\">let ccc = undefined\nconsole.log(ccc); // undefined\n</code></pre>\n</li>\n<li>\n<p>没有定义<code>return</code>的函数隐士返回<code>undefined</code></p>\n<pre><code class=\"language-js\">function ddd() { }\nconsole.log(ddd()); // undefined\n</code></pre>\n</li>\n<li>\n<p>函数<code>return</code>没有显示的返回任何内容</p>\n<pre><code class=\"language-js\">function eee() {\n    return\n}\nconsole.log(eee()); // undefined\n</code></pre>\n</li>\n<li>\n<p>数组未显示填充值的位置处，默认赋值为<code>undefined</code></p>\n<pre><code class=\"language-js\">let arr = [1, , 3]\nconsole.log(arr[1]); // undefined\n</code></pre>\n</li>\n</ol>\n<h3>null</h3>\n<p>当某个对象不需要了的时候，我们可以显示的给其赋值为<code>null</code>，释放内存空间。</p>\n<blockquote>\n<p>undefined和null的区别</p>\n<p><code>null</code>表示“没有对象”，该处不应该有值。<code>undefined</code>表示“缺少值”，就是此处应该有一个值，但是还没有定义。</p>\n<p>参考：<a href=\"http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html\">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></p>\n</blockquote>\n<h3>string</h3>\n<p>js中的字符串有下面两种定义方式</p>\n<ol>\n<li>\n<p>字符串字面量（单引号或双引号）</p>\n<pre><code class=\"language-js\">let str1 = &quot;abc&quot;\nlet str2 = &quot;456&quot;\nlet str1 = \'aaa\'\n</code></pre>\n</li>\n<li>\n<p>使用<code>String</code>函数声明</p>\n<pre><code class=\"language-js\">// thing 表示任何可以被转换成字符串的值。\n// String(thing)\n// new String(thing)\n</code></pre>\n</li>\n<li>\n<p>ES6中的模板字符串</p>\n<pre><code class=\"language-js\">let str = `abc`\n</code></pre>\n</li>\n</ol>\n<blockquote>\n<p>基本字符串与字符换对象的区别。</p>\n<p>字符串字面量 (通过单引号或双引号定义) 和 直接调用 String 方法(没有通过 new 生成字符串对象实例)的字符串都是基本字符串。JavaScript会自动将基本字符串转换为字符串对象，只有将基本字符串转化为字符串对象之后才可以使用字符串对象的方法。</p>\n<pre><code class=\"language-js\">let str1 = \'123\'\nlet str2 = String(456)\nlet str3 = new String(\'aaa\')\nconsole.log(typeof str1); // string\nconsole.log(typeof str2); // string\nconsole.log(typeof str3); // object\n</code></pre>\n<p>当基本字符串需要调用一个字符串对象才有的方法或者查询值的时候(基本字符串是没有这些方法的)，JavaScript 会自动将基本字符串转化为字符串对象并且调用相应的方法或者执行查询。</p>\n<p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String</a></p>\n</blockquote>\n<h3>number</h3>\n<p>类型<code>number</code>与类型<code>string</code>类似，<code>number</code>也有一个包装类<code>Number</code>，所以也有下面几种定义方式</p>\n<ol>\n<li>\n<p>直接使用数字</p>\n</li>\n<li>\n<p>使用<code>Number</code>构造器</p>\n<pre><code class=\"language-js\">let a = 123\nlet b = 1.123\nlet c = Number(123)\nlet d = new Number(123)\nconsole.log(typeof a); // number\nconsole.log(typeof b); // number\nconsole.log(typeof c); // number\nconsole.log(typeof d); // object\n</code></pre>\n</li>\n</ol>\n<blockquote>\n<p>直接使用数字或者<code>String(number)</code>声明出来的都是一样的效果，使用<code>new Number()</code>声明出来的是对象。</p>\n<p>当想使用<code>Number</code>原型上的方法时，会将数字自动的转换为<code>Number</code>的包装对象。</p>\n<p>使用<code>Number(xxx)</code>，如果传入的参数无法转为为数字，会返回<code>NaN</code>。</p>\n</blockquote>\n<p>js的整数取值范围是<code>(-2^53, 2^53)</code>（不包含两个端点），在解析序列化的JSON时，如果JSON解析器将它们强制转换为Number类型，那么超出此范围的整数值可能会被破坏。</p>\n<p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number</a></p>\n<h3>bigint</h3>\n<p><code>BigInt</code> 是一种特殊的数字类型，它提供了对任意长度整数的支持。</p>\n<p>创建 bigint 的方式有两种：在一个整数字面量后面加 <code>n</code> 或者调用 <code>BigInt</code> 函数，该函数从字符串、数字等中生成 bigint。</p>\n<pre><code class=\"language-js\">const bigint = 1234567890123456789012345678901234567890n;\n\nconst sameBigint = BigInt(&quot;1234567890123456789012345678901234567890&quot;);\n\nconst bigintFromNumber = BigInt(10); // 与 10n 相同\n</code></pre>\n<p><code>BigInt</code> 大多数情况下可以像常规数字类型一样使用，例如：</p>\n<pre><code class=\"language-js\">console.log(1n + 2n); // 3n\n\nconsole.log(5n / 2n); // 2n\n</code></pre>\n<p>请注意：除法 <code>5/2</code> 的结果向零进行舍入，舍入后得到的结果没有了小数部分。对 bigint 的所有操作，返回的结果也是 bigint。</p>\n<p>我们不可以把 bigint 和常规数字类型混合使用：</p>\n<pre><code class=\"language-js\">console.log(1n + 2) // TypeError: Cannot mix BigInt and other types, use explicit conversions\n</code></pre>\n<p>如果有需要，我们应该显式地转换它们：使用 <code>BigInt()</code> 或者 <code>Number()</code>，像这样：</p>\n<pre><code class=\"language-js\">let bigint = 1n;\nlet number = 2;\n\n// 将 number 转换为 bigint\nconsole.log(bigint + BigInt(number)); // 3n\n\n// 将 bigint 转换为 number\nconsole.log(Number(bigint) + number); // 3\n</code></pre>\n<p>转换操作始终是静默的，绝不会报错，但是如果 bigint 太大而数字类型无法容纳，则会截断多余的位，因此我们应该谨慎进行此类转换。</p>\n<blockquote>\n<p><strong>BigInt 不支持一元加法</strong></p>\n<p>一元加法运算符 <code>+value</code>，是大家熟知的将 <code>value</code> 转换成数字类型的方法。</p>\n<p>为了避免混淆，在 bigint 中不支持一元加法：</p>\n<pre><code class=\"language-js\">let bigint = 1n;\n\nconsole.log(+bigint); // TypeError: Cannot convert a BigInt value to a number\n</code></pre>\n<p>所以我们应该用 <code>Number()</code> 来将一个 bigint 转换成一个数字类型。</p>\n</blockquote>\n<p>比较运算符，例如 <code>&lt;</code> 和 <code>&gt;</code>，使用它们来对 bigint 和 number 类型的数字进行比较没有问题：</p>\n<pre><code class=\"language-js\">console.log( 2n &gt; 1n ); // true\n\nconsole.log( 2n &gt; 1 ); // true\n</code></pre>\n<p>但是请注意，由于 number 和 bigint 属于不同类型，它们可能在进行 <code>==</code> 比较时相等，但在进行 <code>===</code>（严格相等）比较时不相等：</p>\n<pre><code class=\"language-js\">console.log( 1 == 1n ); // true\n\nconsole.log( 1 === 1n ); // false\n</code></pre>\n<p>当在 <code>if</code> 或其他布尔运算中时，bigint 的行为类似于 number。</p>\n<p>例如，在 <code>if</code> 中，bigint <code>0n</code> 为假，其他值为 <code>true</code>：</p>\n<pre><code class=\"language-js\">if (0n) {\n  // 永远不会执行\n}\n</code></pre>\n<p>布尔运算符，例如 <code>||</code>，<code>&amp;&amp;</code> 和其他运算符，处理 bigint 的方式也类似于 number：</p>\n<pre><code class=\"language-js\">console.log( 1n || 2 ); // 1n（1n 被认为是真）\n\nconsole.log( 0n || 2 ); // 2（0n 被认为是假）\n</code></pre>\n<p>参考：<a href=\"https://zh.javascript.info/bigint\">https://zh.javascript.info/bigint</a></p>\n<h3>boolean</h3>\n<p>boolean 类型仅包含两个值：<code>true</code> 和 <code>false</code>。</p>\n<p>这种类型通常用于存储表示 yes 或 no 的值：<code>true</code> 意味着 “yes，正确”，<code>false</code> 意味着 “no，不正确”。</p>\n<p>比如：</p>\n<pre><code class=\"language-js\">let nameFieldChecked = true; // yes, name field is checked\nlet ageFieldChecked = false; // no, age field is not checked\n</code></pre>\n<p>布尔值也可作为比较的结果：</p>\n<pre><code class=\"language-js\">let isGreater = 4 &gt; 1;\n\nalert( isGreater ); // true（比较的结果是 &quot;yes&quot;）\n</code></pre>\n<h3>symbol</h3>\n<p>根据规范，对象的属性键只能是字符串类型或者 Symbol 类型。不是 Number，也不是 Boolean，只有字符串或 Symbol 这两种类型。</p>\n<p>“Symbol” 值表示唯一的标识符。</p>\n<p>可以使用 <code>Symbol()</code> 来创建这种类型的值：</p>\n<pre><code class=\"language-js\">// id 是 symbol 的一个实例化对象\nlet id = Symbol();\n</code></pre>\n<p>创建时，我们可以给 Symbol 一个描述（也称为 Symbol 名），这在代码调试时非常有用：</p>\n<pre><code class=\"language-js\">// id 是描述为 &quot;id&quot; 的 Symbol\nlet id = Symbol(&quot;id&quot;);\n</code></pre>\n<p>Symbol 保证是唯一的。即使我们创建了许多具有相同描述的 Symbol，它们的值也是不同。描述只是一个标签，不影响任何东西。</p>\n<p>例如，这里有两个描述相同的 Symbol —— 它们不相等：</p>\n<pre><code class=\"language-js\">let id1 = Symbol(&quot;id&quot;);\nlet id2 = Symbol(&quot;id&quot;);\n\nconsole.log(id1 === id2); // false\n</code></pre>\n<blockquote>\n<p><strong>Symbol 不会被自动转换为字符串</strong></p>\n<p>JavaScript 中的大多数值都支持字符串的隐式转换。例如，我们可以 <code>alert</code> 任何值，都可以生效。Symbol 比较特殊，它不会被自动转换。</p>\n<p>例如，这个 <code>alert</code> 将会提示出错：</p>\n<pre><code class=\"language-js\">let id = Symbol(&quot;id&quot;);\nalert(id); // 类型错误：无法将 Symbol 值转换为字符串。\n</code></pre>\n<p>这是一种防止混乱的“语言保护”，因为字符串和 Symbol 有本质上的不同，不应该意外地将它们转换成另一个。</p>\n<p>如果我们真的想显示一个 Symbol，我们需要在它上面调用 <code>.toString()</code>，如下所示：</p>\n<pre><code class=\"language-js\">let id = Symbol(&quot;id&quot;);\nalert(id.toString()); // Symbol(id)，现在它有效了\n</code></pre>\n<p>或者获取 <code>symbol.description</code> 属性，只显示描述（description）：</p>\n<pre><code class=\"language-js\">let id = Symbol(&quot;id&quot;);\nalert(id.description); // id\n</code></pre>\n</blockquote>\n<p>具体参考：<a href=\"https://zh.javascript.info/symbol\">https://zh.javascript.info/symbol</a></p>\n<h3>object</h3>\n<p>我们可以用下面两种语法中的任一种来创建一个空的对象</p>\n<pre><code class=\"language-js\">let user = new Object(); // “构造函数” 的语法\nlet user = {};  // “字面量” 的语法\n</code></pre>\n<p>对象的属性命名没有限制，可以是任何字符串或者 symbol，例如，当数字 <code>0</code> 被用作对象的属性的键时，会被转换为字符串 <code>&quot;0&quot;</code>：</p>\n<pre><code class=\"language-js\">let obj = {\n  0: &quot;test&quot; // 等同于 &quot;0&quot;: &quot;test&quot;\n};\n</code></pre>\n<p>参考：<a href=\"https://zh.javascript.info/object#shu-xing-ming-cheng-xian-zhi\">https://zh.javascript.info/object#shu-xing-ming-cheng-xian-zhi</a></p>\n<h3>function</h3>\n<p>两种声明方式</p>\n<ol>\n<li>\n<p>使用<code>function</code>关键字</p>\n<pre><code class=\"language-js\">function fn() { }\nconsole.log(typeof fn); // function\n\nlet fn2 = function () { }\nconsole.log(typeof fn2); // function\n</code></pre>\n</li>\n<li>\n<p>使用<code>new Function()</code>，（不怎么使用）</p>\n<pre><code class=\"language-js\">let fn3 = new Function(\'a,b\', \'return a+b\')\nconsole.log(typeof fn3); // function\n</code></pre>\n</li>\n</ol>\n<p>所有的<code>function</code>都可以使用<code>new</code>关键字声明出来一个实例对象。</p>\n<p><code>function</code>实际上也是一个对象，也能在上面添加属性，比如</p>\n<pre><code class=\"language-js\">function fn() { }\nfn.a = \'aaa\'\nconsole.log(fn.a) // aaa\n</code></pre>\n<p>具体参考：</p>\n<p><a href=\"http://www.bnbiye.cn/#/articleDetail/87ecdb40-4e5b-11ec-96d5-7933aca11ca0\">http://www.bnbiye.cn/#/articleDetail/87ecdb40-4e5b-11ec-96d5-7933aca11ca0</a></p>\n<p><a href=\"https://zh.javascript.info/function-basics\">https://zh.javascript.info/function-basics</a></p>\n<h2>总结</h2>\n<p>JavaScript 中有八种基本的数据类型（译注：前七种为基本数据类型，也称为原始类型，而 <code>object</code> 为复杂数据类型，还有一个<code>function</code>，实际上也是<code>object</code>）。</p>\n<ul>\n<li><code>number</code> 用于任何类型的数字：整数或浮点数，在 <code>±(253-1)</code> 范围内的整数。</li>\n<li><code>bigint</code> 用于任意长度的整数。</li>\n<li><code>string</code> 用于字符串：一个字符串可以包含 0 个或多个字符，所以没有单独的单字符类型。</li>\n<li><code>boolean</code> 用于 <code>true</code> 和 <code>false</code>。</li>\n<li><code>null</code> 用于未知的值 —— 只有一个 <code>null</code> 值的独立类型。</li>\n<li><code>undefined</code> 用于未定义的值 —— 只有一个 <code>undefined</code> 值的独立类型。</li>\n<li><code>symbol</code> 用于唯一的标识符。</li>\n<li><code>object</code> 用于更复杂的数据结构。</li>\n<li><code>function</code> 实际上也是一个<code>object</code>，可以使用<code>new</code>关键字声明实例对象</li>\n</ul>\n<p>我们可以通过 <code>typeof</code> 运算符查看存储在变量中的数据类型。</p>\n<ul>\n<li>两种形式：<code>typeof x</code> 或者 <code>typeof(x)</code>。</li>\n<li>以字符串的形式返回类型名称，例如 <code>&quot;string&quot;</code>。</li>\n<li><code>typeof null</code> 会返回 <code>&quot;object&quot;</code> —— 这是 JavaScript 编程语言的一个错误，实际上它并不是一个 <code>object</code>。</li>\n</ul>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/types#zong-jie\">https://zh.javascript.info/types#zong-jie</a></p>\n', '2021-11-28 14:59:48', '2021-11-28 14:59:48');
INSERT INTO `t_blog` VALUES ('cb7285e0-4ae1-11ec-96d5-7933aca11ca0', 'js中的几种继承方法', '面试官说，来手写一下js的继承，你能写出来几个呢？是不是听说过很多名词，什么原型链继承、构造函数继承、组合继承、寄生组合继承、class的extends继承。本章我们来一个个的看一下到底是怎么个继承法。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 1, 5, 0, 1, 2, 1, 'http://cdn.qiniu.bnbiye.cn/img/202111212055887.png', '<h2>前言</h2>\n<p>面试官说，来手写一下js的继承，你能写出来几个呢？是不是听说过很多名词，什么原型链继承、构造函数继承、组合继承、寄生组合继承、class的extends继承。本章我们来一个个的看一下到底是怎么个继承法。</p>\n<h2>原型链继承</h2>\n<p>如下代码中，有两个构造函数<code>Parent()</code>和<code>Child()</code>，<code>Parent()</code>的原型上有个<code>sayHi()</code>方法。现在需要你手动的写一个继承，将<code>Child()</code>继承<code>Parent()</code>，使<code>Child()</code>的实例对象<code>child1</code>能通过原型链访问到<code>sayHi</code>方法。</p>\n<pre><code class=\"language-js\">function Parent() {\n    this.name = \'parent\'\n}\n\nParent.prototype.sayHi = function () {\n    console.log(`hello i am ${this.name}`);\n}\n\nfunction Child() { }\n\nlet child1 = new Child()\nchild1.sayHi() // 现在是访问不到的，因为Child与Parent没有任何关系\n// TypeError: child1.sayHi is not a function\n</code></pre>\n<h3>实现</h3>\n<p>我们手动实现一下原型链继承，将上述代码改写一下。</p>\n<pre><code class=\"language-js\">function Parent() {\n    this.name = \'parent\'\n}\n\nParent.prototype.sayHi = function () {\n    console.log(`hello i am ${this.name}`);\n}\n\nfunction Child() { }\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child // 手动的改写一下，符合原型的规则\n\nlet child1 = new Child()\nchild1.sayHi() // hello i am parent\n\nconsole.log(child1.__proto__.__proto__ === Parent.prototype); // true\n</code></pre>\n<ol>\n<li>\n<p><code>Child.prototype = new Parent()</code>，我们将<code>Child</code>的原型指向了一个<code>Parent</code>的实例对象，这是个很巧妙的方式，因为</p>\n<p><code>new Parent()</code>会产出一个<code>Parent</code>的实例对象，假如是<code>p1</code>，那么<code>p1.__proto__ === Parent.prototype</code>。这样就建立了一个关联，<code>Child.prototype.__proto__ === Parent.prototype</code>。</p>\n</li>\n<li>\n<p><code>Child.prototype.constructor = Child</code>，此处需要手动的改写一下<code>constructor </code>的指向，这是因为<code>new Parent()</code>出来的对象的<code>constructor</code>默认指向<code>Parent</code>，而构造方法默认原型上的<code>constructor </code>属性应该指向自己，所以我们手动的改写一下。</p>\n</li>\n</ol>\n<blockquote>\n<p>继承大量的涉及到原型链的概念，所以应该对js的原型链有一定的了解，不熟悉的可以先阅读一下这篇文章。<a href=\"http://www.bnbiye.cn/#/articleDetail/0bbfd760-420e-11ec-96d5-7933aca11ca0\">原型链</a></p>\n</blockquote>\n<h3>存在的问题</h3>\n<p>实现原型链继承时，发现很简单有没有，就两行代码。虽然我们继承了<code>Parent</code>的<code>name</code>属性还有原型上的<code>saiHi()</code>方法，但是是有问题的。</p>\n<ol>\n<li>\n<p>创建的<code>Child</code>实例时没有办法传参。</p>\n<p>很明显，没有地方传参，比如<code>let c2 = new Child(1,2)</code>，传了也没有地方接收。</p>\n</li>\n<li>\n<p>如果<code>Parent</code>属性有引用类型，一旦某个实例修改了当前的值，那么父亲所有的值也会被跟着修改，比如：</p>\n<pre><code class=\"language-js\">function Parent() {\n    this.name = \'parent\'\n    this.action = [\'eat\', \'sleep\']\n}\n\nParent.prototype.sayHi = function () {\n    console.log(`hello i am ${this.name}`);\n}\n\nfunction Child() { }\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n\nlet c1 = new Child()\nc1.sayHi() // hello i am parent\n\nlet c2 = new Child()\nc2.action.pop()\nconsole.log(c2.action); // [ \'eat\' ] 我们只是修改了c2的action，但是发现c1的action也被修改了\nconsole.log(c1.action); // [ \'eat\' ]\n</code></pre>\n<p>可以看一下内存图理解一下，</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111212055887.png\" alt=\"内存图\" /></p>\n<ol>\n<li>\n<p>声明的<code>c1、c2</code>两个变量，指向了<code>Child</code>的两个实例对象（因为是使用<code>new</code>声明的，所以会生成两个新的对象）</p>\n</li>\n<li>\n<p><code>c1.sayHi()</code>为什么可以找到呢，如图所示，先在自己身上找（图中的<code>Oxaab</code>），自己没有，再向上一层原型上找（图中的<code>Oxbbb</code>），也没有找到，继续向上找（图中的<code>Ox456</code>），bingo，找到了（图中的<code>Ox789</code>），确实是一个<code>function</code>，输出<code>hello i am [this.name]</code>，那么这个<code>this.name</code>是谁呢，因为使用的是<code>c1.sayHi()</code>调用的方法，所以此时的<code>this</code>就是<code>c1</code>，所以我们开始找这个<code>name</code>，仍然是这一套，先找自己（<code>Oxaab</code>）没有，往上找（图中的<code>Oxbbb</code>），没有，继续向上找（图中的<code>Ox456</code>），bingo，找到了，<code>Ox456</code>虽然没有，但是<code>Oxaaa</code>上有。（其实先找的<code>Oxaaa</code>再找<code>Ox456</code>，即先找构造函数再找原型。）</p>\n<blockquote>\n<p>🚩注意，假如<code>let o1= new Parent()</code>，那么<code>o1.__proto__ === Parent.prototype</code>，<code>Parent.prototype.constructor === Parent</code>，这都是原型链的知识，（其实<code>o1.constructor === Parent</code>，这是<code>new</code>的知识）。当实例对象<code>o1</code>找某个属性或者方法时，如果自己没有，就会沿着<code>__proto__</code>向上找，也就是构造函数的原型<code>prototype</code>，找的时候其实有个优先级，<code>constructor &gt; prototype</code>。</p>\n<p>假如拿上面的例子举例，改写一下，<code>Parent.prototype.name = \'hhh\'</code>，在构造函数<code>Parent</code>原型上也加一个<code>name</code>属性，你会发现最后打印的时候还是<code>hello i am parent</code>，并没有输出这个<code>hhh</code>。</p>\n</blockquote>\n</li>\n<li>\n<p><code>c2.action.pop()</code>，顺着原型链在图中的<code>Ox123</code>上找到了，是一个引用类型，所以调用<code>pop()</code>后就把这个值更改了，而<code>c1.action</code>也是指向这块内存空间<code>Ox123</code>，所以原型链继承方式就导致了这个毛病，一旦一个实例对象修改了原型链上某个引用类型的值，所有的都会受到影响。</p>\n</li>\n</ol>\n<p>那么，我们怎样消除这两个问题呢，接下来，让我们来看一下构造函数继承。</p>\n</li>\n</ol>\n<h2>构造函数继承</h2>\n<p>原型链继承不能传参，且一个实例对象修改原型链上某个引用类型的值后，所有对象的值都受影响。为了解决这个问题，思考一下，我们把<code>Parent</code>构造函数中的属性全部再复制一份到<code>Child</code>上不就行了嘛。</p>\n<h3>实现</h3>\n<pre><code class=\"language-js\">function Parent(name, action) {\n    this.name = name\n    this.action = action\n}\n\nParent.prototype.sayHi = function () {\n    console.log(`hello i am ${this.name}，i can ${this.action}`);\n}\n\nfunction Child(id, name, action) {\n    Parent.call(this, name, action)\n    this.id = id\n}\n\nlet c1 = new Child(1, \'aa\', [\'eat\'])\nlet c2 = new Child(2, \'bb\', [\'eat\', \'sleep\'])\n\nconsole.log(c1); // Child { name: \'aa\', action: [ \'eat\' ], id: 1 }\nconsole.log(c2); // Child { name: \'bb\', action: [ \'eat\', \'sleep\' ], id: 2 }\n\nc1.sayHi() // c1.sayHi is not a function\n</code></pre>\n<p>其实也挺简单，在<code>Child()</code>构造函数上，使用<code>call</code>显示的调用一下<code>Parent</code>，<code> Parent.call(this, name, action)</code>，这样就相当于把父构造函数的属性都拷贝了一份到自己身上，然后如果自己想传新的参数，也可以在自己构造函数上添加，比如例子中的<code>this.id = id</code>。</p>\n<p>但是这种方式也有问题。</p>\n<h3>存在的问题</h3>\n<ol>\n<li>\n<p>虽然将父构造函数的属性都拷贝了一份到自己身上，也能自己传参，但是父构造函数原型上的属性或方法就取不到了。</p>\n</li>\n<li>\n<p>如果想要继承方法，只能将方法都写到父构造函数上面，比如</p>\n<pre><code class=\"language-js\">function Parent(name, action) {\n    this.name = name\n    this.action = action\n    // 方法声明在构造函数上\n    this.sayHi = function () {\n        console.log(`hello i am ${this.name}，i can ${this.action}`);\n    }\n}\n\nfunction Child(id, name, action) {\n    Parent.call(this, name, action)\n    this.id = id\n}\n\nlet c1 = new Child(1, \'aa\', [\'eat\'])\nlet c2 = new Child(2, \'bb\', [\'eat\', \'sleep\'])\n\nconsole.log(c1); // Child { name: \'aa\', action: [ \'eat\' ], sayHi: [Function (anonymous)], id: 1 }\nconsole.log(c2); // Child { name: \'bb\', action: [ \'eat\', \'sleep\' ], sayHi: [Function (anonymous)], id: 2 }\n\nc1.sayHi() // hello i am aa，i can eat\nc2.sayHi() // hello i am bb，i can eat,sleep\n</code></pre>\n<p>但是这样就导致了，每次声明一个新实例对象时，父构造函数中的方法都会被新建一份，非常浪费内存空间。</p>\n</li>\n</ol>\n<p>我们发现，上面这两种继承方法，各有各的优缺点，但是有意思的是，它俩的缺点都是对方的优点，那我们是不是把这两种方式可以综合一下呢？</p>\n<h2>组合继承</h2>\n<p>组合继承就是结合了原型链继承与构造函数继承而出现的一种新的继承方式，我们来看一下。</p>\n<h3>实现</h3>\n<pre><code class=\"language-js\">function Parent(name, action) {\n    this.name = name\n    this.action = action\n}\n\nParent.prototype.sayHi = function () {\n    console.log(`hello i am ${this.name}，i can ${this.action}`);\n}\n\nfunction Child(id, name, action) {\n    Parent.call(this, name, action)\n    this.id = id\n}\n\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n\nlet c1 = new Child(1, \'aa\', [\'eat\'])\nlet c2 = new Child(2, \'bb\', [\'eat\', \'sleep\'])\n\nconsole.log(c1); // Child { name: \'aa\', action: [ \'eat\' ], id: 1 }\nconsole.log(c2); // Child { name: \'bb\', action: [ \'eat\', \'sleep\' ], id: 2 }\n\nc1.sayHi() // hello i am aa，i can eat\nc2.sayHi() // hello i am bb，i can eat,sleep\n</code></pre>\n<p>组合继承结合了二者的优点，既可以传参，又可以继承原型上的属性和方法，但是还是有一个问题。</p>\n<h3>存在的问题</h3>\n<p>如果仔细观察，你会发现组合继承种的<code>Parent</code>构造方法被调用了两次。</p>\n<ol>\n<li>第一次：<code>Parent.call(this, name, action)</code></li>\n<li>第二次：<code>new Parent()</code></li>\n</ol>\n<p>那我们怎么在优化优化呢？于是，寄生组合式继承就出现了。</p>\n<h2>寄生组合式继承</h2>\n<p>在组合继承中，<code>Parent</code>构造方法被调用了两次，其实我们可以在继承原型链的操作上做一个优化，可以使用一个临时空构造函数做个中间的桥梁。</p>\n<h3>实现</h3>\n<pre><code class=\"language-js\">function Parent(name, action) {\n    this.name = name\n    this.action = action\n}\n\nParent.prototype.sayHi = function () {\n    console.log(`hello i am ${this.name}，i can ${this.action}`);\n}\n\nfunction Child(id, name, action) {\n    Parent.call(this, name, action)\n    this.id = id\n}\n\n// 中间的桥梁，临时空构造函数\nlet TempFn = function () { }\nTempFn.prototype = Parent.prototype\nChild.prototype = new TempFn()\nChild.prototype.constructor = Child\n\nlet c1 = new Child(1, \'aa\', [\'eat\'])\nlet c2 = new Child(2, \'bb\', [\'eat\', \'sleep\'])\n\nconsole.log(c1); // Child { name: \'aa\', action: [ \'eat\' ], id: 1 }\nconsole.log(c2); // Child { name: \'bb\', action: [ \'eat\', \'sleep\' ], id: 2 }\n\nc1.sayHi() // hello i am aa，i can eat\nc2.sayHi() // hello i am bb，i can eat,sleep\n\nconsole.log(Child.prototype.__proto__ === Parent.prototype); // true\n</code></pre>\n<p>我们用一个空的构造函数<code>TempFn</code>，将它的原型指向<code>Parent</code>的原型，然后<code>Child</code>的指向改为<code>new TempFn()</code>，这样的话，依然可以顺着原型链找到<code>Parent.prototype</code>。这就是所谓的寄生组合式继承，把原型链的继承寄生到一个临时的函数上。</p>\n<p>是不是有个小疑问呢？</p>\n<h3>一个小疑问</h3>\n<blockquote>\n<p>为什么一定要通过这个临时的桥梁实现继承，直接<code>Child.prototype = Parent.prototype</code>不行吗？是不是有点多此一举呢？</p>\n</blockquote>\n<p>其实不是的，这样做是很有必要的。</p>\n<p>我们知道<code>Parent.prototype</code>是一个对象，实际就是一个引用，如果直接将<code>Child.prototype</code>指向这个引用，那么假如我们在<code>Child.prototype</code>上新添加属性或方法时，会直接影响到<code>Parent.prototype</code>。</p>\n<p>而使用一个临时构造函数做一个缓冲，就是使用了<code>new</code>关键字的特性，<code>new</code>会生成一个新的对象，新对象的<code>__proto__</code>执行指向了<code>TempFn.prototype</code>，而我们已经将临时构造函数<code>TempFn.prototype</code>指向<code>Parent.protorype</code>，所以<code>Child.prototype = new TempFn()</code>就变相的与<code>Parent</code>的原型关联上了，即<code>Child.prototype.__proto__ === Parent.protorype</code>，这样即能继承原型上的属性和方法，又不用指向同一块引用上，还不用调用两次<code>Parent</code>，一举三得。</p>\n<h2>class的extends继承</h2>\n<p>最后介绍一个ES6的继承方式<code>extends</code>，也是现在最好用的，非常符合我们的编码方式。</p>\n<pre><code class=\"language-js\">class Parent {\n    constructor(name, action) {\n        this.name = name\n        this.action = action\n    }\n\n    sayHi() {\n        console.log(`hello i am ${this.name}，i can ${this.action}`);\n    }\n}\n\nclass Child extends Parent {\n    constructor(id, name, action) {\n        super(name, action)\n        this.id = id\n    }\n}\n\nlet c1 = new Child(1, \'aa\', [\'eat\'])\nlet c2 = new Child(2, \'bb\', [\'eat\', \'sleep\'])\n\nconsole.log(c1); // Child { name: \'aa\', action: [ \'eat\' ], id: 1 }\nconsole.log(c2); // Child { name: \'bb\', action: [ \'eat\', \'sleep\' ], id: 2 }\n\nc1.sayHi() // hello i am aa，i can eat\nc2.sayHi() // hello i am bb，i can eat,sleep\n\nconsole.log(Child.prototype.__proto__ === Parent.prototype); // true\n</code></pre>\n<p>其实ES6的class和extends就是一个语法糖，最后转换后还是寄生组合式继承的代码。</p>\n<h2>总结</h2>\n<ol>\n<li>\n<p>原型链继承，</p>\n<pre><code class=\"language-js\">Child.prototype = new Parent()\nChild.prototype.constructor = Child\n// 继承了Parent的所有，本身的属性方法以及原型上的属性和方法。\n</code></pre>\n<p>但是存在两个问题：</p>\n<ul>\n<li>没办法传参</li>\n<li>如果<code>Parent</code>上有引用类型的属性，一旦某个实例对象修改了这个值，所有的值都跟着变。</li>\n</ul>\n</li>\n<li>\n<p>构造函数继承，<code>Parent.call(this, arg1, arg2, ...)</code>，<code>this.arg = arg</code></p>\n<pre><code class=\"language-js\">function Child(id, name, action) {\n    Parent.call(this, name, action)\n    this.id = id\n}\n// 继承了Parent构造函数上所有的属性和方法，也能够传参。\n</code></pre>\n<p>但是也存在两个问题：</p>\n<ul>\n<li>没有继承原型。</li>\n<li>要想继承方法，只能写在构造方法上，导致了每次声明一次实例对象，就会创建一遍，浪费内存空间。</li>\n</ul>\n</li>\n<li>\n<p>组合继承，结合原型链继承和构造函数继承</p>\n<p><code>Parent.call(this, arg1, arg2, ...)</code>，<code>this.arg = arg</code></p>\n<p><code>Child.prototype = new Parent()</code>，<code>Child.prototype.constructor = Child</code></p>\n<pre><code class=\"language-js\">function Child(id, name, action) {\n    Parent.call(this, name, action)\n    this.id = id\n}\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n</code></pre>\n<p><code>1，2</code>中所有的存在的问题都得到了解决，并且结合了二者的优点。</p>\n<p>但是仍存在一个问题：<code>Parent</code>构造方法调用了两次</p>\n<ul>\n<li>第一次：<code>Parent.call(this, arg1, arg2, ...)</code></li>\n<li>第二次：<code>Child.prototype = new Parent()</code></li>\n</ul>\n</li>\n<li>\n<p>寄生组合式继承，优化了组合继承，使用一个临时的空构造函数做一个桥梁</p>\n<pre><code class=\"language-js\">let TempFn = function () { }\nTempFn.prototype = Parent.prototype\nChild.prototype = new TempFn()\nChild.prototype.constructor = Child\n</code></pre>\n</li>\n<li>\n<p>ES6的<code>extends</code>继承</p>\n</li>\n</ol>\n', '2021-11-21 23:43:38', '2021-11-21 23:43:38');
INSERT INTO `t_blog` VALUES ('d036a7a0-606c-11ec-b395-6d1b1a7579ec', '把二叉树打印成多行', 'JZ78 把二叉树打印成多行', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 1, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112190937533.png\" alt=\"image-20211219093714381\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112190937320.png\" alt=\"image-20211219093759270\" /></p>\n<h2>代码</h2>\n<h3>代码1 层次遍历，一行一行的输出结果</h3>\n<pre><code class=\"language-js\">/*\n层次遍历，按行打印输出结果\n使用一个队列辅助\n使用一个临时数组用来存储本行的值\n*/\nfunction Print(pRoot)\n{\n    if(!pRoot) return []\n    \n    let q = [] // 使用数组模拟队列\n    q.push(pRoot) // 入队\n    \n    let result = [] // 最终返回的结果\n    \n    // 开始层次遍历\n    while(q.length &gt; 0){ // 遍历本行节点\n        \n        let size = q.length // 本行一共有多少个节点\n        \n        let tempArr = [] // 用来存储本行节点的val，好存储到最终结果数组里\n        \n        // 开始遍历本行节点，同时把下一行节点重新入队\n        while(size &gt; 0){\n            \n            let current = q.shift() // 使用shift模拟出队\n            \n            // 将下一层节点重新入队\n            if(current.left){\n                q.push(current.left)\n            }\n            if(current.right){\n                q.push(current.right)\n            }\n            \n            tempArr.push(current.val) // 临时数组用来存储本行的节点的val\n            \n            size--\n        }\n        \n        // 内层的while每次都是一行一行的来遍历，本行的结果都存储在了临时数组tempArr中\n        // 将本行遍历的结果push到最终的结果数组中\n        result.push(tempArr)\n        \n    }\n    \n    return result \n}\n</code></pre>\n<p>时间复杂度O(n)：遍历的节点个数有n个</p>\n<p>空间复杂度O(n)</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/445c44d982d04483b04a54f298796288?tpId=13&amp;tqId=23453&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\">JZ78 把二叉树打印成多行</a></p>\n', '2021-12-19 09:41:40', '2021-12-19 09:41:40');
INSERT INTO `t_blog` VALUES ('d12707e0-3d8a-11ec-97a5-ef78eceb5d73', '使用JavaScript添加交互', 'JavaScript 允许我们修改网页的方方面面: 内容、样式以及它如何响应用户交互。 不过，JavaScript 也会阻止 DOM 构建和延缓网页渲染。 为了实现最佳性能，可以让您的 JavaScript 异步执行，并去除关键渲染路径中任何不必要的 JavaScript。', '-1', 2, 'https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 9, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>JavaScript 允许我们修改网页的方方面面: 内容、样式以及它如何响应用户交互。 不过，JavaScript 也会阻止 DOM 构建和延缓网页渲染。 为了实现最佳性能，可以让您的 JavaScript 异步执行，并去除关键渲染路径中任何不必要的 JavaScript。</p>\n<h2>分析</h2>\n<ul>\n<li>JavaScript 可以查询和修改 DOM 与 CSSOM。</li>\n<li>JavaScript 执行会阻止 CSSOM。</li>\n<li>除非将 JavaScript 显式声明为异步，否则它会阻止构建 DOM。</li>\n</ul>\n<p>JavaScript 是一种运行在浏览器中的动态语言，它允许我们对网页行为的几乎每一个方面进行修改: 我们可以通过在 DOM 树中添加和移除元素来修改内容；我们可以修改每个元素的 CSSOM 属性；我们可以处理用户输入，等等。为进行说明，让我们用一个简单的内联脚本对之前的“Hello World”示例进行扩展:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;title&gt;Critical Path: Script&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script&gt;\n      var span = document.getElementsByTagName(\'span\')[0];\n      span.textContent = \'interactive\'; // change DOM text content\n      span.style.display = \'inline\';  // change CSSOM property\n      // create a new element, style it, and append it to the DOM\n      var loadTime = document.createElement(\'div\');\n      loadTime.textContent = \'You loaded this page on: \' + new Date();\n      loadTime.style.color = \'blue\';\n      document.body.appendChild(loadTime);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<ul>\n<li>JavaScript 允许我们进入 DOM 并拉取对隐藏的 span 节点的引用 - 该节点可能未出现在渲染树中，却仍然存在于 DOM 内。然后，在我们获得引用后，就可以更改其文本（通过 .textContent），甚至可以将其计算的 display 样式属性从“none”替换为“inline”。现在，我们的页面显示“<strong>Hello interactive students!</strong> ”。</li>\n<li>JavaScript 还允许我们在 DOM 中创建、样式化、追加和移除新元素。从技术上讲，我们的整个页面可以是一个大的 JavaScript 文件，此文件能够逐一创建元素并对其进行样式化。尽管这种方法可行，但是在实践中，使用 HTML 和 CSS 要简单得多。在 JavaScript 函数的第二部分，我们会创建一个新的 div 元素，设置其文本内容，对其进行样式化，然后将其追加到正文中。</li>\n</ul>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111041801433.png\" alt=\"image-20211104180138356\" /></p>\n<p>我们通过以上示例修改了现有 DOM 节点的内容和 CSS 样式，并为文档添加了一个全新的节点。我们的网页不会赢得任何设计奖，但它说明了 JavaScript 赋予我们的能力和灵活性。</p>\n<p>不过，尽管 JavaScript 为我们带来了许多功能，不过也在页面渲染方式和时间方面施加了更多限制。</p>\n<p>首先，请注意上例中的内联脚本靠近网页底部。为什么呢？您真应该亲自尝试一下。如果我们将脚本移至 <em>span</em> 元素之上，您就会注意到脚本运行失败，并提示在文档中找不到对任何 <em>span</em> 元素的引用 - 即 <em>getElementsByTagName(‘span\')</em> 会返回 <em>null</em> 。这透露出一个重要事实: 我们的脚本在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JavaScript 引擎；等 JavaScript 引擎运行完毕，浏览器会从中断的地方恢复 DOM 构建。</p>\n<p>换言之，我们的脚本块找不到网页中任何靠后的元素，因为它们尚未接受处理！或者，稍微换个说法: <strong>执行我们的内联脚本会阻止 DOM 构建，也就延缓了首次渲染。</strong></p>\n<p>在网页中引入脚本的另一个微妙事实是，它们不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性。实际上，我们在示例中就是这么做的: 将 span 元素的 display 属性从 none 更改为 inline。最终结果如何？我们现在遇到了竞态问题。</p>\n<p>如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，会怎样？答案很简单，对性能不利: <strong>浏览器将延迟脚本执行和 DOM 构建，直至其完成 CSSOM 的下载和构建。</strong></p>\n<p>简言之，JavaScript 在 DOM、CSSOM 和 JavaScript 执行之间引入了大量新的依赖关系，从而可能导致浏览器在处理以及在屏幕上渲染网页时出现大幅延迟:</p>\n<ul>\n<li>脚本在文档中的位置很重要。</li>\n<li>当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。</li>\n<li>JavaScript 可以查询和修改 DOM 与 CSSOM。</li>\n<li>JavaScript 执行将暂停，直至 CSSOM 就绪。</li>\n</ul>\n<p>“优化关键渲染路径”在很大程度上是指了解和优化 HTML、CSS 和 JavaScript 之间的依赖关系谱。</p>\n<h2>解析器阻止与异步 JavaScript</h2>\n<p>默认情况下，JavaScript 执行会“阻止解析器”: 当浏览器遇到文档中的脚本时，它必须暂停 DOM 构建，将控制权移交给 JavaScript 运行时，让脚本执行完毕，然后再继续构建 DOM。我们在前面的示例中已经见过内联脚本的实用情况。实际上，内联脚本始终会阻止解析器，除非您编写额外代码来推迟它们的执行。</p>\n<p>通过 script 标签引入的脚本又怎样？让我们还用前面的例子，将代码提取到一个单独文件中:</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;title&gt;Critical Path: Script External&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p><strong>app.js</strong></p>\n<pre><code class=\"language-js\">var span = document.getElementsByTagName(\'span\')[0];\nspan.textContent = \'interactive\'; // change DOM text content\nspan.style.display = \'inline\';  // change CSSOM property\n// create a new element, style it, and append it to the DOM\nvar loadTime = document.createElement(\'div\');\nloadTime.textContent = \'You loaded this page on: \' + new Date();\nloadTime.style.color = \'blue\';\ndocument.body.appendChild(loadTime);\n</code></pre>\n<p>无论我们使用   标记还是内联 JavaScript 代码段，您都可以期待两者能够以相同方式工作。 在两种情况下，浏览器都会先暂停并执行脚本，然后才会处理剩余文档。不过，<strong>如果是外部 JavaScript 文件，浏览器必须停下来，等待从磁盘、缓存或远程服务器获取脚本，这就可能给关键渲染路径增加数十至数千毫秒的延迟。</strong></p>\n<p>默认情况下，所有 JavaScript 都会阻止解析器。由于浏览器不了解脚本计划在页面上执行什么操作，它会作最坏的假设并阻止解析器。向浏览器传递脚本不需要在引用位置执行的信号既可以让浏览器继续构建 DOM，也能够让脚本在就绪后执行；例如，在从缓存或远程服务器获取文件后执行。</p>\n<p>为此，我们可以将脚本标记为<em>异步</em> :</p>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;\n    &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&gt;\n    &lt;title&gt;Critical Path: Script Async&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;\n    &lt;div&gt;&lt;img src=&quot;awesome-photo.jpg&quot;&gt;&lt;/div&gt;\n    &lt;script src=&quot;app.js&quot; async&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>向 script 标记添加异步关键字可以指示浏览器在等待脚本可用期间不阻止 DOM 构建，这样可以显著提升性能。</p>\n<p>除了async关键字，还有defer关键字，也能异步加载js脚本，但是二者有点区别</p>\n<p>defer是等待DOM树解析完了才执行，async是加载完了之后立刻执行。</p>\n<p>下一篇：<a href=\"http://www.bnbiye.cn/#/articleDetail/1d47dc80-3d8b-11ec-97a5-ef78eceb5d73\">评估关键渲染路径的几种方法</a></p>\n', '2021-11-05 00:18:16', '2021-11-05 09:02:12');
INSERT INTO `t_blog` VALUES ('d210f890-573a-11ec-96d5-7933aca11ca0', '模式中的反向引用：`\\N` 和 `\\k<name>`', '我们不仅可以在结果或替换字符串中使用捕获组 `(...)` 的内容，还可以在模式本身中使用它们。', '-1', 2, 'https://zh.javascript.info/regexp-backreferences', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 2, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>我们不仅可以在结果或替换字符串中使用捕获组 <code>(...)</code> 的内容，还可以在模式本身中使用它们。</p>\n<h2>按捕获组的编号，反向引用<code>\\n</code></h2>\n<p>可以使用 <code>\\N</code> 在模式中引用一个组，其中 <code>N</code> 是组号。</p>\n<p>为了弄清那为什么有帮助，让我们考虑一项任务。</p>\n<p>我们需要找到带引号的字符串：单引号 <code>\'...\'</code> 或双引号 <code>&quot;...&quot;</code>– 应匹配两种变体。</p>\n<p>如何找到它们？</p>\n<p>我们可以将两种引号放在方括号中：<code>[\'&quot;](.*?)[\'&quot;]</code>，但它会找到带有混合引号的字符串，例如 <code>&quot;...\'</code> 和 <code>\'...&quot;</code>。当一种引号出现在另一种引号内，比如在字符串 <code>&quot;She\'s the one!&quot;</code> 中时，便会导致不正确的匹配：</p>\n<pre><code class=\"language-js\">let str = `He said: &quot;She\'s the one!&quot;.`;\n\nlet regexp = /[\'&quot;](.*?)[\'&quot;]/g;\n\n// 不是我们想要的结果\nconsole.log(str.match(regexp)); // [ `&quot;She\'` ]\n</code></pre>\n<p>如我们所见，该模式找到了一个开头的引号 <code>&quot;</code>，然后文本被匹配，直到另一个引号 <code>\'</code>，该匹配结束。</p>\n<p>为了确保模式查找的结束引号与开始的引号完全相同，我们可以将其包装到捕获组中并对其进行反向引用：<code>([\'&quot;])(.*?)\\1</code>。</p>\n<p>这是正确的代码：</p>\n<pre><code class=\"language-js\">let str = `He said: &quot;She\'s the one!&quot;.`;\n\nlet regexp = /([\'&quot;])(.*?)\\1/g;\n\nconsole.log(str.match(regexp)); // [ `&quot;She\'s the one!&quot;` ]\n</code></pre>\n<p>现在可以了！正则表达式引擎会找到第一个引号 <code>([\'&quot;])</code> 并记住其内容。那是第一个捕获组。</p>\n<p><code>\\1</code> 在模式中进一步的含义是“查找与第一（捕获）分组相同的文本”，在我们的示例中为完全相同的引号。</p>\n<p>与此类似，<code>\\2</code> 表示第二（捕获）分组的内容，<code>\\3</code> – 第三分组，依此类推。</p>\n<blockquote>\n<p><strong>请注意：</strong></p>\n<p>如果我们在组中使用 <code>?:</code>，那么我们将无法引用它。用 <code>(?:...)</code> 捕获的组被排除，引擎不会存储。</p>\n</blockquote>\n<blockquote>\n<p><strong>不要搞混了： 在模式中用 <code>\\1</code>，在替换项中用：<code>$1</code></strong></p>\n<p>在替换字符串中我们使用美元符号：<code>$1</code>，而在模式中 – 使用反斜杠 <code>\\1</code>。</p>\n</blockquote>\n<h2>按捕获组的命名，反向引用<code>\\k&lt;name&gt;</code></h2>\n<p>如果正则表达式中有很多括号对（注：捕获组），给它们起个名字方便引用。</p>\n<p>要引用命名组，我们可以使用：<code>\\k&lt;name&gt;</code>。</p>\n<p>在下面的示例中引号组命名为 <code>?&lt;quote&gt;</code>，因此反向引用为 <code>\\k&lt;quote&gt;</code>：</p>\n<pre><code class=\"language-js\">let str = `He said: &quot;She\'s the one!&quot;.`;\n\nlet regexp = /(?&lt;quote&gt;[\'&quot;])(.*?)\\k&lt;quote&gt;/g;\n\nconsole.log(str.match(regexp)); // [ `&quot;She\'s the one!&quot;` ]\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>\n<p>通过捕获组编号复用正则<code>\\1</code>、<code>\\2</code>等等：</p>\n<p>正则表达式的捕获组都是有编号的，引擎会记住本次匹配中每个捕获组匹配的结果，我们可以在正则里复用捕获组的模式，使用<code>\\n</code>的方式，比如：<code>/(a)(b)\\1\\2/g</code>，<code>\\1</code>匹配的结果就会与第一组捕获组中匹配的结果一致，<code>\\2</code>就会与第二组捕获组匹配的结果一致，这样就相当于复用了规则，不用重写一遍。</p>\n<pre><code class=\"language-js\">let str = \'abab\'\nconsole.log(str.match(/(a)(b)\\1\\2/g)); // [ \'abab\' ]\n</code></pre>\n</li>\n<li>\n<p>通过捕获组别名复用正则<code>\\k&lt;quote&gt;</code>：</p>\n<p>如果捕获组嵌套的层级较深时，不好看出来是第几个捕获组，所以可以通过别名的方式复用，比如：<code>/(?&lt;a&gt;a)(?&lt;b&gt;b)\\k&lt;a&gt;\\k&lt;b&gt;/g</code></p>\n<pre><code class=\"language-js\">let str = \'abab\'\nconsole.log(str.match(/(?&lt;a&gt;a)(?&lt;b&gt;b)\\k&lt;a&gt;\\k&lt;b&gt;/g)); // [ \'abab\' ]\n</code></pre>\n</li>\n<li>\n<p>被排除的捕获组不能复用，因为已经其匹配的结果引擎不再会存储了。<code>(?:xxx)</code></p>\n<pre><code class=\"language-js\">let str = \'abab\'\nlet str2 = \'abb2\'\nconsole.log(str.match(/(?:a)(b)\\1\\2/g)); // null\nconsole.log(str2.match(/(?:a)(b)\\1/g)); // [ \'abb\' ]  只有一个捕获组了\n</code></pre>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-backreferences\">https://zh.javascript.info/regexp-backreferences</a></p>\n', '2021-12-07 16:51:08', '2021-12-07 16:51:08');
INSERT INTO `t_blog` VALUES ('d3704000-63a7-11ec-ac62-9b20ec8e21d3', '111', '111', '-1', 1, '', 'ed61f0f0-2cbe-11ec-86ae-0da8227970f6', -1, 2, 0, 1, 1, 1, '', '<p>111</p>\n', '2021-12-23 12:21:39', '2021-12-23 12:21:52');
INSERT INTO `t_blog` VALUES ('d40c4520-5d55-11ec-96d5-7933aca11ca0', '两个链表的第一个公共节点', 'JZ52 两个链表的第一个公共结点', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 2, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p>\n<p>数据范围： <code>n≤1000</code><br />\n要求：空间复杂度 O(1)，时间复杂度 O(n)</p>\n<p>例如，输入{1,2,3},{4,5},{6,7}时，两个无环的单向链表的结构如下图所示：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112151110602.png\" alt=\"image-20211215111021536\" /></p>\n<p>可以看到它们的第一个公共结点的结点值为6，所以返回结点值为6的结点。</p>\n<h3>输入描述：</h3>\n<p>输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。</p>\n<h3>返回值描述：</h3>\n<p>返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。</p>\n<h2>示例</h2>\n<p>示例1</p>\n<pre><code class=\"language-js\">输入：{1,2,3},{4,5},{6,7}\n返回值：{6,7}\n说明：第一个参数{1,2,3}代表是第一个链表非公共部分，第二个参数{4,5}代表是第二个链表非公共部分，最后的{6,7}表示的是2个链表的公共部分这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的\n</code></pre>\n<p>示例2</p>\n<pre><code class=\"language-js\">输入：{1},{2,3},{}\n返回值：{}\n说明：2个链表没有公共节点 ,返回null，后台打印{}\n</code></pre>\n<h2>代码</h2>\n<h3>代码1 使用双指针法</h3>\n<h4>题解</h4>\n<p>解析参考<a href=\"https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=23257&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\">牛客网官方题解</a></p>\n<p>假如例子如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112151114160.png\" alt=\"image-20211215111408110\" /></p>\n<p>显然第一个公共结点为<code>8</code>，但是链表<code>A</code>头结点到<code>8</code>的长度为<code>2</code>，链表<code>B</code>头结点到<code>8</code>的长度为<code>3</code>，显然不好办？<br />\n如果我们能够制造一种理想情况，如下：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112151114333.png\" alt=\"image-20211215111445288\" /></p>\n<p>这里先假设链表<code>A</code>头结点与结点<code>8</code>的长度 与 链表<code>B</code>头结点与结点<code>8</code>的长度相等，那么就可以用双指针。</p>\n<ol>\n<li>初始化：指针<code>ta</code>指向链表<code>A</code>头结点，指针<code>tb</code>指向链表<code>B</code>头结点</li>\n<li>如果<code>ta == tb</code>， 说明找到了第一个公共的头结点，直接返回即可。</li>\n<li>否则，<code>ta != tb</code>，则<code>++ta，++tb</code></li>\n</ol>\n<p>所以现在的问题就变成，如何让本来长度不相等的变为相等的？<br />\n假设链表<code>A</code>长度为<code>a</code>， 链表<code>B</code>的长度为<code>b</code>，此时<code>a != b</code><br />\n但是，<code>a+b == b+a</code><br />\n因此，可以让a+b作为链表A的新长度，b+a作为链表B的新长度。<br />\n如图：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112151115245.png\" alt=\"image-20211215111521196\" /></p>\n<p>这样，长度就一致了，可以用上述的双指针解法了。</p>\n<h4>代码</h4>\n<pre><code class=\"language-js\">function FindFirstCommonNode(pHead1, pHead2){\n    // 使用两个指针，分别指向两个链表的头结点\n    let p1 = pHead1\n    let p2 = pHead2\n    \n    // 只有当两条链表都为null时，或者相等时会终止循环\n    while(p1!==p2){\n        p1 = p1 === null ? pHead2 : p1.next // 当第一个指针指到头了，就在后面追加另外一条链表 pHead2\n        p2 = p2 === null ? pHead1 : p2.next // 当第二个指针到头了，就在后面追加另外一条链表 pHead1\n    }\n    \n    // 所以最终结果要么返回null，要么就是公共的节点\n    return p1\n}\n</code></pre>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46?tpId=13&amp;tqId=23257&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking\">JZ52 两个链表的第一个公共结点</a></p>\n', '2021-12-15 11:19:35', '2021-12-15 11:19:35');
INSERT INTO `t_blog` VALUES ('d427ae30-5677-11ec-96d5-7933aca11ca0', '贪婪量词和惰性量词', '量词，看上去十分简单，但实际上它可能会很棘手。因为会有贪婪匹配和懒惰匹配两种搜索方式，默认是贪婪匹配，有时候一不小心就会匹配错。', '-1', 2, 'https://zh.javascript.info/regexp-greedy-and-lazy#lan-duo-mo-shi', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 3, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>量词，看上去十分简单，但实际上它可能会很棘手。</p>\n<p>如果我们打算寻找比 <code>/\\d+/</code> 更加复杂的东西，就需要理解搜索工作是如何进行的。</p>\n<p>以接下来的问题为例。</p>\n<p>有一个文本，我们需要用书名号：<code>«...»</code> 来代替所有的引号 <code>&quot;...&quot;</code>。在许多国家，它们是排版的首选。</p>\n<p>例如：<code>&quot;Hello, world&quot;</code> 将会变成 <code>«Hello, world»</code>。</p>\n<p>一些国家偏爱 <code>„Witam, świat!”</code>（波兰语）甚至 <code>「你好，世界」</code>（汉语）引号。对于不同的语言环境，我们可以选择不同的替代方式，但它们都是一样的，那我们就以书名号 <code>«...»</code> 开始。</p>\n<p>为了进行替换，我们首先要找出所有被引号围起来的子串。</p>\n<p>正则表达式看上去可能是这样的：<code>/&quot;.+&quot;/g</code>。这个表达式的意思是：我们要查找这样一个句子，一个引号后跟一个或多个字符，然后以另一个引号结尾。</p>\n<p>…但如果我们试着在一个如此简单的例子中去应用它…</p>\n<pre><code class=\"language-js\">let reg = /&quot;.+&quot;/g;\n\nlet str = \'a &quot;witch&quot; and her &quot;broom&quot; is one\';\n// 并没有达到期望的结果\nconsole.log(str.match(reg)); // [ \'&quot;witch&quot; and her &quot;broom&quot;\' ]\n</code></pre>\n<p>…我们会发现它的运行结果与预期不同！</p>\n<p>它直接找到了一个匹配结果：<code>&quot;witch&quot; and her &quot;broom&quot;</code>，而不是找到两个匹配结果 <code>&quot;witch&quot;</code> 和 <code>&quot;broom&quot;</code>。</p>\n<p>这可被称为“贪婪是万恶之源”。</p>\n<h2>贪婪搜索</h2>\n<p>为了查找到一个匹配项，正则表达式引擎采用了以下算法：</p>\n<ul>\n<li>对于字符串中的每一个字符\n<ul>\n<li>用这个模式来匹配此字符。</li>\n<li>若无匹配，移至下一个字符</li>\n</ul>\n</li>\n</ul>\n<p>这些简单的词语没有说清楚为什么这个正则表达式匹配失败了，因此，让我们详细说明一下模式 <code>&quot;.+&quot;</code> 是如何进行搜索工作的。</p>\n<ol>\n<li>\n<p>该模式的第一个字符是一个引号 <code>&quot;</code>。</p>\n<p>正则表达式引擎企图在字符串 <code>a &quot;witch&quot; and her &quot;broom&quot; is one</code> 的第一个位置就匹配到目标，但这个位置是 subject:a，所以匹配失败。</p>\n<p>然后它进行下一步：移至字符串中的下一个位置，并试图匹配模式中的第一个字符，最终在第三个位置匹配到了引号：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061634864.png\" alt=\"image-20211206163413803\" /></p>\n</li>\n<li>\n<p>检测到了引号后，引擎就尝试去匹配模式中的剩余字符。它试图查看剩余的字符串主体是否符合 <code>.+&quot;</code>。</p>\n<p>在我们的用例中，模式中的下一个字符为 <code>.</code>（一个点）。它表示匹配除了换行符之外的任意字符，所以将会匹配下一个字符 <code>\'w\'</code>：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061635623.png\" alt=\"image-20211206163507581\" /></p>\n</li>\n<li>\n<p>然后因为量词 <code>.+</code>，模式中的点（.）将会重复。正则表达式引擎逐一读取字符，当该字符可能匹配时就用它来构建匹配项。</p>\n<p>…什么时候会不匹配？点（.）能够匹配所有字符，所以只有在移至字符串末尾时才停止匹配：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061635609.png\" alt=\"image-20211206163551570\" /></p>\n</li>\n<li>\n<p>现在引擎完成了对重复模式 <code>.+</code> 的搜索，并且试图寻找模式中的下一个字符。这个字符是引号 <code>&quot;</code>。但还有一个问题，对字符串的遍历已经结束，已经没有更多的字符了！</p>\n<p>正则表达式引擎明白它已经为 <code>.+</code> 匹配了太多项了，所以开始<strong>回溯</strong>了。</p>\n<p>换句话说，它去掉了量词的匹配项的最后一个字符：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061636058.png\" alt=\"image-20211206163642017\" /></p>\n<p>现在它假设在结束前，<code>.+</code> 会匹配一个字符，并尝试匹配剩余的字符。</p>\n<p>如果出现了一个引号，就表示到达了末尾，但最后一个字符是 <code>\'e\'</code>，所以无法匹配。</p>\n</li>\n<li>\n<p>…所以引擎会再去掉一个字符，以此来减少 <code>.+</code> 的重复次数：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061637362.png\" alt=\"image-20211206163728328\" /></p>\n<p><code>\'&quot;\'</code> 并不会匹配 <code>\'n\'</code>。</p>\n</li>\n<li>\n<p>引擎不断进行回溯：它减少了 <code>\'.\'</code> 的重复次数，直到模式的其它部分（在我们的用例中是 <code>\'&quot;\'</code>）匹配到结果：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061637793.png\" alt=\"image-20211206163758758\" /></p>\n</li>\n<li>\n<p>匹配完成。</p>\n</li>\n<li>\n<p>所以，第一次匹配是 <code>&quot;witch&quot; and her &quot;broom&quot;</code>。接下来的搜索的起点位于第一次搜索的终点，但在 <code>is one</code> 中没有更多的引号了，所以没有其它的结果了。</p>\n</li>\n</ol>\n<p>这可能不是我们所想要的，但这就是它的工作原理。</p>\n<p><strong>在贪婪模式下（默认情况下），量词都会尽可能地重复多次。</strong></p>\n<p>正则表达式引擎尝试用 <code>.+</code> 去获取尽可能多的字符，然后再一步步地筛选它们。</p>\n<p>对于这个问题，我们想要另一种结果，这也就是懒惰量词模式的用途。</p>\n<h2>懒惰模式</h2>\n<p>懒惰模式中的量词与贪婪模式中的是相反的。它想要“重复最少次数”。</p>\n<p>我们能够通过在量词之后添加一个问号 <code>\'?\'</code> 来启用它，所以匹配模式变为 <code>*?</code> 或 <code>+?</code>，甚至将 <code>\'?\'</code> 变为 <code>??</code>。</p>\n<p>这么说吧：通常，一个问号 <code>?</code> 就是一个它本身的量词（0 或 1），但如果添加<strong>另一个量词（甚至可以是它自己）</strong>，就会有不同的意思 —— 它将匹配的模式从贪婪转为懒惰。</p>\n<p>正则表达式 <code>/&quot;.+?&quot;/g</code> 正如预期工作：它找到了 <code>&quot;witch&quot;</code> 和 <code>&quot;broom&quot;</code>：</p>\n<pre><code class=\"language-js\">let reg = /&quot;.+?&quot;/g;\n\nlet str = \'a &quot;witch&quot; and her &quot;broom&quot; is one\';\n\n// 通过在量词 + 后面增加 ? ，使得从默认的贪婪搜索转换为惰性搜索，达到了预期的效果\nconsole.log(str.match(reg)); // [ \'&quot;witch&quot;\', \'&quot;broom&quot;\' ]\n</code></pre>\n<p>为了更清楚地理解这个变化，我们来一步步解析这个搜索过程。</p>\n<ol>\n<li>\n<p>第一步依然相同：它在第三个位置开始 <code>\'&quot;\'</code>：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061643177.png\" alt=\"image-20211206164313130\" /></p>\n</li>\n<li>\n<p>下一步也是类似的：引擎为 <code>\'.\'</code> 找到了一个匹配项：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061643683.png\" alt=\"image-20211206164333642\" /></p>\n</li>\n<li>\n<p>接下来就是搜索过程出现不同的时候了。因为我们对 <code>+?</code> 启用了懒惰模式，引擎不会去尝试多匹配一个点，并且开始了对剩余的 <code>\'&quot;\'</code> 的匹配：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061644820.png\" alt=\"image-20211206164420779\" /></p>\n<p>如果有一个引号，搜索就会停止，但是有一个 <code>\'i\'</code>，所以没有匹配到引号。</p>\n</li>\n<li>\n<p>接着，正则表达式引擎增加对点的重复搜索次数，并且再次尝试：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061644986.png\" alt=\"image-20211206164456950\" /></p>\n<p>又失败了。然后重复次数一次又一次的增加…</p>\n</li>\n<li>\n<p>…直到模式中的剩余部分找到匹配项：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061645040.png\" alt=\"image-20211206164528998\" /></p>\n</li>\n<li>\n<p>接下来的搜索工作从当前匹配结束的那一项开始，就会再产生一个结果：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112061645199.png\" alt=\"image-20211206164555158\" /></p>\n</li>\n</ol>\n<p>在这个例子中，我们看到了懒惰模式 <code>+?</code> 是怎样工作的。量词 <code>*?</code> 和 <code>??</code> 也有类似的效果 —— <strong>只有在模式的剩余部分无法在给定位置匹配时，正则表达式引擎才会增加重复次数</strong>。</p>\n<p><strong>懒惰模式只能够通过带 <code>?</code> 的量词启用</strong></p>\n<p>其它的量词依旧保持贪婪模式。</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">console.log( &quot;123 456&quot;.match(/\\d+ \\d+?/g) ); // 123 4\n</code></pre>\n<ol>\n<li>\n<p>模式 <code>\\d+</code> 尝试匹配尽可能多的数字（贪婪模式），因此在它找到 <code>123</code> 时停止，因为下一个字符为空格 <code>\' \'</code>。</p>\n</li>\n<li>\n<p>匹配到一个空格。</p>\n</li>\n<li>\n<p>由于 <code>\\d+?</code>。量词是出于懒惰模式的，所以它匹配一个数字 <code>4</code> 并且尝试去检测模式的剩余部分是否匹配。</p>\n<p>。。。但是在 <code>\\d+?</code> 之后没有其它的匹配项了。</p>\n<p>懒惰模式不会在不必要的情况下重复任何事情。模式结束，所以我们找到了匹配项 <code>123 4</code>。</p>\n</li>\n<li>\n<p>接下来的搜索工作从字符 <code>5</code> 开始。</p>\n</li>\n</ol>\n<blockquote>\n<p><strong>Optimizations</strong></p>\n<p>当代的正则表达式引擎会通过优化内部算法来提升效率。所以它们的工作流程和所描述的算法可能略有不同。</p>\n<p>但如果只是为了理解正则表达式是如何工作以及如何构建的，我们不需要知道这些，它们仅用于内部优化。</p>\n<p>复杂的正则表达式是难以优化的，所以搜索的过程可能会完全按照描述进行。</p>\n</blockquote>\n<h2>替代方法</h2>\n<p>在正则表达式中，通常有多种方法来达到某个相同目的。</p>\n<p>在用例中，我们能够在不启用懒惰模式的情况下用 <code>&quot;[^&quot;]+&quot;</code> 找到带引号的字符串：</p>\n<pre><code class=\"language-js\">let reg = /&quot;[^&quot;]+&quot;/g;\n\nlet str = \'a &quot;witch&quot; and her &quot;broom&quot; is one\';\n\nconsole.log(str.match(reg)); // [ \'&quot;witch&quot;\', \'&quot;broom&quot;\' ]\n</code></pre>\n<p><code>&quot;[^&quot;]+&quot;</code> 得到了正确的答案，因为它查找一个引号 <code>\'&quot;\'</code>，后跟一个或多个非引号字符 <code>[^&quot;]</code>，然后是结束的引号。</p>\n<p>当引擎寻找 <code>[^&quot;]+</code> 时，它会在匹配到结束的引号时停止重复，这样就完成了。</p>\n<p>请注意，这个逻辑并不能取代惰性量词！</p>\n<p>这是不同的，我们有时需要这一个，有时却需要另一个。</p>\n<p>让我们再来看一个使用惰性量词失败而使用这种方式正确的例子。</p>\n<p>例如，我们想要找到 <code>&lt;a href=&quot;...&quot; class=&quot;doc&quot;&gt;</code> 形式的链接，或是任意 <code>href</code>。</p>\n<p>该使用哪个正则表达式呢？</p>\n<p>首先可能会想到：<code>/&lt;a href=&quot;.*&quot; class=&quot;doc&quot;&gt;/g</code>。</p>\n<p>验证一下：</p>\n<pre><code class=\"language-js\">let str = \'...&lt;a href=&quot;link&quot; class=&quot;doc&quot;&gt;...\';\nlet reg = /&lt;a href=&quot;.*&quot; class=&quot;doc&quot;&gt;/g;\n\n// Works!\nconsole.log( str.match(reg) ); // &lt;a href=&quot;link&quot; class=&quot;doc&quot;&gt;\n</code></pre>\n<p>…但如果文本中有多个链接呢？</p>\n<pre><code class=\"language-js\">let str = \'...&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;... &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;...\';\nlet reg = /&lt;a href=&quot;.*&quot; class=&quot;doc&quot;&gt;/g;\n\n// Whoops! Two links in one match!\nconsole.log(str.match(reg)); // [ \'&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;... &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;\' ]\n</code></pre>\n<p>现在这个结果和我们的 “witches” 用例结果的错误原因是一样的。量词 <code>.*</code> 占用太多字符了。</p>\n<p>匹配结果如下：</p>\n<pre><code class=\"language-html\">&lt;a href=&quot;.....................................&quot; class=&quot;doc&quot;&gt;\n&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;... &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;\n</code></pre>\n<p>让我们启用惰性量词 <code>.*?</code> 来修改模式：</p>\n<pre><code class=\"language-js\">let str = \'...&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;... &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;...\';\nlet reg = /&lt;a href=&quot;.*?&quot; class=&quot;doc&quot;&gt;/g;\n\n// 有效！\nconsole.log(str.match(reg)); // [ \'&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;\', \'&lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;\' ]\n</code></pre>\n<p>现在能成功了，有两个匹配项：</p>\n<pre><code class=\"language-html\">&lt;a href=&quot;.....&quot; class=&quot;doc&quot;&gt;    &lt;a href=&quot;.....&quot; class=&quot;doc&quot;&gt;\n&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;... &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;\n</code></pre>\n<p>它的工作原理是 —— 在上述的解释之后，这应该是显而易见的。所以我们不停留在这些细节上，来再尝试一个例子：</p>\n<pre><code class=\"language-js\">let str = \'...&lt;a href=&quot;link1&quot; class=&quot;wrong&quot;&gt;... &lt;p style=&quot;&quot; class=&quot;doc&quot;&gt;...\';\nlet reg = /&lt;a href=&quot;.*?&quot; class=&quot;doc&quot;&gt;/g;\n\n// 错误！不仅匹配了一个链接，还匹配了包含 &lt;p...&gt; 的一段文本。\nconsole.log(str.match(reg)); // [ \'&lt;a href=&quot;link1&quot; class=&quot;wrong&quot;&gt;... &lt;p style=&quot;&quot; class=&quot;doc&quot;&gt;\' ]\n</code></pre>\n<p>我们会发现，这个正则表达式不仅匹配了一个链接，还匹配了包含 <code>&lt;p...&gt;</code> 的一段文本。</p>\n<p>为什么？</p>\n<ol>\n<li>\n<p>首先，正则表达式发现一个链接标签：<code>&lt;a href=&quot;</code>。</p>\n</li>\n<li>\n<p>然后它寻找 <code>.*?</code>，我们取一个字符，检查其是否与模式的剩余部分匹配，然后再取另一个。。。</p>\n<p>量词 <code>.*?</code> 检测字符，直到 <code>class=&quot;doc&quot;&gt;</code>。</p>\n<p>…在哪里可以找到它呢？我们如果查看文本，就可以看到唯一的 <code>class=&quot;doc&quot;&gt;</code> 是在链接之后的，在 <code>&lt;p&gt;</code> 中。</p>\n</li>\n<li>\n<p>所以有了如下匹配项：</p>\n<pre><code class=\"language-html\">&lt;a href=&quot;...................................&quot; class=&quot;doc&quot;&gt;\n&lt;a href=&quot;link1&quot; class=&quot;wrong&quot;&gt;... &lt;p style=&quot;&quot; class=&quot;doc&quot;&gt;\n</code></pre>\n</li>\n</ol>\n<p>所以，懒惰模式在这里不起作用。</p>\n<p>我们需要寻找 <code>&lt;a href=&quot;...something...&quot; class=&quot;doc&quot;&gt;</code>，但贪婪和懒惰模式都有一些问题。</p>\n<p>正确的做法应该是这样的：<code>href=&quot;[^&quot;]*&quot;</code>。它会获取 href 属性中的所有字符，正好符合我们的需求。</p>\n<p>一个实例：</p>\n<pre><code class=\"language-js\">let str1 = \'...&lt;a href=&quot;link1&quot; class=&quot;wrong&quot;&gt;... &lt;p style=&quot;&quot; class=&quot;doc&quot;&gt;...\';\nlet str2 = \'...&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;... &lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;...\';\nlet reg = /&lt;a href=&quot;[^&quot;]*&quot; class=&quot;doc&quot;&gt;/g;\n\n// Works!\nconsole.log(str1.match(reg)); // null 没有匹配项，是正确的\nconsole.log(str2.match(reg)); // [ \'&lt;a href=&quot;link1&quot; class=&quot;doc&quot;&gt;\', \'&lt;a href=&quot;link2&quot; class=&quot;doc&quot;&gt;\' ]\n</code></pre>\n<h2>总结</h2>\n<p>量词有两种工作模式：</p>\n<ol>\n<li>\n<p>贪婪模式</p>\n<p>默认情况下，正则表达式引擎会尝试尽可能多地重复量词。例如，<code>\\d+</code> 检测所有可能的字符。当不可能检测更多（没有更多的字符或到达字符串末尾）时，然后它再匹配模式的剩余部分。如果没有匹配，则减少重复的次数（<strong>回溯</strong>），并再次尝试。</p>\n</li>\n<li>\n<p>懒惰模式</p>\n<p>通过<strong>在量词后添加问号</strong> <code>?</code> <strong>来启用</strong>。在每次重复量词之前，引擎会尝试去匹配模式的剩余部分。</p>\n<p>正如我们所见，懒惰模式并不是针对贪婪搜索的灵丹妙药。另一种方式是“微调”贪婪搜索（就是巧用<code>[^x]+</code>的形式，尽早截断贪婪搜索，让其赶紧去匹配剩余的模式）。比如</p>\n<pre><code class=\"language-js\">let str = `&quot;a123&quot;&quot;b456&quot;&quot;c789&quot;`\n// 预期效果 &quot;a123&quot;, &quot;b456&quot;, &quot;c789&quot;\n\n// 贪婪匹配，未达到预期效果\nlet reg1 = /&quot;.*&quot;/g\n\n// 懒惰匹配，在量词后面加 ?\n// 达到了预期效果\nlet reg2 = /&quot;.*?&quot;/g\n\n// 替代方法\nlet reg3 = /&quot;[^&quot;]*&quot;/g\n\n\n// 没有达到预期的效果\nconsole.log(str.match(reg1)); // [ \'&quot;a123&quot;&quot;b456&quot;&quot;c789&quot;\' ]\n\n// 达到了预期效果\nconsole.log(str.match(reg2)); // [ \'&quot;a123&quot;\', \'&quot;b456&quot;\', \'&quot;c789&quot;\' ]\n\n// // 达到了预期效果\nconsole.log(str.match(reg3)); // [ \'&quot;a123&quot;\', \'&quot;b456&quot;\', \'&quot;c789&quot;\' ]\n</code></pre>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-greedy-and-lazy#lan-duo-mo-shi\">https://zh.javascript.info/regexp-greedy-and-lazy#lan-duo-mo-shi</a></p>\n', '2021-12-06 17:35:20', '2021-12-06 17:35:20');
INSERT INTO `t_blog` VALUES ('d4435a20-5f57-11ec-b395-6d1b1a7579ec', '二叉搜索树与双向链表', 'JZ36 二叉搜索树与双向链表', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 3, 0, 1, 2, 1, '', '<h2>题目描述</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112172358548.png\" alt=\"image-20211217235855464\" /></p>\n<h2>示例</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112172359833.png\" alt=\"image-20211217235915781\" /></p>\n<h2>代码</h2>\n<h3>代码1 中序遍历，将结果保存在数组中，通过数组构建双向链表</h3>\n<pre><code class=\"language-js\">/*\n二叉搜索树 采用中序遍历（左根右）\n正好得到一个从小到大排好序的数组\n通过数组在构建双向链表\n*/\nfunction Convert(pRootOfTree)\n{\n    if(!pRootOfTree) return null\n    \n    let result = [] // 中序遍历拿到的排好序的节点，通过这个节点构造双向链表\n    // 开始中序遍历\n    inOrder(pRootOfTree)\n    \n    // 开始拼接链表\n    for(let i = 0; i &lt; result.length-1; i++){\n        result[i].right = result[i+1]\n        result[i+1].left = result[i]\n    }\n    \n    return result[0] // 返回头结点\n    \n    \n    // 中序遍历 左根右\n    function inOrder(pRootOfTree){\n        // 出口\n        if(!pRootOfTree) return;\n        \n        // 递归遍历\n        inOrder(pRootOfTree.left) // 左\n        result.push(pRootOfTree) // 根 直接把当前节点的引用保存到数组中，因为题目要求不构建新的节点，所以只能用原来的\n        inOrder(pRootOfTree.right) // 右\n    }\n    \n}\n</code></pre>\n<p>时间复杂度：O(N)，等于中序遍历的时间复杂度。<br />\n空间复杂度：O(N)，开辟了一个数组来存储结点。</p>\n<h3>代码2 中序遍历，遍历的途中直接修改指针指向（全局保存一个前驱节点）</h3>\n<pre><code class=\"language-js\">/*\n因为是二叉搜索树，采用中序遍历直接就是从小到大的结果\n所以本题就采用中序遍历，\n因为题目要求在原树上操作\n所以在遍历的途中把指针给修改了\n\n关键难点在于 如何记录 前一个节点\n\n*/\nfunction Convert(pRootOfTree)\n{\n    if(!pRootOfTree) return null\n    \n    let preNode = null // 递归的途中，记录上一个节点\n    \n    // 找到最左侧的节点，待会好返回\n    // 返回的头结点，就是二叉搜索树最左侧的那个节点\n    let head = pRootOfTree \n    while(head.left) {\n        head = head.left\n    }\n    \n    // 开始遍历，同时修改指针指向，将二叉搜索树转换为双向链表\n    inOreder(pRootOfTree)\n    \n    // 转换完成，返回结果\n    return head\n    \n    \n    // 中序遍历（左根右）的过程中，将指针都修改完毕\n    function inOreder(pRootOfTree){\n        // 出口\n        if(!pRootOfTree) return;\n        \n        inOreder(pRootOfTree.left) // 左\n        \n        //当前结点中需要进校的调整。\n        pRootOfTree.left = preNode\n        // 最左侧的节点第一次进来时，preNode尚未初始化，默认的为null，所以增加一个判断\n        if(preNode) {\n            preNode.right = pRootOfTree\n        }\n        \n        preNode = pRootOfTree //更新preNode，指向当前结点，作为下一个结点的前驱。\n        \n        inOreder(pRootOfTree.right) // 右\n    }\n    \n}\n</code></pre>\n<p>时间复杂度：O(N)，等于中序遍历的时间复杂度。<br />\n空间复杂度：O(N)。没有申请新的空间，但是递归调用栈占用了N的空间。</p>\n<h2>题目来源</h2>\n<p><a href=\"https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&amp;tqId=23253&amp;ru=/practice/b736e784e3e34731af99065031301bca&amp;qru=/ta/coding-interviews/question-ranking\">JZ36 二叉搜索树与双向链表</a></p>\n', '2021-12-18 00:38:56', '2021-12-18 00:38:56');
INSERT INTO `t_blog` VALUES ('d44e8580-48e1-11ec-96d5-7933aca11ca0', 'typeof和Object.prototype.toString', 'js中的`typeof`关键字可以用来判断数据的基本类型，它会返回一个字符串，比如`number`、`string`、`boolean`、`object`、`undefined`等等。其实除了可以使用`typeof`来判断数据类型，我们还可以使用`Object.prototype.toString.call()`，这个方法更灵活好用，本章我们都来学习一下。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 11, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>js中的<code>typeof</code>关键字可以用来判断数据的基本类型，它会返回一个字符串，比如<code>number</code>、<code>string</code>、<code>boolean</code>、<code>object</code>、<code>undefined</code>等等。其实除了可以使用<code>typeof</code>来判断数据类型，我们还可以使用<code>Object.prototype.toString.call()</code>，这个方法更灵活好用，本章我们都来学习一下。</p>\n<h2>typeof</h2>\n<h3>typeof的所有可返回值</h3>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Undefined</td>\n<td>&quot;undefined&quot;</td>\n</tr>\n<tr>\n<td>Null</td>\n<td>&quot;object&quot;</td>\n</tr>\n<tr>\n<td>Boolean</td>\n<td>&quot;boolean&quot;</td>\n</tr>\n<tr>\n<td>Number</td>\n<td>&quot;number&quot;</td>\n</tr>\n<tr>\n<td>BigInt</td>\n<td>&quot;bigint&quot;</td>\n</tr>\n<tr>\n<td>String</td>\n<td>&quot;string&quot;</td>\n</tr>\n<tr>\n<td>Symbol</td>\n<td>&quot;symbol&quot;</td>\n</tr>\n<tr>\n<td>宿主对象（由 JS 环境提供）</td>\n<td>取决于具体实现</td>\n</tr>\n<tr>\n<td>Function对象</td>\n<td>&quot;function&quot;</td>\n</tr>\n<tr>\n<td>其他任何对象</td>\n<td>&quot;object&quot;</td>\n</tr>\n</tbody>\n</table>\n<p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</a></p>\n<h3>示例</h3>\n<pre><code class=\"language-js\">// 数值\ntypeof 37 === \'number\';\ntypeof 3.14 === \'number\';\ntypeof(42) === \'number\';\ntypeof Math.LN2 === \'number\';\ntypeof Infinity === \'number\';\ntypeof NaN === \'number\'; // 尽管它是 &quot;Not-A-Number&quot; (非数值) 的缩写\ntypeof Number(1) === \'number\'; // Number 会尝试把参数解析成数值\n\ntypeof 42n === \'bigint\';\n\n\n// 字符串\ntypeof \'\' === \'string\';\ntypeof \'bla\' === \'string\';\ntypeof `template literal` === \'string\';\ntypeof \'1\' === \'string\'; // 注意内容为数字的字符串仍是字符串\ntypeof (typeof 1) === \'string\'; // typeof 总是返回一个字符串\ntypeof String(1) === \'string\'; // String 将任意值转换为字符串，比 toString 更安全\n\n\n// 布尔值\ntypeof true === \'boolean\';\ntypeof false === \'boolean\';\ntypeof Boolean(1) === \'boolean\'; // Boolean() 会基于参数是真值还是虚值进行转换\ntypeof !!(1) === \'boolean\'; // 两次调用 ! (逻辑非) 操作符相当于 Boolean()\n\n\n// Symbols\ntypeof Symbol() === \'symbol\';\ntypeof Symbol(\'foo\') === \'symbol\';\ntypeof Symbol.iterator === \'symbol\';\n\n\n// Undefined\ntypeof undefined === \'undefined\';\ntypeof declaredButUndefinedVariable === \'undefined\';\ntypeof undeclaredVariable === \'undefined\';\n\n\n// 对象\ntypeof {a: 1} === \'object\';\n\n// 使用 Array.isArray 或者 Object.prototype.toString.call\n// 区分数组和普通对象\ntypeof [1, 2, 4] === \'object\';\n\ntypeof new Date() === \'object\';\ntypeof /regex/ === \'object\'; // 历史结果请参阅正则表达式部分\n\n\n// 下面的例子令人迷惑，非常危险，没有用处。避免使用它们。\ntypeof new Boolean(true) === \'object\';\ntypeof new Number(1) === \'object\';\ntypeof new String(\'abc\') === \'object\';\n\n// 函数\ntypeof function() {} === \'function\';\ntypeof class C {} === \'function\'\ntypeof Math.sin === \'function\';\n</code></pre>\n<h3>typeof null</h3>\n<pre><code class=\"language-js\">// JavaScript 诞生以来便如此\ntypeof null === \'object\';\n</code></pre>\n<h3>typeof 正则表达式</h3>\n<p>对正则表达式字面量的类型判断在某些浏览器中不符合标准：</p>\n<pre><code class=\"language-js\">typeof /s/ === \'function\'; // Chrome 1-12 , 不符合 ECMAScript 5.1\ntypeof /s/ === \'object\'; // Firefox 5+ , 符合 ECMAScript 5.1\n</code></pre>\n<h3>typeof在ES6可能抛出的异常</h3>\n<p>在 ECMAScript 2015 之前，<code>typeof</code> 总能保证对任何所给的操作数返回一个字符串。即便是没有声明的标识符，<code>typeof</code> 也能返回 <code>\'undefined\'</code>。使用 <code>typeof</code> 永远不会抛出错误。</p>\n<p>但在加入了块级作用域的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let\">let</a> 和 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/const\">const</a> 之后，在其被声明之前对块中的 <code>let</code> 和 <code>const</code> 变量使用 <code>typeof</code> 会抛出一个 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError\">ReferenceError</a>。块作用域变量在块的头部处于“<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let#temporal_dead_zone_and_errors_with_let\">暂存死区</a>”，直至其被初始化，在这期间，访问变量将会引发错误。</p>\n<pre><code class=\"language-js\">typeof undeclaredVariable === \'undefined\';\n\ntypeof newLetVariable; // ReferenceError\ntypeof newConstVariable; // ReferenceError\ntypeof newClass; // ReferenceError\n\nlet newLetVariable;\nconst newConstVariable = \'hello\';\nclass newClass{};\n</code></pre>\n<h2>Object.prototype.toString</h2>\n<blockquote>\n<p><code>typeof</code>虽然使用起来很方便，但是在一些特殊的场景下还是会不好用。比如<code>typeof null</code>或者是正则表达式。有一个替代的方法，Object.prototype.toString</p>\n</blockquote>\n<pre><code class=\"language-js\">let obj = {};\nlet arr = [1, 2, 3]\nlet reg = /123/g\nlet fn = function () { }\n\nlet _s = Object.prototype.toString\n\nconsole.log(obj.toString()); // [object Object]\n\nconsole.log(_s.call(arr)); // [object Array]\nconsole.log(_s.call(reg)); // [object RegExp]\nconsole.log(_s.call(null)); // [object Null]\nconsole.log(_s.call(undefined)); // [object Undefined]\nconsole.log(_s.call(true)); // [object Boolean]\nconsole.log(_s.call(Symbol())); // [object Symbol]\nconsole.log(_s.call(123)); // [object Number]\nconsole.log(_s.call(\'123\')); // [object String]\nconsole.log(_s.call(18n)); // [object BigInt]\nconsole.log(_s.call(fn)); // [object Function]\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</a></p>\n', '2021-11-19 10:38:50', '2021-11-19 20:25:48');
INSERT INTO `t_blog` VALUES ('d5e060a0-34cb-11ec-a1da-59f2d55bf031', '定位', '静态定位、相对定位、绝对定位、粘性定位', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 9, 0, 1, 2, 1, '', '<h2><code>position: static</code></h2>\n<ul>\n<li>\n<p>静态定位，元素默认的定位方式</p>\n</li>\n<li>\n<p>按照标准流排列</p>\n</li>\n</ul>\n<h2><code>position:relative</code></h2>\n<ul>\n<li>相对定位，相较于自己原来的位置定位</li>\n<li>不脱离文档流</li>\n</ul>\n<h2><code>position:absolute</code></h2>\n<ul>\n<li>绝对定位，相较于父级已定位的元素（除了<code>static</code>）定位</li>\n<li>如果所有的父级都未定位，就相较于<code>&lt;html&gt;&lt;/html&gt;</code>标签定位</li>\n<li>脱离文档流</li>\n</ul>\n<h2><code>position:fixed</code></h2>\n<ul>\n<li>固定定位，相较于浏览器可视窗口定位</li>\n<li>脱离文档流</li>\n<li>不随滚动条滚动</li>\n</ul>\n<h2><code>position:sticky</code></h2>\n<p>参考：<a href=\"https://www.jianshu.com/p/b72f504121f5\">https://www.jianshu.com/p/b72f504121f5</a></p>\n<ul>\n<li>粘性定位，结合了相对定位和固定定位的特点</li>\n<li>滑动到指定位置处，固定在屏幕中间</li>\n<li>有兼容性问题</li>\n</ul>\n', '2021-10-24 21:11:01', '2021-10-24 21:11:01');
INSERT INTO `t_blog` VALUES ('d6c6e1f0-347c-11ec-a1da-59f2d55bf031', '外边距合并', '两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加...', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 3, 13, 4, 1, 2, 1, 'http://82.156.76.49:20517/upload/png/2021-10-24/c95ac180-347c-11ec-a1da-59f2d55bf031.png', '<p>两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。</p>\n<h2>外边距合并的条件</h2>\n<ul>\n<li>都属于普通流的块级盒子且参与到相同的块级格式上下文中</li>\n<li>没有被padding、border、clear和line box分隔开</li>\n<li>都属于垂直毗邻盒子边缘：\n<ul>\n<li>盒子的top margin和它第一个普通流子元素的top margin</li>\n<li>盒子的bottom margin和它下一个普通流兄弟的top margin</li>\n<li>盒子的bottom margin和它父元素的bottom margin</li>\n<li>盒子的top margin和bottom margin，且没有创建一个新的块级格式上下文，且有被计算为0的min-height，被计算为0或auto的height，且没有普通流子元素，比如<code>&lt;div&gt;&lt;/div&gt;</code>，啥也没有，一个空的元素</li>\n</ul>\n</li>\n</ul>\n<h2>合并的三种情况，小例子</h2>\n<h3>相邻兄弟元素</h3>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6afabaf9f01a44c3bcba7a5808774c63~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211022105203024.png\" /></p>\n<p>如上图，相邻的两个<code>div</code>，<code>box1</code>和<code>box2</code>，最后实际的间距被合并为了<code>30px</code></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    .box1 {\n        width: 100px;\n        height: 100px;\n        background-color: green;\n        margin-bottom: 20px;\n    }\n\n    .box2 {\n        width: 100px;\n        height: 100px;\n        background-color: pink;\n        margin-top: 30px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<h3>相邻的父子元素</h3>\n<h4>父元素的上外边距和第一个子元素的上外边距</h4>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbb3e401df8c4f0f98766b86eed72b46~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211022105203024.png\" /></p>\n<p>如上图，两个<code>div</code>，<code>father</code>和<code>son</code>，<code>father</code>的上边距是<code>30px</code>，<code>son</code>的上边距是<code>60px</code>，最终<code>son</code>并没有和<code>father</code>分离开，而是转移到了<code>father</code>上</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n\n    .father {\n        width: 100px;\n        height: 100px;\n        background-color: green;\n        margin-top: 30px;\n    }\n\n    .son {\n        width: 50px;\n        height: 50px;\n        background-color: pink;\n        margin-top: 60px;\n    }\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<h4>父元素的下外边距和最后一个子元素的下外边距</h4>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce95d7a9d4c44089b571127a80d16518~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211022105203024.png\" /></p>\n<p>如上图<code>father</code>和<code>son2</code>，<code>father</code>的下边距是<code>30px</code>，<code>son2</code>的下边距是<code>60px</code>，最终<code>son2</code>并没有和<code>father</code>分离开，而是转移到了<code>father</code>上</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n\n    .father {\n        width: 100px;\n        background-color: green;\n        margin-bottom: 30px;\n    }\n\n    .son1 {\n        width: 50px;\n        height: 50px;\n        background-color: pink;\n    }\n\n    .son2 {\n        width: 50px;\n        height: 50px;\n        background-color: lightskyblue;\n        margin-bottom: 60px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;div class=&quot;son1&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;son2&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div&gt;参照物&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<h3>高度计算为0或者auto的div自己的上下边距合并</h3>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d4c9015c0c14636831769cfad14beca~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20211022105203024.png\" /></p>\n<p>如上图<code>margin-test</code>的没有给高度，默认是<code>0</code>，给了个上边距<code>20px</code>，下边距<code>30px</code>，最终合并成了<code>30px</code></p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n\n    .box {\n        height: 30px;\n        background: green;\n    }\n\n    .margin-test {\n        margin: 20px 0 30px;\n    }\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;margin-test&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<h2>合并的计算方式</h2>\n<ul>\n<li>如果都是正值，取较大的那一个，比如<code>margin: 20px 0 10px</code> ，最终合并结果是<code>20px</code></li>\n<li>如果一正一负，取两数之和，比如<code>margin: 20px 0 -10px</code> ，最终合并结果是<code>10px</code></li>\n<li>如果都是负数，取绝对值大的那一个，比如<code>margin: -20px 0 -10px</code> ，最终合并结果是<code>-20px</code></li>\n</ul>\n<h2>如何避免外边距合并</h2>\n<p>就是破坏外边距形成的条件，打破任意一个即可：毗邻、两个或多个、普通流和垂直方向。</p>\n<h3>触发一个新的bfc</h3>\n<p>对于第一个例子，相邻的兄弟元素的上下外边距合并，是因为他们处于同一个bfc下面，这时候只要让他俩不处于同一个bfc下就可以避免合并</p>\n<p>比如：使用一个div包裹一下，创建一个新的bfc</p>\n<blockquote>\n<p>触发bfc的条件有很多</p>\n<p>float不为none</p>\n<p>position为absolute或者fixed</p>\n<p>display为inline-block、table-cell、table-caption、flex、inline-flex</p>\n<p>overflow不为visible</p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n    .box1 {\n        width: 100px;\n        height: 100px;\n        background-color: green;\n        margin-bottom: 20px;\n    }\n\n    .box2 {\n        width: 100px;\n        height: 100px;\n        background-color: pink;\n        margin-top: 30px;\n    }\n    .wrapper {\n        overflow: hidden;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;wrapper&quot;&gt;\n        &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>2、对于第二个例子，相邻的父子元素外边距合并，可以把父元素变为一个新的bfc，也可以解决边距合并问题</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n\n    .father {\n        width: 100px;\n        height: 100px;\n        background-color: green;\n        margin-top: 30px;\n        /* float: left; */\n        /* overflow: hidden; */\n        /* position: absolute; */\n        /* position: fixed; */\n        /* display: inline-block; */\n    }\n\n    .son {\n        width: 50px;\n        height: 50px;\n        background-color: pink;\n        margin-top: 60px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>对于第三个例子，空元素块的上下边距合并，可以将这个元素变为一个新的bfc，也解决了自身的上下边距合并问题</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n    .box1 {\n        height: 30px;\n        background: green;\n    }\n    .box2 {\n        height: 30px;\n        background: pink;\n    }\n    .margin-test {\n        margin: 10px 0 20px;\n        /* overflow: hidden; */\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;margin-test&quot;&gt;1&lt;/div&gt;\n    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<h3>不让它们毗邻</h3>\n<p>对于第二个例子，可以给父元素加一个<code>border-top</code>或者<code>padding-top</code>，将<code>father</code>的上外边距和<code>son</code>的上外边距隔断，也能解决外边距合并的问题</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n\n    .father {\n        width: 100px;\n        height: 100px;\n        background-color: green;\n        margin-top: 30px;\n        /* border-top: 1px solid transparent; */\n        /* padding-top: 1px; */\n    }\n\n    .son {\n        width: 50px;\n        height: 50px;\n        background-color: pink;\n        margin-top: 60px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;father&quot;&gt;\n        &lt;div class=&quot;son&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<p>同理第三个例子，空元素的上下边距合并，也可以给其自身增加一个padding-top或者border-top，来隔断边距，从而解决边距合并问题</p>\n<pre><code class=\"language-html\">&lt;style&gt;\n    * {\n        margin: 0;\n    }\n    .box1 {\n        height: 30px;\n        background: green;\n    }\n    .box2 {\n        height: 30px;\n        background: pink;\n    }\n    .margin-test {\n        margin: 10px 0 20px;\n        /* padding-top: 1px; */\n        /* border-top: 1px solid transparent; */\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;box1&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;margin-test&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;box2&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre>\n<h2>总结</h2>\n<ul>\n<li>外边距合并的几种情况</li>\n</ul>\n<p>1、同一文档流中的兄弟元素的上下外边距总会发生合并</p>\n<p>2、空元素自己的上下边距会发生合并</p>\n<p>3、毗邻的父子元素，父元素的上边距，会和子元素的上边距合并；父元素的下边距，会和子元素的下边距发生合并</p>\n<ul>\n<li>避免外边距合并</li>\n</ul>\n<p>1、使发生合并的元素处于不同的bfc块下</p>\n<p>2、破坏其毗邻的位置关系，增加<code>border</code>或者<code>padding</code>，不让<code>margin</code>直接接触</p>\n<ul>\n<li>触发bfc的几个属性</li>\n</ul>\n<p>1、根元素本身就是一个bfc，即body标签</p>\n<p>2、float不为none</p>\n<p>3、position为absolute或fixed</p>\n<p>4、display为inline-block，table-cell，table-caption，flex，inline-flex</p>\n<p>5、overflow不为visible</p>\n<p>参考：</p>\n<p><a href=\"https://segmentfault.com/a/1190000010346113?utm_source=sf-similar-article#item-2-8\">https://segmentfault.com/a/1190000010346113?utm_source=sf-similar-article#item-2-8</a></p>\n<p><a href=\"https://blog.csdn.net/prdslf001001/article/details/99972476\">https://blog.csdn.net/prdslf001001/article/details/99972476</a></p>\n', '2021-10-24 11:45:32', '2021-12-09 21:54:56');
INSERT INTO `t_blog` VALUES ('d6eb4710-4689-11ec-96d5-7933aca11ca0', 'call、apply、bind', '我们知道，js的this指向总是在运行时才能够确定，这样虽然很灵活，但是也不能满足所有的需求场景。假如在程序运行时，我们想人为的改变它指向到某一个对象上（不再是.前面的对象了），这时该怎么做呢？于是call、apply和bind就出现了，可以显示的改变函数中的this指向。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 5, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>在上一篇文章中 <a href=\"http://www.bnbiye.cn/#/articleDetail/9499b500-42c3-11ec-96d5-7933aca11ca0\">js的this指向</a>，我们知道，js的<code>this</code>指向总是在运行时才能够确定，这样虽然很灵活，但是也不能满足所有的需求场景。假如在程序运行时，我们想人为的改变它指向到某一个对象上（不再是<code>.</code>前面的对象了），这时该怎么做呢？</p>\n<p>于是<code>call、apply和bind</code>就出现了，可以显示的改变函数中的<code>this</code>指向。</p>\n<h2>一个例子</h2>\n<pre><code class=\"language-js\">const obj1 = {\n    name: \'tom\',\n    getName() {\n        console.log(this.name);\n        console.log(Array.from(arguments));\n    }\n};\n\nconst obj2 = {\n    name: \'jerry\'\n};\n\nobj1.getName(1, 2, 3)\n// tom\n// [1,2,3]\n</code></pre>\n<p>如上述例子，我们什么也没做，<code>obj1</code>在调用自己的<code>getName()</code>方法时，因为<code>.</code>前面的对象是<code>obj1</code>，所以此时的<code>this</code>就是<code>obj1</code>，当打印<code>this.name</code>时输出了自己的<code>tom</code>。并且我们传入的参数<code>1, 2, 3</code>会被<code>arguments</code>接收，所以同时打印了<code>[1,2,3]</code>。让我们改写一下。</p>\n<h3>call</h3>\n<p>使用<code>call</code>改变<code>this</code>指向。</p>\n<pre><code class=\"language-js\">const obj1 = {\n    name: \'tom\',\n    getName() {\n        console.log(this.name);\n        console.log(Array.from(arguments));\n    }\n};\n\nconst obj2 = {\n    name: \'jerry\'\n};\n\nobj1.getName.call(obj2, 1, 2, 3)\n// jerry\n// [1,2,3]\n</code></pre>\n<p>如上面的例子所示，当<code>obj1</code>调用<code>getName()</code>方法时，使用<code>call</code>显示的将<code>this</code>指向了<code>obj2</code>对象上，当在输出结果时，发现结果已经变了，因为此时的<code>this</code>显示的指向了<code>obj2</code>，所以打印<code>this.name</code>时，输出了<code>jerry</code>。并且我们传入的参数<code>1, 2, 3</code>会被<code>arguments</code>接收，所以同时打印了<code>[1,2,3]</code>。（注意，<code>call</code>的传参是一个一个传的）</p>\n<blockquote>\n<p>🚩<code>function.call(thisArg, arg1, arg2, ...)</code></p>\n<ul>\n<li>\n<p><code>thisArg</code></p>\n<p>可选的。在*<code>function</code>* 函数运行时使用的<code>this</code> 值。<strong>非严格模式下</strong> ，如果不传入，或传入<code>null</code>或<code>undefined</code>时会自动替换为全局对象，原始类型将会被包装。<strong>严格模式下</strong> ，传入的是什么就是什么，如果不传，就为<code>undefined</code>。</p>\n</li>\n<li>\n<p><code>arg1, arg2, ...</code></p>\n<p>指定的参数列表。</p>\n</li>\n<li>\n<p>返回值</p>\n<p>调用有指定<code>this</code>值和参数的函数的结果。若该方法没有返回值，则返回<code>undefined</code>。</p>\n</li>\n</ul>\n</blockquote>\n<h3>apply</h3>\n<p>使用<code>apply</code>改变<code>this</code>指向。</p>\n<pre><code class=\"language-js\">const obj1 = {\n    name: \'tom\',\n    getName() {\n        console.log(this.name);\n        console.log(Array.from(arguments));\n    }\n};\n\nconst obj2 = {\n    name: \'jerry\'\n};\n\nobj1.getName.apply(obj2, [1, 2, 3])\n// jerry\n// [1,2,3]\n</code></pre>\n<p>如上面的例子所示，当<code>obj1</code>调用<code>getName()</code>方法时，使用<code>apply</code>显示的将<code>this</code>指向了<code>obj2</code>对象上，当在输出结果时，发现结果已经变了。因为此时的<code>this</code>指向<code>obj2</code>，所以打印<code>this.name</code>时，输出了<code>jerry</code>。并且我们传入的参数<code>[1, 2, 3]</code>会被<code>arguments</code>接收，所以同时打印了<code>[1,2,3]</code>。（注意，<code>apply</code>的传参是一个数组）</p>\n<blockquote>\n<p>🚩<code>function.apply(thisArg, [argsArray])</code></p>\n<ul>\n<li>\n<p><code>thisArg</code></p>\n<p>可选的（<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\">MDN</a>上写的必选，应该是写错了，跟<code>call</code>方法是一样的）。在*<code>function</code>* 函数运行时使用的<code>this</code> 值。<strong>非严格模式下</strong> ，如果不传入，或传入<code>null</code>或<code>undefined</code>时会自动替换为全局对象，原始类型将会被包装。<strong>严格模式下</strong> ，传入的是什么就是什么，如果不传，就为<code>undefined</code>。</p>\n</li>\n<li>\n<p><code>argsArray</code></p>\n<p>可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给<code>func</code> 函数。如果该参数的值为<code>null</code>或<code>undefined</code>，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。</p>\n</li>\n<li>\n<p>返回值</p>\n<p>调用有指定<code>this</code>值和参数的函数的结果。若该方法没有返回值，则返回<code>undefined</code>。</p>\n</li>\n</ul>\n</blockquote>\n<h3>bind</h3>\n<p>使用<code>bind</code>改变<code>this</code>指向。</p>\n<pre><code class=\"language-js\">const obj1 = {\n    name: \'tom\',\n    getName() {\n        console.log(this.name);\n        console.log(Array.from(arguments));\n    }\n};\n\nconst obj2 = {\n    name: \'jerry\'\n};\n\nconst fn = obj1.getName.bind(obj2, 1, 2)\nfn(3)\n// jerry\n// [1,2,3]\n</code></pre>\n<p>如上面的例子所示，当<code>obj1</code>调用<code>getName()</code>方法时，使用<code>bind</code>显示的将<code>this</code>指向了<code>obj2</code>对象上，<code>bind</code>并不会直接调用方法，而是会返回一个新函数，新函数的<code>this</code>被指定为<code>bind</code>的第一个参数，<strong>其余参数将作为新函数的参数，供调用时使用</strong> 。</p>\n<p>我们调用新函数<code>fn</code>，当输出结果时，发现结果已经变了。因为此时的<code>this</code>指向<code>obj2</code>，所以打印<code>this.name</code>时，输出了<code>jerry</code>。</p>\n<blockquote>\n<p>🚩<code>function.apply(thisArg[, arg1[, arg2[, ...]]])</code></p>\n<ul>\n<li>\n<p><code>thisArg</code></p>\n<p>可选的。在<code>function</code> 函数运行时使用的<code>this</code> 值。<strong>非严格模式下</strong> ，如果不传入，或传入<code>null</code>或<code>undefined</code>时会自动替换为全局对象，原始类型将会被包装。<strong>严格模式下</strong> ，传入的是什么就是什么，如果不传，就为<code>undefined</code>。</p>\n</li>\n<li>\n<p><code>arg1, arg2, ...</code></p>\n<p>可选的。当目标函数被调用时，被预置入绑定函数的参数列表中的参数。</p>\n</li>\n<li>\n<p>返回值</p>\n<p>返回一个原函数的拷贝，称之为绑定函数（<strong>bound function</strong> ，BF），拥有指定的<code>this</code> 值和初始参数。</p>\n</li>\n</ul>\n</blockquote>\n<h2>call、apply、bind的区别</h2>\n<p>通过上面的例子，我们知道，<code>call、apply、bind</code>的作用都是用来改变js方法中的<code>this</code>指向。但是它们还有些区别。</p>\n<ul>\n<li>call、apply\n<ol>\n<li><code>call和apply</code>两个比较相似，它俩的第一个参数都是改变后的<code>this</code>值，都是可选的。在非严格模式下，该参数如果不传或者传入<code>null</code>或<code>undefined</code>时，都会默认指向全局对象（浏览器端指向<code>window</code>，<code>nodejs</code>端指向<code>global</code>），如果传入的是基本类型（number、boolean等），都会自动转换为对应的包装对象（Number、Boolean等）。在严格模式下，传入的是啥就是啥，如果不传，就是<code>undefined</code>。</li>\n<li>但是它俩第二个参数就完全不一样了，<code>call</code>接收的是一串参数，想传多少传多少，比如<code>arg1, arg2, ...</code>。而<code>apply</code>第二个参数接收的是一个数组或者类数组对象，比如<code>[arg1, arg2, ...]</code>。</li>\n<li>它俩还有一个相同点，都是直接调用的。</li>\n<li>所以，这两个方法还是很相似的，如果参数想传数组就用<code>apply</code>，不需要传数组，一个一个传就用<code>call</code>。</li>\n</ol>\n</li>\n<li><code>bind</code>\n<ol>\n<li><code>bind</code>与<code>call、apply</code>的第一个参数类似，都是改变后的<code>this</code>值，并且在严格模式和非严格模式下的性质也都一样。</li>\n<li>不同的地方是返回值不同，<code>call、apply</code>方法都是立即调用，返回值都是原先方法的返回值，如果原先方法没有返回值，就默认返回<code>undefined</code>。而<code>bind</code>的返回值是原来函数的一个拷贝，称之为绑定函数（<strong>bound function</strong> ，BF），即已经绑定好了<code>this</code>，其值为绑定时传入的第一个参数。调用绑定函数会执行包装函数（原函数）。绑定函数也可以使用<code>new</code>运算符构造，不过它提供的<code>this</code>会被忽略，参数仍会提供给模板函数。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">参考 MDN，bind</a></li>\n<li><code>bind</code>的第一个参数是待绑定的<code>this</code>，从第二个参数开始，就可以随便传，传参的方式和<code>call</code>差不多，<code>arg1, arg2, ...</code>。<code>bind</code>传入的参数会跟新函数的参数做一个合并，假如在绑定<code>this</code>时，另外传了两个参数<code>arg1, arg2</code>，如：<code>const newFn =  oldFn.bind(null, arg1, arg2)</code>，然后调用新函数<code>newFn(arg3, arg4)</code>，最终执行新函数时，实际接收的参数就是<code>arg1, arg2, arg3, arg4</code>（会做一个合并）。</li>\n<li>所以<code>bind</code>除了改变<code>this</code>外，有时也可以给某个函数预设初始值（利用参数合并的特点）。</li>\n</ol>\n</li>\n</ul>\n<h2>手写call</h2>\n<p>手写call，注意下面几点</p>\n<ol>\n<li>第一个参数传的是<code>this</code>，然后可以传很多个参数`arg1, arg2, ...``</li>\n<li><code>this</code>默认是传的第一个参数，如果不是，就传<code>window</code></li>\n<li>新写的方法应该是在构造函数<code>Function</code>的原型上面，比如，<code>Function.prorotype.mycall()</code></li>\n<li>调用方式保持一致，<code>xxObj1.xxFn.myCall(xxObj2, arg1, arg2, ...)</code>或者<code>xxFn.myCall(xxObj, arg1, arg2, ...)</code></li>\n<li>调用后的返回值与改变后<code>this</code>指向的原函数保持一致</li>\n</ol>\n<pre><code class=\"language-js\">Function.prototype.myCall = function (xxObj, ...agrs) {\n    // 2.\n    xxObj = xxObj || window\n    agrs = agrs || []\n    // 为xxObj添加这个方法，为了避免与原来的属性键值冲突，使用Symbol作为key\n    let key = Symbol()\n    xxObj[key] = this // 因为调用方式是 xxObj1.xxFn.myCall(xxObj2, arg1, arg2, ...)，所以当前的this就是xxFn，将它塞到新对象上\n    // 5.\n    let x = xxObj[key](...agrs)\n    delete xxObj[key] // 使用完后再删除\n\n    return x\n}\n</code></pre>\n<p>使用</p>\n<pre><code class=\"language-js\">let obj1 = {\n    name: \'aa\',\n    getName: function () {\n        console.log(this.name, Array.from(arguments));\n        return \'hhh\'\n    }\n}\n\nlet obj2 = {\n    name: \'bb\'\n}\n\nlet x1 = obj1.getName(1, 2) // aa [1, 2]\nconsole.log(x1);// hhh\nlet x2 = obj1.getName.myCall(obj2, 3, 4) // bb [3, 4]\nconsole.log(x2); // hhh\n</code></pre>\n<h2>手写apply</h2>\n<p><code>apply</code>和<code>call</code>就参数不一样。</p>\n<ol>\n<li>第一个参数传的是<code>this</code>，第二个参数是一个数组，比如<code>[arg1, arg2, ...]</code></li>\n<li><code>this</code>默认是传的第一个参数，如果不是，就传<code>window</code></li>\n<li>新写的方法应该是在构造函数<code>Function</code>的原型上面，比如，<code>Function.prorotype.mycall()</code></li>\n<li>调用方式保持一致，<code>xxObj1.xxFn.myCall(xxObj2, arg1, arg2, ...)</code>或者<code>xxFn.myCall(xxObj, arg1, arg2, ...)</code></li>\n<li>调用后的返回值与改变后<code>this</code>指向的原函数保持一致</li>\n</ol>\n<pre><code class=\"language-js\">Function.prototype.myApply = function (context, args) {\n    //这里默认不传就是给window或者global\n    context = context || window\n    args = args ? args : []\n    //给context新增一个独一无二的属性以免覆盖原有属性\n    const key = Symbol()\n    context[key] = this\n    //通过隐式绑定的方式调用函数\n    const result = context[key](...args) // obj1.getName.myApply，所以此时会获得原始函数，待会直接调用\n    //删除添加的属性\n    delete context[key]\n    //返回函数调用的返回值\n    return result\n}\n</code></pre>\n<p>使用</p>\n<pre><code class=\"language-js\">let obj1 = {\n    name: \'aa\',\n    getName: function () {\n        console.log(this.name, Array.from(arguments));\n        return \'hhh\'\n    }\n}\n\nlet obj2 = {\n    name: \'bb\'\n}\n\nlet x1 = obj1.getName(1, 2) // aa [1, 2]\nconsole.log(x1);// hhh\nlet x2 = obj1.getName.myCall(obj2, [3, 4]) // bb [3, 4]\nconsole.log(x2); // hhh\n</code></pre>\n<h2>手写bind</h2>\n<ol>\n<li>bind第一个参数传的是this，这里默认传的是一个对象</li>\n<li>bind从第二个参数开始，可以传很多个，类似call的传参，比如<code>arg1, arg2, ...</code></li>\n<li>bind返回的是一个绑定过this的绑定函数，绑定函数也可以传参，最终执行的时候，会和步骤2中的参数做一个合并</li>\n<li>绑定函数也可以使用new关键字，声明出来的对象就好像一个绑定好值的原构造方法的实例对象（绑定函数在使用new关键字构建对象时，它只起到一个包装作用，并没有干什么事，新对象仍有原构造方法的特性，比如能访问原构造方法原型上的属性和方法，即instanceof 原构造函数时，返回true）</li>\n<li>绑定函数也有返回值，返回值与原方法保持一致</li>\n</ol>\n<pre><code class=\"language-js\">Function.prototype.myBind = function (context, ...agrs) {\n    context = context || window\n    agrs = agrs || []\n\n    // 调用bind的方式是 xxxObj1.xxxFn.bind(xxxObj2, arg1, arg2, ...)，所以当前this就是 xxxFn\n    let fn = this\n\n    // 3.\n    let boundFn = function () {\n        // 参数合并\n        let newArgs = [...agrs, ...arguments]\n        // 5. 应该做一个判定，如果是new出来的对象，就会忽略原先的context\n        context = this instanceof fn ? this : context\n        let x = fn.apply(context, newArgs)\n        return x\n    }\n\n    // 4. 需要考虑new的情况，使用寄生组合式继承的方式，需要做个简单的变形 返回的boundFn原型上的constructor属性还应该指向bind之前的构造器\n    let TempFn = function () { }\n    TempFn.prototype = fn.prototype\n    boundFn.prototype = new TempFn\n    boundFn.prototype.constructor = fn // 返回的绑定函数最终的constructor还是原来bind之前的函数\n\n    return boundFn\n}\n</code></pre>\n<p>使用1</p>\n<pre><code class=\"language-js\">let obj1 = {\n    name: \'aa\',\n    getName: function () {\n        console.log(this.name, Array.from(arguments));\n    }\n}\n\nlet obj2 = {\n    name: \'bb\'\n}\n\nobj1.getName(1, 2, 3) // aa [1, 2, 3]\nlet newFN = obj1.getName.myBind(obj2, 1, 2)\nnewFN(3, 4) // bb [1, 2, 3, 4]\n</code></pre>\n<p>使用2</p>\n<pre><code class=\"language-js\">function Person(name, age) {\n    this.name = name\n    this.age = age\n}\nPerson.prototype.toString = function () {\n    console.log(`${this.name}---${this.age}`);\n}\n\nlet newPersonFn = Person.myBind(obj1, \'dd\', 20)\nlet p2 = new newPersonFn()\np2.toString() // dd---20\nconsole.log(p2 instanceof newPersonFn); // true\nconsole.log(p2 instanceof Person); // true\nconsole.log(p2.constructor === Person); // true\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903496253177863#heading-1\">https://juejin.cn/post/6844903496253177863#heading-1</a></p>\n<p><a href=\"https://juejin.cn/post/6844903891092389901\">https://juejin.cn/post/6844903891092389901</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call</a></p>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply</a></p>\n<p><a href=\"https://juejin.cn/post/6946022649768181774#heading-30\">https://juejin.cn/post/6946022649768181774#heading-30</a></p>\n', '2021-11-16 11:03:57', '2021-11-22 09:15:40');
INSERT INTO `t_blog` VALUES ('d94ae140-5648-11ec-96d5-7933aca11ca0', '集合和范围[...]', '在方括号 `[…]` 中的几个字符或者字符类意味着“搜索给定的字符中的任意一个”。', '-1', 2, 'https://zh.javascript.info/regexp-character-sets-and-ranges', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 7, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>在方括号 <code>[…]</code> 中的几个字符或者字符类意味着“搜索给定的字符中的任意一个”。</p>\n<h2>集合</h2>\n<p>比如说，<code>[eao]</code> 意味着查找在 3 个字符 <code>\'a\'</code>、<code>\'e\'</code> 或者 `‘o’ 中的任意一个。</p>\n<p>这被叫做一个<strong>集合</strong>。集合可以在正则表达式中和其它常规字符一起使用。</p>\n<pre><code class=\"language-js\">// 查找 [t 或者 m]，然后再匹配 “op”\nconsole.log( &quot;Mop top&quot;.match(/[tm]op/gi) ); // [ \'Mop\', \'top\' ]\n</code></pre>\n<p>请注意尽管在集合中有多个字符，但它们在匹配中只会对应其中的一个。</p>\n<p>所以下面的示例并不会匹配上：</p>\n<pre><code class=\"language-js\">// 查找 “V”，然后匹配 [o 或者 i]，之后再匹配 “la”\nconsole.log( &quot;Voila&quot;.match(/V[oi]la/) ); // null，并没有匹配上\n</code></pre>\n<p>这个模式会做以下假设：</p>\n<ul>\n<li><code>V</code>，</li>\n<li>然后匹配其中的<strong>一个字符</strong> <code>[oi]</code>，</li>\n<li>然后匹配 <code>la</code>，</li>\n</ul>\n<p>所以可以匹配上 <code>Vola</code> 或者 <code>Vila</code>。</p>\n<h2>范围</h2>\n<p>方括号也可以包含<strong>字符范围</strong>。</p>\n<p>比如说，<code>[a-z]</code> 会匹配从 <code>a</code> 到 <code>z</code> 范围内的字母，<code>[0-5]</code> 表示从 <code>0</code> 到 <code>5</code> 的数字。</p>\n<p>在下面的示例中，我们会查询首先匹配 <code>&quot;x&quot;</code> 字符，再匹配两个数字或者位于 <code>A</code> 到 <code>F</code> 范围内的字符。</p>\n<pre><code class=\"language-js\">console.log( &quot;Exception 0xAF&quot;.match(/x[0-9A-F][0-9A-F]/g) ); // [ \'xAF\' ]\n</code></pre>\n<p><code>[0-9A-F]</code> 表示两个范围：它搜索一个字符，满足数字 <code>0</code> 到 <code>9</code> 或字母 <code>A</code> 到 <code>F</code>。</p>\n<p>如果我们还想查找小写字母，则可以添加范围 <code>a-f</code>：<code>[0-9A-Fa-f]</code>。或添加标志 <code>i</code>。</p>\n<p>我们也可以在 <code>[…]</code> 里面使用字符类。</p>\n<p>例如，如果我们想要查找单词字符 <code>\\w</code> 或连字符 <code>-</code>，则该集合为 <code>[\\w-]</code>。</p>\n<p>也可以组合多个类，例如 <code>[\\s\\d]</code> 表示 “空格字符或数字”。</p>\n<blockquote>\n<p><strong>字符类是某些字符集的简写</strong></p>\n<p>例如：</p>\n<ul>\n<li><strong>\\d</strong> —— 和 <code>[0-9]</code> 相同，</li>\n<li><strong>\\w</strong> —— 和 <code>[a-zA-Z0-9_]</code> 相同，</li>\n<li><strong>\\s</strong> —— 和 <code>[\\t\\n\\v\\f\\r ]</code> 外加少量罕见的 unicode 空格字符相同。</li>\n</ul>\n</blockquote>\n<h2>示例：多语言<code>\\w</code></h2>\n<p>由于字符类 <code>\\w</code> 是简写的 <code>[a-zA-Z0-9_]</code>，因此无法找到中文象形文字，西里尔字母等。</p>\n<p>我们可以编写一个更通用的模式，该模式可以查找任何语言中的文字字符。这很容易想到就 Unicode 属性：</p>\n<p><code>[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]</code>。</p>\n<p>让我们理解它。类似于 <code>\\w</code>，我们在制作自己的一套字符集，包括以下 unicode 字符：</p>\n<ul>\n<li><code>Alphabetic</code> (<code>Alpha</code>) —— 字母，</li>\n<li><code>Mark</code> (<code>M</code>) —— 重读，</li>\n<li><code>Decimal_Number</code> (<code>Nd</code>) —— 数字，</li>\n<li><code>Connector_Punctuation</code> (<code>Pc</code>) —— 下划线 <code>\'_\'</code> 和类似的字符，</li>\n<li><code>Join_Control</code> (<code>Join_C</code>) —— 两个特殊代码 <code>200c</code> and <code>200d</code>，用于连字，例如阿拉伯语。</li>\n</ul>\n<p>使用示例：</p>\n<pre><code class=\"language-js\">let regexp = /[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]/gu;\n\nlet str = `Hi 你好 12`;\n\n// finds all letters and digits:\nconsole.log( str.match(regexp) ); // H,i,你,好,1,2\n</code></pre>\n<p>当然，我们可以编辑此模式：添加 unicode 属性或删除它们。文章 <a href=\"http://www.bnbiye.cn/#/articleDetail/276f1d80-5579-11ec-96d5-7933aca11ca0\">Unicode：修饰符 “u” 和 class \\p{...}</a> 中包含了更多 Unicode 属性的细节。</p>\n<blockquote>\n<p><strong>Edge 和 Firefox 不支持 Unicode 属性</strong></p>\n<p>Edge 和 Firefox 尚未实现 Unicode 属性 <code>p{…}</code>。如果确实需要它们，可以使用库 <a href=\"http://xregexp.com/\">XRegExp</a>。</p>\n<p>或者只使用我们想要的语言范围的字符，例如西里尔字母 <code>[а-я]</code>。</p>\n</blockquote>\n<h2>排除范围</h2>\n<p>除了普通的范围匹配，还有类似 <code>[^…]</code> 的“排除”范围匹配。</p>\n<p>它们通过在匹配查询的开头添加插入符号 <code>^</code> 来表示，它会匹配所有<strong>除了给定的字符</strong>之外的任意字符。</p>\n<p>比如说：</p>\n<ul>\n<li><code>[^aeyo]</code> —— 匹配任何除了 <code>\'a\'</code>、<code>\'e\'</code>、<code>\'y\'</code> 或者 <code>\'o\'</code> 之外的字符。</li>\n<li><code>[^0-9]</code> —— 匹配任何除了数字之外的字符，也可以使用 <code>\\D</code> 来表示。</li>\n<li><code>[^\\s]</code> —— 匹配任何非空字符，也可以使用 <code>\\S</code> 来表示。</li>\n</ul>\n<p>下面的示例查询除了字母，数字和空格之外的任意字符：</p>\n<pre><code class=\"language-js\">console.log( &quot;alice15@gmail.com&quot;.match(/[^\\d\\sA-Z]/gi) ); // [ \'@\', \'.\' ]\n</code></pre>\n<h2>在<code>[...]</code>中不转义</h2>\n<p>通常当我们的确需要查询点字符时，我们需要把它转义成像 <code>\\.</code> 这样的形式。如果我们需要查询一个反斜杠，我们需要使用 <code>\\\\</code>。</p>\n<p>在方括号表示中，绝大多数特殊字符可以在不转义的情况下使用：</p>\n<ul>\n<li>表示一个点符号 <code>\'.\'</code>。</li>\n<li>表示一个加号 <code>\'+\'</code>。</li>\n<li>表示一个括号 <code>\'( )\'</code>。</li>\n<li>在开头或者结尾表示一个破折号（在这些位置该符号表示的就不是一个范围） `pattern:’-’。</li>\n<li>在不是开头的位置表示一个插入符号（在开头位置该符号表示的是排除）<code>\'^\'</code>。</li>\n<li>表示一个开口的方括号符号 <code>\'[\'</code>。</li>\n</ul>\n<p><strong>换句话说，除了在方括号中有特殊含义的字符外，其它所有特殊字符都是允许不添加反斜杠的。</strong></p>\n<p>一个在方括号中的点符号 <code>&quot;.&quot;</code> 表示的就是一个点字符。查询模式 <code>[.,]</code> 将会寻找一个为点或者逗号的字符。</p>\n<p>在下面的示例中，<code>[-().^+]</code> 会查找 <code>-().^+</code> 的其中任意一个字符：</p>\n<pre><code class=\"language-js\">// 并不需要转义\nlet reg = /[-().^+]/g;\n\nconsole.log( &quot;1 + 2 - 3&quot;.match(reg) ); // [ \'+\', \'-\' ]\n</code></pre>\n<p>。。。但是如果你为了“以防万一”转义了它们，这也不会有任何问题：</p>\n<pre><code class=\"language-js\">//转义其中的所有字符\nlet reg = /[\\-\\(\\)\\.\\^\\+]/g;\n\nconsole.log( &quot;1 + 2 - 3&quot;.match(reg) ); // 仍能正常工作：[ \'+\', \'-\' ]\n</code></pre>\n<h2>范围和标志&quot;u&quot;</h2>\n<p>如果集合中有代理对（surrogate pairs），则需要标志 <code>u</code> 以使其正常工作。</p>\n<p>例如，让我们在字符串 <code>𝒳</code> 中查找 <code>[𝒳𝒴]</code>：</p>\n<pre><code class=\"language-js\">console.log(\'𝒳\'.match(/[𝒳𝒴]/)); // 显示一个奇怪的字符，像 [?]\n// [ \'�\', index: 0, input: \'𝒳\', groups: undefined ]\n//（搜索执行不正确，返回了半个字符）\n</code></pre>\n<p>结果不正确，因为默认情况下正则表达式“不知道”代理对。</p>\n<p>正则表达式引擎认为 <code>[𝒳𝒴]</code> —— 不是两个，而是四个字符：</p>\n<ol>\n<li><code>𝒳</code> <code>(1)</code> 的左半部分，</li>\n<li><code>𝒳</code> <code>(2)</code> 的右半部分，</li>\n<li><code>𝒴</code> <code>(3)</code> 的左半部分，</li>\n<li><code>𝒴</code> <code>(4)</code> 的右半部分。</li>\n</ol>\n<p>我们可以看到它们的代码，如下所示：</p>\n<pre><code class=\"language-js\">for (let i = 0; i &lt; \'𝒳𝒴\'.length; i++) {\n    console.log(\'𝒳𝒴\'.charCodeAt(i)); // 55349, 56499, 55349, 56500\n};\n</code></pre>\n<p>因此，以上示例查找并显示了 <code>𝒳</code> 的左半部分。</p>\n<p>如果我们添加标志 <code>u</code>，那么行为将是正确的：</p>\n<pre><code class=\"language-js\">console.log( \'𝒳\'.match(/[𝒳𝒴]/u) ); // [ \'𝒳\', index: 0, input: \'𝒳\', groups: undefined ]\n</code></pre>\n<p>当我们查找范围时也会出现类似的情况，就像 <code>[𝒳-𝒴]</code>。</p>\n<p>如果我们忘记添加标志 <code>u</code>，则会出现错误：</p>\n<pre><code class=\"language-js\">console.log(\'𝒳\'.match(/[𝒳-𝒴]/)); // 错误：无效的正则表达式\n// SyntaxError: Invalid regular expression: /[𝒳-𝒴]/: Range out of order in character class\n</code></pre>\n<p>原因是，没有标志 <code>u</code> 的代理对被视为两个字符，因此 <code>[𝒳-𝒴]</code> 被解释为 <code>[&lt;55349&gt;&lt;56499&gt;-&lt;55349&gt;&lt;56500&gt;]</code>（每个代理对都替换为其代码）。现在很容易看出范围 <code>56499-55349</code> 是无效的：其起始代码 <code>56499</code> 大于终止代码 <code>55349</code>。这就是错误的原因。</p>\n<p>使用标志 <code>u</code>，该模式可以正常匹配：</p>\n<pre><code class=\"language-js\">// 查找字符从 𝒳 到 𝒵\nconsole.log(\'𝒴\'.match(/[𝒳-𝒵]/u)); // [ \'𝒴\', index: 0, input: \'𝒴\', groups: undefined ]\n</code></pre>\n<h2>总结</h2>\n<ol>\n<li>\n<p>正则表达式中，使用方括号包裹的字符，类似于<code>[abcd]</code>，表示满足其中一个字符即可</p>\n</li>\n<li>\n<p>如果想取反的话，可以在方括号中使用<code>^</code>，比如<code>[^0-9]</code>，表示不是<code>0-9</code>中的任意一个</p>\n</li>\n<li>\n<p>方括号中的<code>-</code>表示范围，比如<code>[0-9]</code>就是<code>[0123456789]</code></p>\n</li>\n<li>\n<p>一些简写方式</p>\n<ol>\n<li><code>\\d</code>：数字集合，也可以表示为<code>[0-9]</code>，所以<code>\\D</code>可以表示为<code>[^0-9]</code></li>\n<li><code>\\s</code>：空格符号，包括空格、制表符<code>\\t</code>、换行符<code>\\n</code>，和其它少数的稀有字符，也可以表示为，和<code>[\\t\\n\\v\\f\\r ]</code> 外加少量罕见的 unicode 空格字符。（<code>\\v</code>：垂直标签，<code>\\f</code>：换页，<code>\\r</code>：Windows文本文件使用两个字符<code>\\r\\n</code>表示换行）</li>\n<li><code>\\w</code>：一个单词，也可以表示为<code>[a-zA-Z0-9_]</code>，所以<code>\\W</code>，非单字符可以表示为<code>[^a-zA-Z0-9_]</code></li>\n</ol>\n</li>\n<li>\n<p>一些特殊字符的范围表示，必须加修饰符<code>u</code>，比如<code>[/[𝒳-𝒵]/u]</code>，如果不标识<code>u</code>不能正常识别，且有可能会报错。这是因为，没有标识<code>u</code>的代理对被视为两个字符，因此那些四个字符的无法正确识别。</p>\n<p>那些不标识<code>u</code>的特殊字符，在进行范围匹配时，有可能会转换为这样的形式<code>[&lt;55349&gt;&lt;56499&gt;-&lt;55349&gt;&lt;56500&gt;]</code>，这时的范围是<code>56499-55349</code>，左边的大于右边，区间错误，于是就会报错。</p>\n</li>\n<li>\n<p>如果想在方括号里匹配特殊字符，大多数的特殊字符可以转义也可以不转义，都会被正常识别，比如</p>\n<pre><code class=\"language-js\">let str = \'^.\\\\()-+/\'\n\n// 方括号中的部分特殊字符，无需转义也能正常获取到，不过反斜杠需要转义一下\nconsole.log(str.match(/[.\\\\()\\-+^]/g)); // [ \'^\', \'.\', \'\\\\\', \'(\', \')\', \'-\', \'+\' ]\n\n// 正常转义也是可以的\nconsole.log(str.match(/[\\.\\\\\\(\\)\\-\\+\\^]/g)); // [ \'^\', \'.\', \'\\\\\', \'(\', \')\', \'-\', \'+\' ]\n</code></pre>\n<p>注意：因为方括号中的<code>^</code>放开头，表示取反，<code>-</code>放中间表示范围，所以在匹配它俩的时候需要注意一下，如果想匹配开头的<code>^</code>就需要转义一下，同理匹配中间的<code>-</code>时也需要转义一下。</p>\n</li>\n<li>\n<p>因为<code>\\w</code>是简写的<code>[a-zA-Z0-9_]</code>，所以无法找到象形文字或者西里尔字母等，所以可以使用<code>unicode</code>的<code>\\p{}</code>属性，编写更通用的模式去匹配所有的文字字符，比如<code>[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}\\p{Join_C}]</code>。</p>\n<ol>\n<li><code>Alphabetic</code> (<code>Alpha</code>) —— 字母，</li>\n<li><code>Mark</code> (<code>M</code>) —— 重读，</li>\n<li><code>Decimal_Number</code> (<code>Nd</code>) —— 数字，</li>\n<li><code>Connector_Punctuation</code> (<code>Pc</code>) —— 下划线 <code>\'_\'</code> 和类似的字符，</li>\n<li><code>Join_Control</code> (<code>Join_C</code>) —— 两个特殊代码 <code>200c</code> and <code>200d</code>，用于连字，例如阿拉伯语。</li>\n</ol>\n</li>\n<li>\n<p><code>.</code>会匹配到所有的字符，除了换行符，即<code>\\n</code>或者<code>\\r\\n</code></p>\n<pre><code class=\"language-js\">let str2 = &quot;abc123 你好 \\n 𝒳𝒴 \\r\\n cc \\t 11 \\f 22 \\v 333&quot;\nconsole.log(str2.match(/.+/g)); // [ \'abc123 你好 \', \' 𝒳𝒴 \', \' cc \\t 11 \\f 22 \\x0B 333\' ]\n</code></pre>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-character-sets-and-ranges\">https://zh.javascript.info/regexp-character-sets-and-ranges</a></p>\n', '2021-12-06 11:59:02', '2021-12-09 10:32:57');
INSERT INTO `t_blog` VALUES ('dc2dbb30-5e72-11ec-b395-6d1b1a7579ec', '二叉树的先序、中序、后序遍历（概念）', '只给定二叉树的一种遍历序列，是无法唯一确定相应的二叉树。\n\n但是，如果知道了二叉树的**中序遍历**序列和**任意的另一种序列**，就可以**唯一的确定**这棵二叉树。', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 4, 0, 1, 2, 1, '', '<h2>二叉树的三种遍历方式</h2>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112162053539.png\" alt=\"image-20211216205307471\" /></p>\n<h3>先序遍历：根左右</h3>\n<p><code>A B D H E I C F J K G</code></p>\n<h3>中序遍历：左根右</h3>\n<p><code>D H B E I A J F K C G</code></p>\n<h3>后序遍历：左右根</h3>\n<p><code>H D I E B J K F G C A</code></p>\n<h2>一个结论</h2>\n<p>只给定二叉树的一种遍历序列，是无法唯一确定相应的二叉树。</p>\n<p>但是，如果知道了二叉树的<strong>中序遍历</strong>序列和<strong>任意的另一种序列</strong>，就可以<strong>唯一的确定</strong>这棵二叉树。</p>\n<h2>例子</h2>\n<h3>例子1 已知 中序遍历、先序遍历（可以确定）</h3>\n<p>中序遍历：<code>D H B E I A J F K C G</code></p>\n<p>先序遍历：<code>A B D H E I C F J K G</code></p>\n<ol>\n<li>先序遍历的根节点在第一个，所以可知 A 为根节点</li>\n<li>所以根据中序遍历<code>（D H B E I ）A（ J F K C G）</code>，得到了左子树和右子树</li>\n<li>先序遍历的第二个节点是 B ，所以左子树的根是 B，<code>(D H) B (E I)</code></li>\n<li>依次类推，就可以画出这棵唯一的树</li>\n</ol>\n<h3>例子2 已知 中序遍历、后序遍历（可以确定）</h3>\n<p>中序遍历：<code>D H B E I A J F K C G</code></p>\n<p>后序遍历：<code>H D I E B J K F G C A</code></p>\n<ol>\n<li>后序遍历的根节点在最后一个，所以可知 A 为根节点</li>\n<li>所以根据中序遍历<code>（D H B E I ）A（ J F K C G）</code>，得到了左子树和右子树</li>\n<li>后序遍历的倒数第二个节点是 C ，所以右子树的根是 C，<code>（J F K） C （G）</code></li>\n<li>依次类推，就可以画出这棵唯一的树</li>\n</ol>\n<h3>例子2 已知 先序遍历、后序遍历（无法确定）</h3>\n<p>这种情况无法确定这棵树长什么样，因为你只能确定根是什么，但是无法确定左子树和右子树</p>\n<h2>参考</h2>\n<p><a href=\"https://blog.csdn.net/qq_34840129/article/details/80619761\">二叉树的先序、中序、后序遍历序列</a></p>\n', '2021-12-16 21:19:55', '2021-12-17 16:35:13');
INSERT INTO `t_blog` VALUES ('e6f5d9b0-5109-11ec-96d5-7933aca11ca0', 'js中==与===', 'js中判断两个值是否相等，有两种方式，`==`和`===`，`==`并不是严格相等，会将左右两边的值做类型转换，所以会出现各种莫名其妙的情况。而`===`是严格意义上的相等，会进行类型比较，如果类型不同会直接返回`false`，类型一致了才会去比较值，只有真正的值相等了，才返回`true`。\n\n本篇文章就来彻底弄清楚`==`与`===`的区别。首先来看一些例子，测试一下自己的掌握情况。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 4, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>js中判断两个值是否相等，有两种方式，<code>==</code>和<code>===</code>，<code>==</code>并不是严格相等，会将左右两边的值做类型转换，所以会出现各种莫名其妙的情况。而<code>===</code>是严格意义上的相等，会进行类型比较，如果类型不同会直接返回<code>false</code>，类型一致了才会去比较值，只有真正的值相等了，才返回<code>true</code>。</p>\n<p>本篇文章就来彻底弄清楚<code>==</code>与<code>===</code>的区别。首先来看一些例子，测试一下自己的掌握情况。</p>\n<h3>一个小例子</h3>\n<ol>\n<li><code>==</code>\n<pre><code class=\"language-js\">console.log([10] == 10);                //true\nconsole.log(\'10\' == 10);                //true\nconsole.log([] == 0);                   //true\nconsole.log(true == 1);                 //true\nconsole.log([] == false);               //true\nconsole.log(![] == false);              //true\nconsole.log(\'\' == 0);                   //true\nconsole.log(\'\' == false);               //true\nconsole.log(null == false);             //false\nconsole.log(!null == true);             //true\nconsole.log(null == undefined);         //true\n\nlet a = Symbol(123)\nconsole.log(a == \'Symbol(123)\'); // false\nconsole.log(a == a); // true\nconsole.log(\'[object Object]\' == {}); // true\nconsole.log(\'1,2,3\' == [1, 2, 3]); // true\nconsole.log(\'\' == []); // true\n</code></pre>\n</li>\n<li><code>===</code>\n<pre><code class=\"language-js\">console.log(1 === \'1\'); // false\nconsole.log(undefined === undefined); // true\nconsole.log(null === null); // true\nconsole.log(\'abc\' === \'abc\'); // true\nconsole.log(true === true); // true\nconsole.log(false === false); // true\nconsole.log(true === false); // false\n\nlet a = Symbol(123)\nconsole.log(a === Symbol(123)); // false\nconsole.log(a === a); // true\n\nconsole.log(NaN === NaN); // false\nconsole.log(1 === NaN); // false\nconsole.log(1 === 1); // true\nconsole.log(0 === -0); // true\nconsole.log(+0 === -0); // true\n\nconsole.log([1, 2, 3] === [1, 2, 3]); // false\nconsole.log({} === {}); // false\n</code></pre>\n</li>\n</ol>\n<p><code>===</code>中的例子比较好理解，很容易就说出答案，但是<code>==</code>的就蒙圈了，先不管为什么，我们来学习一下它们的比较规则，学习完之后再逐个击破。</p>\n<h2><code>==</code></h2>\n<h3>规范</h3>\n<p>看一下<code>ECMAScript</code>对<code>==</code>符号的规范是怎么定义的（列的很清晰了）</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111291737448.png\" alt=\"image-20211129173756339\" /></p>\n<p>图片来自：<a href=\"https://262.ecma-international.org/5.1/#sec-11.9.1\">https://262.ecma-international.org/5.1/#sec-11.9.1</a></p>\n<h3>翻译成中文</h3>\n<p>比较<code>x==y</code>两个值，会返回一个<code>true</code>或<code>false</code>，比较规则如下：</p>\n<ol>\n<li>如果x和y类型相同\n<ol>\n<li>如果x是undefined，返回true</li>\n<li>如果x是null，返回true</li>\n<li>如果x是number，\n<ol>\n<li>如果x是NaN，返回false</li>\n<li>如果y是NaN，返回false</li>\n<li>如果x和y是相同的数值，返回true，不相同就返回false</li>\n<li>如果x是+0，y是-0，返回true</li>\n<li>如果x是-0，y是+0，返回true</li>\n<li>以上都不是时，返回false</li>\n</ol>\n</li>\n<li>如果x是string，当x和y里的字符都一样时，返回true，不一样就返回false</li>\n<li>如果x是boolean，如果x和y同时为true或者false时，返回true，不一样时返回false</li>\n<li>如果x和y存储着相同对象的引用时，返回true，不同就返回false</li>\n</ol>\n</li>\n<li>如果x是null，y是undefined，返回true</li>\n<li>如果x是undefined，y是null，返回true</li>\n<li>如果x是number，y是string，把y转换为number再比较</li>\n<li>如果x是string，y是number，把x转换为number再比较</li>\n<li>如果x是boolean，把x转换为number再比较</li>\n<li>如果y是boolean，把y转换为number再比较</li>\n<li>如果x是string或者number，y是object，把y转换为基本类型再比较</li>\n<li>如果x是object，y是string或者number，把x转换为基本类型再比较</li>\n<li>以上都不是，返回false</li>\n</ol>\n<h3>例子</h3>\n<p>了解完<code>==</code>比较的规范后，我们再来看一下这些示例就很清晰了，我们来分析一下：</p>\n<blockquote>\n<p>关于类型转换参考另一篇文章：<a href=\"http://www.bnbiye.cn/#/articleDetail/b86f6770-50ee-11ec-96d5-7933aca11ca0\">js中的类型转换</a></p>\n</blockquote>\n<ol>\n<li><code>console.log([10] == 10)</code>\n<pre><code class=\"language-js\">/*\n	x=[10]，是object，y=10，是number，类型不一样\n	将x转换为基本类型，[10] -&gt; \'10\'，此时 \n	x=\'10\'，是string，y=10，是number，类型不一样\n	将string转换为number，\'10\' -&gt; 10，此时\n	x=10，是number，y=10，是number，类型一样\n	10=10，返回true\n*/\nconsole.log([10] == 10);                //true\n</code></pre>\n</li>\n<li><code>console.log(\'10\' == 10)</code>\n<pre><code class=\"language-js\">/*\n	x=\'10\'，是string，y=10，是number，类型不一样\n	将string转换为number，\'10\' -&gt; 10，此时\n	x=10，是number，y=10，是number，类型一样\n	10==10，返回true\n*/\nconsole.log(\'10\' == 10);                //true\n</code></pre>\n</li>\n<li><code>console.log([] == 0)</code>\n<pre><code class=\"language-js\">/*\n	x=[]，是object，y=0，是number，类型不一样\n	将x转换为基本类型，[] -&gt; \'\'，此时 \n	x=\'\'，是string，y=0，是number，类型不一样\n	将string转换为number，\'\' -&gt; 0，此时\n	x=0，是number，y=0，是number，类型一样\n	0==0，返回true	\n*/\nconsole.log([] == 0);                   //true\n</code></pre>\n</li>\n<li><code>console.log(true == 1)</code>\n<pre><code class=\"language-js\">/*\n	x=true，是boolean，y=1，是number，类型不一样\n	将boolean转换为number，true -&gt; 1，此时\n	x=1，是number，y=1，是number，类型一样\n	1==1，返回true	\n*/\nconsole.log(true == 1);                 //true\n</code></pre>\n</li>\n<li><code>console.log([] == false)</code>\n<pre><code class=\"language-js\">/*\n	x=[]，是object，y=false，是boolean，类型不一样\n	将boolean转换为number，false -&gt; 0，此时 \n	x=[]，是object，y=0，是number，类型不一样\n	将x转换为基本类型，[] -&gt; \'\'，此时 \n	x=\'\'，是string，y=0，是number，类型不一样\n	将string转换为number，\'\' -&gt; 0，此时\n	x=0，是number，y=0，是number，类型一样\n	0==0，返回true	\n*/\nconsole.log([] == false);               //true\n</code></pre>\n</li>\n<li><code>console.log([] == false)</code>\n<pre><code class=\"language-js\">/*\n	x=[]，是object，y=false，是boolean，类型不一样\n	将x转换为基本类型，[] -&gt; \'\'，此时 \n	x=\'\'，是string，y=false，是boolean，类型不一样\n	将boolean转换为number，false -&gt; 0，此时\n	x=\'\'，是string，y=0，是number，类型不一样\n	将string转换为number，\'\' -&gt; 0，此时\n	0==0，返回true	\n*/\nconsole.log([] == false);               //true\n</code></pre>\n</li>\n<li><code>console.log(![] == false)</code>\n<pre><code class=\"language-js\">/*\n	x=![]，y=false，\n        ! 非运算符返回值是boolean类型，[]先隐式转换为true，所以!true 就 返回了false\n	x=false，是boolean，y=false，是boolean，类型一样\n	false==false，返回true\n*/\nconsole.log(![] == false);              //true\n</code></pre>\n</li>\n<li><code>console.log(\'\' == 0)</code>\n<pre><code class=\"language-js\">/*\n	x=\'\'，是string，y=0，是string，类型不一样\n	将string转换为number，\'\' -&gt; 0，此时\n	x=0，是number，y=0，是number，类型一样\n	0==0，返回true	\n*/\nconsole.log(\'\' == 0);                   //true\n</code></pre>\n</li>\n<li><code>console.log(\'\' == false)</code>\n<pre><code class=\"language-js\">/*\n	x=\'\'，是string，y=false，是boolean，类型不一样\n	将boolean转换为number，false -&gt; 0，此时\n	x=\'\'，是string，y=0，是number，类型不一样\n	将string转换为number，\'\' -&gt; 0，此时\n	x=0，是number，y=0，是number，类型一样\n	0==0，返回true	\n*/\nconsole.log(\'\' == false);               //true\n</code></pre>\n</li>\n<li><code>console.log(null == false)</code></li>\n</ol>\n<pre><code class=\"language-js\">/*\n	null == null 返回true\n	null == undefined 返回true\n	其它的全部返回false\n*/\nconsole.log(null == false);             //false\n</code></pre>\n<ol start=\"11\">\n<li><code>console.log(!null == true)</code></li>\n</ol>\n<pre><code class=\"language-js\">/*\n	!null 会变为 true\n	true == true 返回true\n*/\nconsole.log(!null == true);             //true\n</code></pre>\n<ol start=\"12\">\n<li><code>console.log(null == undefined)</code></li>\n</ol>\n<pre><code class=\"language-js\">/*\n	null == null 返回true\n	null == undefined 返回true\n	其它的全部返回false\n*/\nconsole.log(null == undefined);         //true\n</code></pre>\n<ol start=\"13\">\n<li>剩下的自己理解理解</li>\n</ol>\n<pre><code class=\"language-js\">/*\n	symbol与任何其它类型==比较都返回false，除了它自己返回true\n	{}对象转换为字符串会变为\'[object Object]\'\n	[]数组转换为字符串会变为 \'\'，空字符串\n	[1,2,3]转换为字符串会变为 \'1,2,3\'\n	NaN与任何值比较都会返回false\n*/\nlet a = Symbol(123)\nconsole.log(a == \'Symbol(123)\'); // false\nconsole.log(a == a); // true\nconsole.log(\'[object Object]\' == {}); // true\nconsole.log(\'1,2,3\' == [1, 2, 3]); // true\nconsole.log(\'\' == []); // true\nconsole.log(NaN == \'\'); // false\nconsole.log(NaN == NaN); // false\n</code></pre>\n<h3>小结</h3>\n<p><code>==</code>其实就是（简化版，自己理解）</p>\n<ol>\n<li>\n<p>当都是引用类型时，比较引用类型的地址，地址相当就相等</p>\n</li>\n<li>\n<p>当引用类型和基本类型比较时，引用类型转基本类型，然后再去比较</p>\n</li>\n<li>\n<p>基本类型与基本类型比较，类型相等时，</p>\n<ol>\n<li>undefind与undefined返回true</li>\n<li>null与null返回true</li>\n<li>相等的字符串返回true</li>\n<li>相等的数字返回true</li>\n<li>相等的布尔值返回true</li>\n<li>+0与-0返回true</li>\n<li>NaN与任何值比较都会返回false</li>\n</ol>\n</li>\n<li>\n<p>基本类型与基本类型比较，类型不相等时，</p>\n<ol>\n<li>null与undefined比较返回true（只有<code>null == null，null == undefined</code>返回<code>true</code>，其余的与<code>null</code>做<code>==</code>比较的都返回<code>false</code>）</li>\n<li>字符串与数字比较，字符串先转为数字，然后再比较</li>\n<li>布尔与字符串比较，布尔先转数字，然后再比较</li>\n<li>字符串与布尔比较，都先转换为数字，然后再比较</li>\n</ol>\n<p>（就是优先转换为数字，然后去比较）</p>\n</li>\n</ol>\n<blockquote>\n<p>类型转换参考另一篇文章：<a href=\"http://www.bnbiye.cn/#/articleDetail/b86f6770-50ee-11ec-96d5-7933aca11ca0\">js中的类型转换</a></p>\n</blockquote>\n<h2><code>===</code></h2>\n<h3>规范</h3>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111291913081.png\" alt=\"image-20211129191331014\" /></p>\n<p>图片来自：<a href=\"https://262.ecma-international.org/5.1/#sec-11.9.1\">https://262.ecma-international.org/5.1/#sec-11.9.1</a></p>\n<h3>翻译成中文</h3>\n<p>比较x===y，返回true或false，规则如下：</p>\n<ol>\n<li>如果x和y类型不一样，直接返回false</li>\n<li>如果都是undefined，返回true</li>\n<li>如果都是null，返回true</li>\n<li>如果都是number，\n<ol>\n<li>如果x是NaN，返回false</li>\n<li>如果y是NaN，返回false</li>\n<li>如果是相同的数字，返回true</li>\n<li>如果x是+0，y是-0，返回true</li>\n<li>如果x是-0，y是+0，返回true</li>\n<li>其余的都返回false</li>\n</ol>\n</li>\n<li>如果都是string，相同返回true，不同返回false</li>\n<li>如果都是boolean，相同返回true，不同返回false</li>\n<li>如果都是object，如果两个对象的引用相同，返回true，不相同返回false</li>\n</ol>\n<h3>例子</h3>\n<pre><code class=\"language-js\">// 类型不同，返回false\nconsole.log(1 === \'1\'); // false\n\n// 都是undefined，返回true\nconsole.log(undefined === undefined); // true\n\n// 都是null，返回true\nconsole.log(null === null); // true\n\n// 都是字符串\'abc\'，返回true\nconsole.log(\'abc\' === \'abc\'); // true\n\n/*\n	true === true 返回true\n	false === false 返回true\n	true === false 返回false\n*/\nconsole.log(true === true); // true\nconsole.log(false === false); // true\nconsole.log(true === false); // false\n\n/*\n	同一个symbol才会返回true\n	不同的就会返回false\n*/\nlet a = Symbol(123)\nconsole.log(a === Symbol(123)); // false\nconsole.log(a === a); // true\n\n/*\n	NaN与任何值比较都是false\n	+0与-0 返回true\n*/\nconsole.log(NaN === NaN); // false\nconsole.log(1 === NaN); // false\nconsole.log(1 === 1); // true\nconsole.log(0 === -0); // true\nconsole.log(+0 === -0); // true\n\n/*\n	只有是同一个对象时，才会返回true\n*/\nconsole.log([1, 2, 3] === [1, 2, 3]); // false\nconsole.log({} === {}); // false\n</code></pre>\n<h2>总结</h2>\n<p>==与===的区别如下：</p>\n<p>===比较时类型不一致会直接返回false，而==比较时，类型不一致会进行类型转换</p>\n<blockquote>\n<p><strong>==的转换规则如下（大致概括）:</strong></p>\n<ol>\n<li>都为引用类型时\n<ol>\n<li>会看它俩是否为同一份引用，引用相同时，返回true，不相同返回false</li>\n</ol>\n</li>\n<li>引用类型和基本类型时\n<ol>\n<li>会先将引用类型转换为基本类型，然后基本类型与基本类型比较</li>\n</ol>\n</li>\n<li>基本类型与基本类型\n<ol>\n<li>当类型相同时\n<ol>\n<li>undefined与undefined比较时，返回true</li>\n<li>null与null比较时，返回true</li>\n<li>string和string比较时，如果字符串全部一致时，返回true，不一致返回false</li>\n<li>number和number比较时，\n<ol>\n<li>如果有一个是NaN，返回false</li>\n<li>数值都相等时，返回true，数值不相等，返回false</li>\n<li>+0和-0比较时，返回true</li>\n</ol>\n</li>\n<li>当symbol比较时，同一个symbol返回true，不同的返回false</li>\n<li>当为bigint时，数值一样返回true，数值不同返回false</li>\n</ol>\n</li>\n<li>当类型不同时\n<ol>\n<li>undefined与null比较时，返回true</li>\n<li>string与number比较时，string先转换为number再进行比较</li>\n<li>boolean与number比较时，boolean先转换为number再比较</li>\n<li>string与boolean比较时，string和boolean都转换为数字再比较<br />\n（就是优先转换为number，然后再比较）</li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p><strong>===的转换规则如下（大致概括）:</strong></p>\n<ol>\n<li>类型不同时，直接返回false</li>\n<li>类型相同时，\n<ol>\n<li>都为引用类型时，比较它俩的引用地址，相同返回true，不同返回false</li>\n<li>都为undefined时，相同返回true，不同返回false</li>\n<li>都为null时，相同返回true，不同返回false</li>\n<li>都为string时，相同返回true，不同返回false</li>\n<li>都为number时，\n<ol>\n<li>如果有一个是NaN时，返回false</li>\n<li>相同的数值返回true，不同返回false</li>\n<li>+0和-0比较时返回true</li>\n</ol>\n</li>\n<li>都为bigint时，相同返回true，不同返回false</li>\n<li>都为symbol时，同一个symbol返回true，不同的返回false</li>\n</ol>\n</li>\n</ol>\n</blockquote>\n<blockquote>\n<p>tip：js中的类型是如何转换的，参考另一篇文章，<a href=\"http://www.bnbiye.cn/#/articleDetail/b86f6770-50ee-11ec-96d5-7933aca11ca0\">js中的类型转换</a></p>\n</blockquote>\n<h2>参考</h2>\n<p><a href=\"https://juejin.cn/post/6844903456407289869\">https://juejin.cn/post/6844903456407289869</a></p>\n<p><a href=\"https://262.ecma-international.org/5.1/#sec-11.9.1\">https://262.ecma-international.org/5.1/#sec-11.9.1</a></p>\n', '2021-11-29 19:45:51', '2021-11-30 09:24:57');
INSERT INTO `t_blog` VALUES ('ec46c330-5f22-11ec-b395-6d1b1a7579ec', '二叉树的BFS和DFS', 'BFS广度优先搜索，也叫层次遍历。DFS深度优先搜索。', '-1', 1, '', '33559e70-5cc3-11ec-96d5-7933aca11ca0', -1, 1, 0, 1, 2, 1, '', '<h2>BFC：广度优先搜索（又称之为 层次遍历、宽度优先搜索）</h2>\n<blockquote>\n<p>BFC：（Breadth First Search）</p>\n</blockquote>\n<blockquote>\n<p>他的访问顺序是：先访问上一层，在访问下一层，一层一层的往下访问</p>\n<p>所以下图BFS遍历的结果是：A→B→C→D→E→F</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171800403.png\" alt=\"image-20211217180028321\" /></p>\n</blockquote>\n<h3>代码实现：使用一个队列辅助</h3>\n<pre><code class=\"language-js\">let result = []\n\nfunction bfsOrder(tree) {\n    if (tree === null) return\n\n    let q = [] // 使用数组模拟队列 先进先出\n\n    q.push(tree)\n\n    // 开始一层一层遍历\n    while (q.length &gt; 0) {\n\n        // 挨个取出这一层的节点\n        let currentNode = q.shift() // 模拟队列的先进先出\n\n        result.push(currentNode.val)\n\n        // 继续遍历下一层\n        if (currentNode.left) {\n            q.push(currentNode.left)\n        }\n        if (currentNode.right) {\n            q.push(currentNode.right)\n        }\n    }\n}\n\n// 测试\nbfsOrder(A)\nconsole.log(result); // [ \'A\', \'B\', \'C\', \'D\', \'E\', \'F\' ]\n</code></pre>\n<h2>DFC：深度优先搜索</h2>\n<blockquote>\n<p>DFC：（Depth First Search）</p>\n<p>他的访问顺序是：先访根节点，然后左结点，一直往下，直到最左结点没有子节点的时候然后往上退一步到父节点，然后父节点的右子节点在重复上面步骤……</p>\n<p>所以下图深度优先搜索遍历的结果是：A→B→D→E→C→F</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202112171814263.png\" alt=\"image-20211217181401193\" /></p>\n</blockquote>\n<h3>代码实现 递归</h3>\n<pre><code class=\"language-js\">let result = []\n\nfunction dfsOrder(tree) {\n    if (tree === null) return\n\n    result.push(tree.val)\n    dfsOrder(tree.left)\n    dfsOrder(tree.right)\n\n}\n\n// 测试\ndfsOrder(A)\nconsole.log(result); // [ \'A\', \'B\', \'D\', \'E\', \'C\', \'F\' ]\n</code></pre>\n<h2>参考</h2>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzU0ODMyNDk0Mw==&amp;mid=2247487028&amp;idx=1&amp;sn=e06a0cd5760e62890e60e43a279a472b&amp;chksm=fb419d14cc36140257eb220aaeac182287b10c3cab5c803ebd54013ee3fc120d693067c2e960&amp;scene=21#wechat_redirect\">数据结构-6,树</a></p>\n', '2021-12-17 18:20:13', '2021-12-17 18:20:13');
INSERT INTO `t_blog` VALUES ('ef3306b0-581c-11ec-96d5-7933aca11ca0', '粘性标志 \"y\"，在位置处搜索', '正则表达式中的`y` 标志允许在源字符串中的指定位置执行搜索。', '-1', 2, 'https://zh.javascript.info/regexp-sticky', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 6, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>正则表达式中的<code>y</code> 标志允许在源字符串中的指定位置执行搜索。</p>\n<p>为了掌握 <code>y</code> 标志的用例，看看它有多好，让我们来探讨一个实际的用例。</p>\n<p>regexps 的常见任务之一是＂词法分析＂：比如我们在程序设计语言中得到一个文本，然后分析它的结构元素。</p>\n<p>例如，HTML 有标签和属性，JavaScript 代码有函数、变量等。</p>\n<p>编写词法分析器是一个特殊的领域，有自己的工具和算法，所以我们就不深究了，但有一个共同的任务：在给定的位置读出一些东西。</p>\n<p>例如，我们有一个代码字符串 <code>let varName = &quot;value&quot;</code>，我们需要从其中读取变量名，这个变量名从位置 <code>4</code> 开始。</p>\n<p>我们用 regexp <code>\\w+</code> 来查找变量名。实际上，JavaScript 的变量名需要更复杂的 regexp 来进行准确的匹配，但在这里并不重要。</p>\n<p>调用 <code>str.match(/\\w+/)</code> 将只找到该行中的第一个单词。或者是所有带标记 <code>g</code> 的单词。但我们只需要在位置 <code>4</code> 的一个词。</p>\n<p>要从给定位置搜索，我们可以使用方法 <code>regexp.exec(str)</code>。</p>\n<p>如果 <code>regexp</code> 没有标志 <code>g</code> 或 <code>y</code>，那么这个方法就可以寻找字符串 <code>str</code> 中的第一个匹配，就像 <code>str.match(regexp)</code> 一样。这种简单的无标志的情况我们在这里并不感兴趣。</p>\n<p>如果有标志 <code>g</code>，那么它就会在字符串 <code>str</code> 中执行搜索，从存储在 <code>regexp.lastIndex</code> 属性中的位置开始。如果发现匹配，则将 <code>regexp.lastIndex</code> 设置为匹配后的索引。</p>\n<p>当一个 regexp 被创建时，它的 <code>lastIndex</code> 是 <code>0</code>。</p>\n<p>因此，连续调用 <code>regexp.exec(str)</code> 会一个接一个地返回匹配。</p>\n<h2>例子</h2>\n<h3>例子1（不用标志<code>g</code>）</h3>\n<pre><code class=\"language-js\">let str = \'let varName\';\n\nlet regexp = /\\w+/;\n// 正则的lastIndex默认为0\nconsole.log(regexp.lastIndex); // 0\n\n// 不带g标志的exec和match方法返回的结果一样，返回第一个匹配的结果\nconsole.log(regexp.exec(str)); // [ \'let\', index: 0, input: \'let varName\', groups: undefined ]\n\n// 正则的lastIndex不会改变，扔然是0\nconsole.log(regexp.lastIndex); // 0\n</code></pre>\n<h3>例子2（用标志 <code>g</code> ）：</h3>\n<pre><code class=\"language-js\">let str = \'let varName\';\n\nlet regexp = /\\w+/g;\n// 带g标志的正则每次执行完一次exec方法后，如果有新的返回结果，就会更改lastIndex的值，初始时默认为0\nconsole.log(regexp.lastIndex); // 0（最初 lastIndex=0）\n\nlet word1 = regexp.exec(str);\nconsole.log(word1); // [ \'let\', index: 0, input: \'let varName\', groups: undefined ]\nconsole.log(word1[0]); // let（第一个单词）\nconsole.log(regexp.lastIndex); // 3（匹配后的位置）\n\nlet word2 = regexp.exec(str);\nconsole.log(word2); // [ \'varName\', index: 4, input: \'let varName\', groups: undefined ]\nconsole.log(word2[0]); // varName (第二个单词)\nconsole.log(regexp.lastIndex); // 11（匹配后的位置）\n\nlet word3 = regexp.exec(str);\nconsole.log(word3); // null（没有更多的匹配）\nconsole.log(regexp.lastIndex); // 0（搜索结束时重置）\n</code></pre>\n<p>每个匹配都会以数组形式返回，包含分组和附加属性。</p>\n<p>我们可以在循环中得到所有的匹配。</p>\n<pre><code class=\"language-js\">let str = \'let varName\';\nlet regexp = /\\w+/g;\n\nlet result;\n\nwhile (result = regexp.exec(str)) {\n    console.log(`Found ${result[0]} at position ${result.index}`);\n    // 在位置 0 发现 let, 然后\n    // 在位置 4 发现 varName\n}\n/*\nFound let at position 0\nFound varName at position 4\n*/\n</code></pre>\n<h2>``regexp.exec()<code>与标记</code>y`</h2>\n<h3><code>regexp.exec()</code></h3>\n<p><code>regexp.exec</code> 是 <code>str.matchAll</code> 方法的替代方法。</p>\n<p>与其他方法不同，我们可以设置自己的 <code>lastIndex</code>，从给定位置开始搜索。</p>\n<p>例如，让我们从位置 <code>4</code> 开始寻找一个单词。</p>\n<pre><code class=\"language-js\">let str = \'let varName = &quot;value&quot;\';\n\nlet regexp = /\\w+/g; // 如果没有标志 &quot;g&quot;，属性 lastIndex 会被忽略\n\n// 上来就可以设置从第几位开始查找\nregexp.lastIndex = 4;\n\nlet word = regexp.exec(str);\nconsole.log(word); // varName\n/*\n[\n  \'varName\',\n  index: 4,\n  input: \'let varName = &quot;value&quot;\',\n  groups: undefined\n]\n*/\n</code></pre>\n<p>我们从位置 <code>regexp.lastIndex = 4</code> 开始搜索 <code>w+</code>。</p>\n<p>请注意：搜索从位置 <code>lastIndex</code> 开始，然后再往前走。如果在 <code>lastIndex</code> 位置上没有词，但它在后面的某个地方，那么它就会被找到：</p>\n<pre><code class=\"language-js\">let str = \'let varName = &quot;value&quot;\';\n\nlet regexp = /\\w+/g;\n\nregexp.lastIndex = 3;\n\nlet word = regexp.exec(str);\nconsole.log(word[0]); // varName\nconsole.log(word.index); // 4\n</code></pre>\n<p>……所以，用标志 <code>g</code> 属性 <code>lastIndex</code> 设置搜索的起始位置。</p>\n<h3>标记<code>y</code></h3>\n<p>标记 <code>y</code> 使 <code>regexp.exec</code> 正好在 <code>lastIndex</code> 位置，而不是在它之前，也不是在它之后。</p>\n<p>下面是使用标志 <code>y</code> 进行同样的搜索。</p>\n<pre><code class=\"language-js\">let str = \'let varName = &quot;value&quot;\';\n\nlet regexp = /\\w+/y;\n\nregexp.lastIndex = 3;\nconsole.log(regexp.exec(str)); // null（位置 3 有一个空格，不是单词）\n\nregexp.lastIndex = 4;\nconsole.log(regexp.exec(str)); // varName（在位置 4 的单词）\n/*\n[\n  \'varName\',\n  index: 4,\n  input: \'let varName = &quot;value&quot;\',\n  groups: undefined\n]\n*/\n</code></pre>\n<p>我们可以看到，regexp <code>/\\w+/y</code> 在位置 <code>3</code> 处不匹配(不同于标志 <code>g</code> )，而是在位置 <code>4</code> 处匹配。</p>\n<p>想象一下，我们有一个长的文本，而里面根本没有匹配。那么用标志 <code>g</code> 搜索将一直到文本的最后，这将比用标志 <code>y</code> 搜索要花费更多的时间。</p>\n<p>在像词法分析这样的任务中，通常在一个确切的位置会有很多搜索。使用标志 <code>y</code> 是获得良好性能的关键。</p>\n<h2>总结</h2>\n<p>当想要在指定位置处搜索一个字符串时，可以对正则设置<code>lastIndex</code>属性，但是有以下注意点：</p>\n<ol>\n<li>\n<p>正则默认的<code>lastIndex</code>属性为<code>0</code></p>\n<pre><code class=\"language-js\">let str = `let name = &quot;cheny&quot; `\nlet reg = /\\w+/\nconsole.log(reg.lastIndex) // 0\nconsole.log(str.match(reg)); // [ \'let\', index: 0, input: \'let name = &quot;cheny&quot; \', groups: undefined ]\n</code></pre>\n</li>\n<li>\n<p>想要在执行位置处搜索，需搭配<code>reg.exec()</code>方法</p>\n<ol>\n<li>\n<p>当正则不带标志<code>g</code>时，<code>reg.exec()</code>方法和<code>str.match()</code>方法，表现一致，且正则的<code>lastIndex</code>属性会被忽略</p>\n<pre><code class=\"language-js\">let str = `let name = &quot;cheny&quot; `\nlet reg = /\\w+/\n\n// 如果正则表达式不带标志g时，reg.exec()方法和str.match()方法表现一致\nconsole.log(reg.lastIndex) // 0\nconsole.log(reg.exec(str)) // [ \'let\', index: 0, input: \'let name = &quot;cheny&quot; \', groups: undefined ]\nconsole.log(reg.lastIndex) // 0\n</code></pre>\n<pre><code class=\"language-js\">let str = `let name = &quot;cheny&quot; `\nlet reg = /\\w+/\n\nreg.lastIndex = 4 // 手动设置开始查找的位置，但是因为没有标记 g，并不会生效\nconsole.log(reg.lastIndex) // 4\n\n// 如果正则表达式不带标志g时，reg.exec()方法和str.match()方法表现一致\n// 因为没有带 标记 g， 设置的lastIndex并没有生效，仍然是从索引0开始查找的\nconsole.log(reg.exec(str)) // [ \'let\', index: 0, input: \'let name = &quot;cheny&quot; \', groups: undefined ]\nconsole.log(reg.lastIndex) // 4\n\nconsole.log(reg.exec(str)) // [ \'let\', index: 0, input: \'let name = &quot;cheny&quot; \', groups: undefined ]\n</code></pre>\n</li>\n<li>\n<p>当带标志<code>g</code>时，就可以在指定位置处搜索了</p>\n<pre><code class=\"language-js\">let str = `let name = &quot;cheny&quot; `\nlet reg = /\\w+/g \n\nconsole.log(reg.lastIndex) // 0 默认lastIndex为 0，也可以手动设置 \nconsole.log(reg.exec(str)) // [ \'let\', index: 0, input: \'let name = &quot;cheny&quot; \', groups: undefined ]\nconsole.log(reg.lastIndex) // 3\nconsole.log(reg.exec(str)) // [ \'name\', index: 4, input: \'let name = &quot;cheny&quot; \', groups: undefined ]\nconsole.log(reg.lastIndex) // 8\nconsole.log(reg.exec(str)) // [ \'cheny\', index: 12, input: \'let name = &quot;cheny&quot; \', groups: undefined ]\nconsole.log(reg.lastIndex) // 17\nconsole.log(reg.exec(str)) // null\nconsole.log(reg.lastIndex) // 0 返回null之后，lastIndex就又重新赋值为0了\n</code></pre>\n<pre><code class=\"language-js\">let str = `let name = &quot;cheny&quot; `\nlet reg = /\\w+/g\n// 如果不带标记 g lastIndex会被自动忽略\n\n// 手动设置lastIndex 设置从哪里开始查找\nreg.lastIndex = 1\nconsole.log(reg.lastIndex) // 1 所以被设置成1了，所以从1开始查找\nconsole.log(reg.exec(str)) // [ \'et\', index: 1, input: \'let name = &quot;cheny&quot; \', groups: undefined ]\n</code></pre>\n</li>\n<li>\n<p>标记<code>g</code>，会默认查找所有字符串，但是当我们只想查找一次，并且也想让<code>lastIndex</code>生效时（当不带<code>g</code>时，<code>lastIndex</code>会被自动忽略），所以这时候就可以使用标记<code>y</code>来代替，标记<code>y</code>，可以在指定索引处查找一次。</p>\n<pre><code class=\"language-js\">let str = `let name = &quot;cheny&quot; `\nlet reg = /\\w+/y\n// 如果不带标记 g lastIndex会被自动忽略\n// 但是标记 g 会默认匹配全部的字符串，但是我们不想把所有文本都匹配一遍，只想从设置的位置处查找一次，所以 g 标记就不满足需求了\n// 于是就出现了 标记 y ，可以在指定索引处查找一次\n\n// 手动设置lastIndex 设置从哪里开始查找\nreg.lastIndex = 3\nconsole.log(reg.lastIndex) // 3 初始查找索引被设置成3了，所以从3开始查找\nconsole.log(reg.exec(str)) // null 索引3的位置是空格，没有匹配到\\d规则，y 标记不会继续往下找了 直接就返回null（这就是与 g 标记的区别，如果是g标记会继续往下找）\nconsole.log(reg.lastIndex) // 0 返回null之后，lastIndex就又重新赋值为0了\n</code></pre>\n<pre><code class=\"language-js\">let str = `let name = &quot;cheny&quot; `\nlet reg = /\\w+/y\n// 如果不带标记 g lastIndex会被自动忽略\n// 但是标记 g 会默认匹配全部的字符串，但是我们不想把所有文本都匹配一遍，只想从设置的位置处查找一次，所以 g 标记就不满足需求了\n// 于是就出现了 标记 y ，可以在指定索引处查找一次\n\n// 手动设置lastIndex 设置从哪里开始查找\nreg.lastIndex = 4\nconsole.log(reg.lastIndex) // 4 初始查找索引被设置成4了，所以从4开始查找\nconsole.log(reg.exec(str)) // [ \'name\', index: 4, input: \'let name = &quot;cheny&quot; \', groups: undefined ]\nconsole.log(reg.lastIndex) // 8\nconsole.log(reg.exec(str)) // null 索引8 的位置是空格，不满足规则，所以返回null\nconsole.log(reg.lastIndex) // 返回null之后，lastIndex就又重新赋值为0了\n</code></pre>\n</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/regexp-sticky\">https://zh.javascript.info/regexp-sticky</a></p>\n', '2021-12-08 19:49:43', '2021-12-08 19:49:43');
INSERT INTO `t_blog` VALUES ('f0f3fbe0-2cbf-11ec-86ae-0da8227970f6', '手写一个Promise', '手写一个符合Promise A+ 规范的类', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 36, 1, 1, 2, 1, 'http://82.156.76.49:20517/upload/png/2021-10-14/d68e52f0-2cbf-11ec-86ae-0da8227970f6.png', '<h2>规范</h2>\n<h3>Promise States</h3>\n<p>promise有三种状态</p>\n<ol>\n<li>\n<p>pending</p>\n<p>1.1 初始状态，可改变</p>\n<p>1.2 一个promise在resolve或者rejected前都处于这个状态</p>\n<p>1.3 可以通过 resolve -&gt; fulfilled 状态</p>\n<p>1.4 可以通过 reject -&gt; rejected 状态</p>\n</li>\n<li>\n<p>fulfilled</p>\n<p>1.1 最终态，不可改变</p>\n<p>1.2 一个promise被resolve后改变成这个状态</p>\n<p>1.3 必须拥有一个value值，</p>\n<p>（注意：如果直接resolve()，那么这个value值是undefined ）</p>\n</li>\n<li>\n<p>rejected</p>\n<p>1.1 最终态，不可改变</p>\n<p>1.2 一个promise被rejected后改变成这个状态</p>\n<p>1.3 必须拥有一个reason值，</p>\n<p>（注意：如果直接reject()，那么这个value值是undefined ）</p>\n</li>\n</ol>\n<blockquote>\n<p>Tips：总结一下就是，promise的状态流转是这样的</p>\n<p>pending -&gt; resolve(value) -&gt; fulfilled</p>\n<p>pending -&gt; reject(reason) -&gt; rejected</p>\n</blockquote>\n<h2>一步一步实现promise</h2>\n<h3>第一步：先有一个类MyPromise</h3>\n<p>肯定需要先有一个类，因为平时使用promise的时候，都是 new Promse(...)，所以第一步，先声明一个类，这里我们叫<code>MyPromise</code>，在构造方法中，有三个属性，<code>status</code>，<code>value</code>，<code>reason</code></p>\n<pre><code class=\"language-js\">// 声明状态常量\nconst PENDING = \'pending\' // 默认状态\nconst FULFILLED = \'fulfilled\' // resolve()之后的状态 \nconst REJECTED = \'rejected\' // reject() 之后的状态\n\n\nclass MyPromise {\n    constructor() {\n        this.status = PENDING // 默认状态\n        this.value = null\n        this.reason = null\n    }\n}\n</code></pre>\n<h3>第二步：构造器增加参数<code>fn</code></h3>\n<p>是不是少了点啥，平时使用promise时，<code>new Promise((resolve, reject)=&gt;{})</code>，构造方法接收的参数是一个函数，没有错，少的就是参数，我们把参数加上</p>\n<pre><code class=\"language-js\">class MyPromise {\n    constructor(fn) {\n        this.status = PENDING // 默认状态\n        this.value = null\n        this.reason = null\n        // 在Promise A+ 规范中 在初始化promise的时候，就需要执行这个函数，所以我们直接执行一下\n        fn()\n    }\n}\n</code></pre>\n<p>在执行函数<code>fn</code>时，需要处理一下参数<code>resolve</code>和<code>reject</code>，并且需要注意执行<code>fn</code>的时候，并不确定这个函数里面有什么逻辑，可能会有错误，所以应该使用try...catch...包裹一下，改造后如下</p>\n<pre><code class=\"language-js\">class MyPromise {\n    constructor(fn) {\n        this.status = PENDING // 默认状态\n        this.value = null\n        this.reason = null\n        /**\n         * 注意：在初始化promise的时候，就需要执行这个函数，并且有任何报错都要通过reject抛出去\n         *  所以，执行的时候用try...catch...包裹一下，使用bind绑定当前的this，防止出现乱起八糟的情况\n         */\n        try {\n            fn(this.resolve.bind(this), this.reject.bind(this))\n        } catch (e) {\n            this.reject(e) // 报错的时候，直接reject\n        }\n    }\n    \n    // 状态由pending-&gt;fulfilled\n    resolve(value) {}\n    \n    // 状态由pending-&gt;rejected\n    reject(reason) {}\n}\n</code></pre>\n<h3>第三步：<code>resolve</code>和<code>reject</code>方法</h3>\n<p>上面我们已经处理过了入参<code>fn</code>，接下来就应该着重看一下<code>fn</code>的两个参数<code>resolve</code>和<code>reject</code>，这两个参数，其实就是promise的两个回调函数，用来改变状态和返回结果，我们来写一下这两个函数的逻辑</p>\n<pre><code class=\"language-js\">class MyPromise {\n    constructor(fn) {/** ... */}\n    \n    // 参数value是外界给传过来的\n     /**\n     * @description promise的resolve，成功时执行\n     * 做了两件事\n     *  1、设置自己的 value\n     *  2、将状态改为 FULFILLED\n     * 状态有两种流转方式，所以只有当前状态是 PENDING 时才允许改变，一旦改变不可逆\n     *  pending -&gt; resolve(value) -&gt; fulfilled    \n     *  pending -&gt; reject(reason) -&gt; rejected\n     * \n     * @param {*} value 从外面传过来的值，可以是任意类型\n     */\n    resolve(value) {\n        if (this.status === PENDING) {\n            this.value = value\n            this.status = FULFILLED\n        }\n    }\n    // 参数reason是外界给传过来的\n    reject(reason) {\n        if (this.status === PENDING) {\n            this.reason = reason\n           	this.status = REJECTED\n        }\n    }\n    \n	/**\n     * 比如我们封装一个jQuery ajax请求时（就简单的做个比方）\n     * getData(){\n     *  return new Promise((resolve, reject)=&gt;{\n     *      $.ajax(\n     *          url: \'xxx\',\n     *          success: function(data){\n     *              // 这里就拿到了这个data，然后就可以执行promise的回调resolve将这个结果返回出去\n     *			   // 这时就触发了Promise的resolve回调，\n     *              resolve(data)\n     *          },\n     *          error: function(error){\n     *              // 失败就可以reject出去这个错误\n     *              reject(error)\n     *          },\n     * \n     *      )\n     *  })\n     * }\n     * \n     */\n}\n</code></pre>\n<h3>第四步：<code>then(onFulfilled, onRejected)</code>方法</h3>\n<p>接下来我们就开始研究一下这个then方法了，在平常使用promise时，<code>return new Promise().then(fn1,fn2)</code>，<code>.then</code>方法接收两个参数，第一个参数是成功时的回调，第二个是失败时的回调，注意，这两个回调只会执行一个（咱举个例子试试）</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/338494a2c8ce4ff0b7c0f96ed0dc9d89~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20210928234313934.png\" /></p>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1434477e72eb409dab6567d1a0086d6e~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20210928234534427.png\" /></p>\n<p>不管怎么试，最后的结果都是一样的，这两个回调，只会执行一个，所以咱开始写一下then函数</p>\n<pre><code class=\"language-js\">class MyPromise {\n    constructor(fn) {/** ... */}\n    \n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n    \n    /**\n     * onFulfilled 成功时的回调，外面传过来的\n     * onRejected 失败时的回调，外面传过来的\n     * 还拿刚才封装的ajax请求来说，我们把服务器数据拿过来之后，就可以做我们想做的事了\n     * getData().then(\n     *  (value)=&gt;{\n     *      // 数据拿到了，做我们想做的事\n     *      this.xxxData = value\n     *  },\n     *  (reason)=&gt;{\n     *      // 失败的回调，这时候我们一般会弄个弹窗，提示一下用户出了什么错\n     *      // 比如，网络超时、断网、未授权、等等等等\n     *  }\n     * )\n     * \n     *   \n     */\n    then(onFulfilled, onRejected) {\n        // 调用完then方法，返回值仍然是一个promise，所以我们再new一个promise2，用来返回，这样就达到了链式调用的效果\n        // .then().then().then().then().then().... 想多少都行，无穷无尽的链式操作\n        const promise2 = new MyPromise((resolve, reject) =&gt; { \n            switch (this.status) {\n                // 状态为 FULFILLED 时，调用一下成功的回调\n                case FULFILLED:\n                    onFulfilled()\n                    break;\n\n                // 状态为 REJECTED 时，调用一下失败的回调    \n                case REJECTED:\n                    onRejected()\n                    break;\n\n                // 状态为 PENDING 时，怎么办？？？？？下一步再我们再研究\n                case PENDING:\n                    // ...下一步再再研究\n                    break;\n            }\n        })\n        return promise2\n    }\n}\n</code></pre>\n<h3>第五步：分析<code>promise</code>的两种调用方式</h3>\n<p>（分析）众所周知，我们在使用<code>promise</code>时，一般会有两种调用方式</p>\n<ul>\n<li>方式一：直接在刚声明的<code>promise</code>对象链式调用<code>then</code>方法，这种链式调用，当结果被<code>resolve</code>后，会自动触发<code>then</code>方法的回调，所以会把<code>resolve</code>的结果打印出来（reject同理），比如\n<pre><code class=\"language-js\">const test = new Promise((resolve, reject)=&gt;{\n    setTimeout(()=&gt;{\n       resolve(111) \n    }, 1000)\n    // 直接链式调用，刚声明出来就调用，如果状态是fulfilled或者rejected时，会自动触发对应的回调，然后就可以在回调函数里操作我们其他的业务逻辑\n}).then((value)=&gt;{\n    console.log(value)\n    console.log(test)\n})\n</code></pre>\n</li>\n<li>方式二：同步调用<code>then</code>方法，先声明，然后同步调用，同步调用的时候，resolve的结果由于延迟了一秒才会执行，所以在同步执行<code>then</code>方法的时候，所有的状态都是pending，这时候就需要考虑两件事了，（1）调用<code>then</code>方法时，是pending状态怎么处理？（2）如何监听到状态的改变，然后去触发<code>then</code>方法对应的回调函数？\n<pre><code class=\"language-js\">const test = new Promise((resolve, reject)=&gt;{\n    setTimeout(()=&gt;{\n       resolve(111) \n    }, 1000)\n    // 直接链式调用，刚声明出来就调用\n})\n\ntest.then((value)=&gt;{console.log(value)})\ntest.then((value)=&gt;{console.log(value)})\ntest.then((value)=&gt;{console.log(value)})\ntest.then((value)=&gt;{console.log(value)})\n\nconsole.log(test)\n</code></pre>\n</li>\n</ul>\n<h3>第六步：改写<code>then</code>方法，使用<code>getter</code>和<code>setter</code>监听状态的改变</h3>\n<p>所以针对第四步的问题，和第五步分析中考虑的两个问题，来继续改写我们的代码，</p>\n<ul>\n<li>\n<p>对于第五步的第一个问题，（1）调用<code>then</code>方法时，是pending状态怎么处理？</p>\n<p>可以声明两个数组，将未执行的回调先存起来，等到状态改变时，再挨个从数组拿出来执行一遍。</p>\n</li>\n<li>\n<p>对于第五步的第二个问题，（2）如何监听到状态的改变，然后去触发<code>then</code>方法对应的回调函数？</p>\n<p>可以使用es6中的getter和setter来监听constructor中属性值变化，显示的声明出getter和setter方法，然后就可以从缓存回调的数组中取出回调函数，挨个执行一遍，这正好应对了步骤五中的方式二，当我们同步的调用<code>then</code>方法时，同一个promise同步调用多次<code>then</code>，每次调用时，状态都是pending，这时就将回调函数存缓存数组中，在状态发生改变时，在挨个执行，执行顺序与注册时的顺序正好是一致的</p>\n</li>\n</ul>\n<pre><code class=\"language-js\">// 声明状态常量\n/** ... */\n\nclass MyPromise {\n    // 声明两个私有数组，缓存状态未执行的回调函数\n    FULFILLED_CALLBACK_LIST = []\n    REJECTED_CALLBACK_LIST = []\n    /**\n     * 定义私有变量 _status，其对应的属性是构造器中的status\n     * 在使用getter、setter监听status时，我们操控 _status\n     * 防止死循环\n     * （\n     *      如果不用一个私有变量存储，那么在每次 对 status进行赋值和取值的操作时，\n     *      都会调用 setter和getter，这样就又是一波 赋值取值操作，然后就继续调用 setter和getter，\n     *      如此循环往复，成了死循环。\n     *      \n     *      但是，当使用 _status 私有变量成员时，_status 并不会被getter、setter监听，所以就避免了死循环\n     *      \n     *  ）\n     */\n    _status = PENDING\n\n    constructor(fn) {/** ... */}\n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n\n    /**\n     * 监听状态的改变，如果变成了fulfilled或者rejected，\n     * 就从缓存回调事件的数组中，把该执行的回调挨着执行一遍\n     */\n    set status(newStatus) {\n        this._status = newStatus\n        switch (newStatus) {\n            case FULFILLED:\n                this.FULFILLED_CALLBACK_LIST.forEach(callback =&gt; {\n                    callback(this.value)\n                });\n                break;\n            case REJECTED:\n                this.REJECTED_CALLBACK_LIST.forEach(callback =&gt; {\n                    callback(this.reason)\n                });\n                break;\n        }\n    }\n	\n	// \n    get status() {\n        return this._status\n    }\n\n    then(onFulfilled, onRejected) {\n        const promise2 = new MyPromise((resolve, reject) =&gt; {\n            switch (this.status) {\n                /** .... */\n                case PENDING:\n                    // 状态为 PENDING 时，我们就先把回调存起来，等状态改变之后再拿出来执行\n                    this.FULFILLED_CALLBACK_LIST.push(onFulfilled)\n                    this.REJECTED_CALLBACK_LIST.push(onRejected)\n                    break;\n            }\n        })\n        return promise2\n    }\n}\n</code></pre>\n<h3>第七步：<code>then</code>方法参数校验，<code>queueMicrotask</code>包裹回调方法，转换到微任务队列</h3>\n<p>接下来继续完善<code>then</code>方法，先完善三个地方</p>\n<ul>\n<li>（1）<code>then(onFulfilled, onRejected)</code>，<code>then</code>方法中的<code>onFulfilled</code>和<code>onRejected</code>是从外部接收的，需要校验参数，期望是函数</li>\n<li>（2）<code>onFulfilled, onRejected</code>，函数的执行必需在微任务中，这里简单的使用<code>queueMicrotask</code>函数包裹一下</li>\n<li>（3）<code>onFulfilled, onRejected</code>，函数的执行过程中，可能会报错，毕竟我们也不知道外部传过来的函数里面都会执行哪些业务，会报错很正常，所以需要使用<code>try...catch...</code>包裹一下，假如有报错，直接把错误<code>reject(e)</code>出去</li>\n</ul>\n<pre><code class=\"language-js\">// 声明状态常量\n/** ... */\nclass MyPromise {\n    /** ... */\n    constructor(fn) {/** ... */}\n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n    get status() {/** ... */}\n    set status(newStatus) {/** ... */}\n\n    then(onFulfilled, onRejected) {\n        /**\n         * 校验 onFulfilled, onRejected\n         * 如果是函数，就还用自己\n         * 如果不是函数，我们就忽略，给个默认的函数\n         */\n        const realOnFulfilled = this.isFunction(onFulfilled) ? onFulfilled : (value) =&gt; {\n            // 给的默认函数需要有返回值，为什么需要有呢？在下面的步骤会给出分析\n            return value\n        }\n        const realOnRejected = this.isFunction(onRejected) ? onRejected : (reason) =&gt; {\n            throw reason\n        }\n\n        const promise2 = new MyPromise((resolve, reject) =&gt; {\n            // 使用queueMicrotask改造成微任务\n            const fulfilledMicrotask = () =&gt; {\n                queueMicrotask(() =&gt; {\n                    // 使用catch包裹，一旦出错就reject出去\n                    try {\n                        realOnFulfilled(this.value)\n                    } catch (e) {\n                        reject(e)\n                    }\n                })\n            }\n\n            // 使用queueMicrotask改造成微任务\n            const rejectedMicrotask = () =&gt; {\n                queueMicrotask(() =&gt; {\n                    // 使用catch包裹，一旦出错就reject出去\n                    try {\n                        realOnRejected(this.reason)\n                    } catch (e) {\n                        reject(e)\n                    }\n                })\n            }\n\n            switch (this.status) {\n                case FULFILLED:\n                    // 此处改为调用对应的微任务\n                    fulfilledMicrotask()\n                    break;\n                case REJECTED:\n                    // 此处改为调用对应的微任务\n                    rejectedMicrotask()\n                    break;\n                case PENDING:\n                    // 此处缓存数组改为存微任务\n                    this.FULFILLED_CALLBACK_LIST.push(fulfilledMicrotask)\n                    this.REJECTED_CALLBACK_LIST.push(rejectedMicrotask)\n                    break;\n            }\n        })\n        return promise2\n    }\n\n    // 判断参数是否为函数\n    isFunction(param) {\n        return typeof param === \'function\'\n    }\n}\n</code></pre>\n<h3>第八步：分析<code>then(onFulfilled, onRejected)</code>方法中回调方法的返回值，抛出疑问，声明<code>resolvePromise(promise2, x, resolve, reject)</code>方法</h3>\n<p>我们继续分析，除了第七步考虑的三点外，还有一个很重要的点需要考虑，在调用<code>then(onFulfilled, onRejected)</code>方法时，外部传来的函数<code>onFulfilled, onRejected</code>，很可能会有返回值，并且返回值会有很多种类型，先来抛出几点疑惑，</p>\n<ul>\n<li>（1）如果返回值仍然是一个<code>promise</code>怎么处理？</li>\n<li>（2）如果返回值是一个对象或者函数怎么处理？</li>\n<li>（3）返回值就不是<code>promise</code>，也不是对象或者函数，那么就只能是基本类型了，这时候又怎么处理？</li>\n</ul>\n<p>在这步我们先不管怎么处理，我们先把问题抛出来，写个处理的方法去处理，在第九步在专心考虑怎么处理这几种情况，所以接着第七步代码改写</p>\n<pre><code class=\"language-js\">// 声明状态常量\n/** ... */\n\nclass MyPromise {\n    /** ... */\n    constructor(fn) {/** ... */}\n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n    get status() {/** ... */}\n    set status(newStatus) {/** ... */}\n    \n    then(onFulfilled, onRejected) {\n        /** ... */\n        const promise2 = new MyPromise((resolve, reject) =&gt; {\n            const fulfilledMicrotask = () =&gt; {\n                queueMicrotask(() =&gt; {\n                    try {\n                        // 返回值我们定义为 x\n                        const x = realOnFulfilled(this.value)\n                        /**\n                         * 处理返回值的方法，我们定义为 resolvePromise\n                         * \n                         * 为什么参数会多传递个 当前的返回值promise2呢？\n                         *  这是因为当返回值 x 也是一个Promise时，\n                         *      把自己.then返回的promise2也传递过去，为了校验 x === promise2的情况，\n                         *      如果它俩完全是同一个promise，会导致死循环\n                         * */\n                        this.resolvePromise(promise2, x, resolve, reject)\n                    } catch (e) {\n                        reject(e)\n                    }\n                })\n            }\n            const rejectedMicrotask = () =&gt; {\n                queueMicrotask(() =&gt; {\n                    try {\n                        // 返回值我们定义为 x\n                        const x = realOnRejected(this.reason)\n                        // 处理返回结果\n                        this.resolvePromise(promise2, x, resolve, reject)\n                    } catch (e) {\n                        reject(e)\n                    }\n                })\n            }\n         	/** ... */\n        })\n        return promise2\n    }\n\n    // 处理回调函数中的返回值，会有大量的if操作，因为有很多种情况，都应该考虑到\n    resolvePromise(promise2, x, resolve, reject) {\n\n    }\n    \n    isFunction(param) {/** ... */}\n}\n</code></pre>\n<h3>第九步：剖析<code>resolvePromise(promise2, x, resolve, reject)</code>方法</h3>\n<p>接着第八步抛出的疑惑，开始完善<code>resolvePromise(promise2, x, resolve, reject)</code>方法的判断逻辑框架，由外到里，一点点剖析，分析得知，外部有四个<code>if</code>判断</p>\n<ul>\n<li>\n<p>（1）如果<code>promise2 === x</code>，即，调用<code>.then()</code>方法得到的<code>promise</code>与执行完回调函数的返回值<code>x</code>是同一个<code>promise</code>，这显然是不合常理的，因为遵循<code>Promise A+</code>规范的链式操作<code>.then().then().then().then()...</code>，每次<code>.then()</code>返回的结果都是一个新的<code>promise</code>对象，如果调用完某一个回调后，比如</p>\n<pre><code class=\"language-js\">let test = new Promise((resolve, reject)=&gt;{\n    resolve(111)\n}).then(\n	()=&gt;{\n        // 假设执行完这个回调后，由于一些意外的操作，返回值 x 与 执行完.then()后的返回值 是同一个promise\n        // return promise2\n    }\n)\n</code></pre>\n<p>这样的话会导致死循环，因为如果相等的话就会按照返回值是<code>promise</code>来处理，会继续执行它的<code>then()</code>方法来递归解析返回值，但是每次返回的<code>x</code>都是这个<code>promise</code>，因而就导致了死循环，所以在最初阶段就需要判断一下，如果<code>x === promise2</code>，那么直接抛出类型异常。</p>\n</li>\n<li>\n<p>（2）如果<code>x instanceof MyPromise</code>，即，执行完回调的返回值<code>x</code>仍然是一个<code>promise</code>，比如下面这个例子，可以看出来，<code>.then()</code>返回的<code>promise</code>继承了<code>x</code>的状态和结果，具体怎么实现，待会再看</p>\n<pre><code class=\"language-js\">let test = new Promise((resolve, reject)=&gt;{\n    resolve(111)\n}).then(\n	(value)=&gt;{\n        console.log(value)\n        // 假设执行完这个回调后，又返回了一个Promise\n        // \n        return new Promise((resolve, reject)=&gt;{\n            resolve(222)\n        })\n    }\n)\n</code></pre>\n</li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d98013276a824755a5990681ba60c611~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20210929135310368.png\" /></p>\n<ul>\n<li>\n<p>（3）如果回调的返回值<code>x</code>是一个对象或者是方法，类似于下面这个例子</p>\n<pre><code class=\"language-js\">let test = new Promise((resolve, reject)=&gt;{\n    resolve(111)\n}).then(\n	(value)=&gt;{\n        console.log(value)\n        // 假设执行完这个回调后，又返回了一个对象\n        // \n        return {\n            a: \'aaa\',\n            b: \'bbb\'\n        }\n    }\n)\ntest.then(console.log)\n</code></pre>\n<pre><code class=\"language-js\">let test = new Promise((resolve, reject)=&gt;{\n    resolve(111)\n}).then(\n	(value)=&gt;{\n        console.log(value)\n        // 假设执行完这个回调后，又返回了一个对象\n        // \n        return {\n            a: \'aaa\',\n            b: \'bbb\',\n            then: \'ccc\'\n        }\n    }\n)\ntest.then(console.log)\n</code></pre>\n<pre><code class=\"language-js\">let test = new Promise((resolve, reject)=&gt;{\n    resolve(111)\n}).then(\n	(value)=&gt;{\n        console.log(value)\n        // 假设执行完这个回调后，又返回了一个对象\n        // \n        return {\n            a: \'aaa\',\n            b: \'bbb\',\n            then: (resolve, reject)=&gt;{\n                resolve(2222)\n            }\n        }\n    }\n)\ntest.then(console.log)\n</code></pre>\n</li>\n</ul>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/859a7c29999a45cb8d2eed23b3a90046~tplv-k3u1fbpfcp-watermark.image?\" alt=\"image-20210929150528467.png\" /></p>\n<pre><code>```js\nlet test = new Promise((resolve, reject)=&gt;{\n    resolve(111)\n}).then(\n	(value)=&gt;{\n        console.log(value)\n        // 假设执行完这个回调后，又返回了一个方法\n        // \n        return ()=&gt;{\n            console.log(2222)\n        }\n  }\n)\ntest.then(console.log)\n</code></pre>\n<p>运行完这几个例子，会发现，如果是对象，会找对象里有没有一个属性是<code>then</code>，看看符不符合<code>promise A+</code>中的then()方法的规范，即，<code>then((resolve, reject)=&gt;{resolve(1111)})</code>，类似这样的方法，可以传成功回调和失败回调，如果有就会继承，没有的话就返回原结果<code>x</code>。</p>\n<p>这里有点绕，待会直接看代码理解一下，记得把例子敲一下试试。</p>\n<pre><code>- （4）排除以上条件，剩下的只能是基本类型，如果是基本数据类型，直接返回结果\n\n### 第十步：实现`resolvePromise(promise2, x, resolve, reject)`方法，解析回调函数返回的结果`x`\n\n第九步已经将所有的条件都分析了一遍，现在开始写第八步解析回调结果`x`的方法`resolvePromise(promise2, x, resolve, reject)`\n\n```js\n// 声明状态常量\n/** ... */\n\nclass MyPromise {\n    /** ... */\n\n    constructor(fn) {/** ... */}\n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n    get status() {/** ... */}\n    set status(newStatus) {/** ... */}\n\n    then(onFulfilled, onRejected) {\n        /** ... */\n        const promise2 = new MyPromise((resolve, reject) =&gt; {\n            const fulfilledMicrotask = () =&gt; {\n                queueMicrotask(() =&gt; {\n                    try {\n                        // 返回值我们定义为 x\n                        const x = realOnFulfilled(this.value)\n                        this.resolvePromise(promise2, x, resolve, reject)\n                    } catch (e) {\n                        reject(e)\n                    }\n                })\n            }\n            const rejectedMicrotask = () =&gt; {\n                queueMicrotask(() =&gt; {\n                    try {\n                        // 返回值我们定义为 x\n                        const x = realOnRejected(this.reason)\n                        // 处理返回结果\n                        this.resolvePromise(promise2, x, resolve, reject)\n                    } catch (e) {\n                        reject(e)\n                    }\n                })\n            }\n         	/** ... */\n        })\n        return promise2\n    }\n\n    // 处理回调函数中的返回值，会有大量的if操作，因为有很多种情况，都应该考虑到\n    resolvePromise(promise2, x, resolve, reject) {\n        // 1、如果 .then()返回的promise 和 执行完回调返回值是同一个promise\n        if (x === promise2) {\n            // 不能相等，如果相等会死循环，应保证每次执行完返回的promise的唯一性\n            return reject(new TypeError(\'The promise and the return value are the same\'))\n        }\n\n        // 2、如果返回值x是promise\n        if (x instanceof MyPromise) {\n            // 微任务中执行，继续解析Promise\n            queueMicrotask(() =&gt; {\n                x.then(\n                    (y) =&gt; {\n                        // 递归解析，一直解析成其他情况为止\n                        this.resolvePromise(promise2, y, resolve, reject)\n                    },\n                    reject,\n                )\n            })\n        } else if (typeof x === \'object\' || this.isFunction(x)) { // 3、如果返回值是对象或者函数\n            // 先判断是不是null\n            if (x === null) {\n                return resolve(x) // 直接返回结果\n            }\n\n            // 在看看对象里有没有符合promise规范的then方法\n            let then = null\n            try {\n                // 把这个then 取出来，万一报错了，直接reject出去\n                then = x.then\n            } catch (e) {\n                reject(e)\n            }\n\n            if (this.isFunction(then)) {\n                // 成功和失败的回调只能调用一个\n                let called = false\n                // 执行方法的时候包裹一个try..catch... 捕获方法里的异常\n                try {\n                    // 如果是x.then是function\n                    then.call(\n                        x,\n                        (y) =&gt; {\n                            if (called) return\n                            called = true\n                            // 继续解析返回的结果\n                            this.resolvePromise(promise2, y, resolve, reject)\n                        },\n                        (r) =&gt; {\n                            if (called) return\n                            called = true\n                            // 直接reject回去\n                            reject(r)\n                        }\n                    )\n                } catch (e) {\n                    if (called) return\n                    called = true\n                    // 直接reject回去\n                    reject(r)\n                }\n            } else { // x是对象，且x.then不是function || x直接就是一个function\n                resolve(x) // 直接resolve出去\n            }\n        } else { // 4、如果什么都不是，那只能是基本类型了，直接把结果resolve出去\n            resolve(x)\n        }\n    }\n\n    isFunction(param) {/** ... */}\n}\n</code></pre>\n<h3>第十步：实现<code>.catch()</code>方法</h3>\n<p><code>promise</code>除了可以使用<code>.then(onFulfilled, onRejected)</code>方法的第二个参数获取失败的回调结果外，还可以使用<code>.catch()</code>方法获得，比如</p>\n<pre><code class=\"language-js\">const test = new Promise((resolve, reject)=&gt;{\n    setTimeout(()=&gt;{\n       reject(111) \n    }, 1000)\n}).then(\n    value=&gt;{},\n    reason=&gt;{\n        console.log(reason, \'onRejected\')\n    }\n)\n\n// 或者\ntest.catch(reason=&gt;{\n    console.log(reason, \'onRejected\')\n})\n</code></pre>\n<p>我们自己也实现一个</p>\n<pre><code class=\"language-js\">// 声明状态常量\n/** ... */\n\nclass MyPromise {\n    /** ... */\n\n    constructor(fn) {/** ... */}\n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n    get status() {/** ... */}\n    set status(newStatus) {/** ... */}\n    \n    // 直接调用then方法，不传成功的回调，只传失败的回调即可\n    catch(onRejected) {\n        return this.then(null, onRejected)\n    }\n\n    then(onFulfilled, onRejected) {/** ... */}\n\n    resolvePromise(promise2, x, resolve, reject) {/** ... */}\n\n    isFunction(param) {/** ... */}\n}\n</code></pre>\n<hr />\n<p>通过上面的十步，我们已经可以使用自己定义的promise，自己可以代入用例试一试，比如</p>\n<pre><code class=\"language-js\">const test = new MyPromise((resolve, reject)=&gt;{\n    setTimeout(() =&gt; {\n        resolve(111)\n    }, 1000)\n}).then(console.log)\n\nconsole.log(test)\n</code></pre>\n<p>或者</p>\n<pre><code class=\"language-js\">const test = new MyPromise((resolve, reject)=&gt;{\n    setTimeout(() =&gt; {\n        resolve(111)\n    }, 1000)\n})\n\ntest.then(console.log)\ntest.then(console.log)\ntest.then(console.log)\ntest.then(console.log)\n</code></pre>\n<h3>第十一步：<code>Promise.resolve()</code></h3>\n<p>在实际的工作中，我们有时还会直接使用<code>promise</code>的静态方法<code>Promise.resolve(value)</code>直接返回一个<code>promise</code>对象，存在两种情况</p>\n<ul>\n<li>（1）如果<code>value</code>是一个基本类型，以这个基本类型为<code>value</code>，返回一个<code>promise</code>对象\n<pre><code class=\"language-js\">const test = Promise.resolve(1111)\ntest.then(console.log)\n</code></pre>\n</li>\n<li>（2）如果<code>value</code>是一个<code>promise</code>对象，那直接返回这个<code>promise</code>\n<pre><code class=\"language-js\">const test = Promise.resolve( \n	new Promise((resolve, reject)=&gt;{\n        setTimeout(()=&gt;{\n            resolve(111)\n        }, 1000)\n    })\n)\ntest.then(console.log)\n</code></pre>\n</li>\n</ul>\n<p>我们自己也实现一个<code>MyPromise.resolve()</code></p>\n<pre><code class=\"language-js\">// 声明状态常量\n/** ... */\n\nclass MyPromise {\n    /** ... */\n    constructor(fn) {/** ... */}\n    \n    /**\n     * 注意：\n     *  静态成员方法只能通过类名调用\n     *  并且在方法体里也只能调用静态方法，没有this\n     */\n    static resolve(value) {\n        // 如果value是一个Promise，直接返回\n        if (value instanceof MyPromise) {\n            return value\n        }\n\n        // 如果不是就直接以value为值，返回一个新的Promise\n        return new MyPromise((resolve) =&gt; {\n            resolve(value)\n        })\n    }\n\n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n    get status() {/** ... */}\n    set status(newStatus) {/** ... */}\n    then(onFulfilled, onRejected) {/** ... */}\n    resolvePromise(promise2, x, resolve, reject) {/** ... */}\n    isFunction(param) {/** ... */}\n}\n</code></pre>\n<h3>第十二步：<code>Promise.reject()</code></h3>\n<p><code>Promise.reject(reason)</code>直接返回一个<code>fulfilled</code>状态的<code>promise</code>，比如</p>\n<pre><code class=\"language-js\">const test = Promise.reject(1111)\ntest.then(\n	(value)=&gt;{console.log(value,\'fulfilled\')},\n    (reason)=&gt;{console.log(reason,\'rejected\')},\n)\n</code></pre>\n<p>自己也实现一个</p>\n<pre><code class=\"language-js\">// 声明状态常量\n/** ... */\n\nclass MyPromise {\n    /** ... */\n    constructor(fn) {/** ... */}\n    static resolve(value) {/** ... */}\n    \n    static reject(reason) {\n        // 以reason为值，返回一个新的Promise\n        return new MyPromise((resolve, reject) =&gt; {\n            reject(reason)\n        })\n    }\n\n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n    get status() {/** ... */}\n    set status(newStatus) {/** ... */}\n    then(onFulfilled, onRejected) {/** ... */}\n    resolvePromise(promise2, x, resolve, reject) {/** ... */}\n    isFunction(param) {/** ... */}\n}\n</code></pre>\n<h3>第十三步：<code>Promise.race()</code></h3>\n<p><code>promise</code>的<code>race</code>方法，是传入一个数组（其实是类数组，只要可以被迭代都可以），数组里存了一堆等待执行的<code>promise</code>对象，如果不是<code>promise</code>，内部直接给全部转换为<code>promise</code>，我们并不知道这些``promie<code>最终执行的结果，当使用</code>Promise.race(arr).then()<code>时，这些</code>promise<code>一旦有一个被</code>resolve<code>了，就直接将结果返回，执行时是同步的，可以使用</code>for`循环来模拟，for循环默认为同步执行</p>\n<pre><code class=\"language-js\">// 声明状态常量\n/** ... */\n\nclass MyPromise {\n    /** ... */\n    constructor(fn) {/** ... */}\n    static resolve(value) {/** ... */}\n    static reject(reason) {/** ... */}\n    \n    static race(iterableList) {\n        return new MyPromise((resolve, reject) =&gt; {\n            /** \n             * 判断传入的参数是否可迭代 \n             * */\n            if (!MyPromise.isIterable(iterableList)) {\n                return reject(new TypeError(`${iterableList} is not iterable (cannot read property Symbol(Symbol.iterator))`))\n            }\n\n            // 2、将类数组转换为数组\n            const promiseList = Array.from(iterableList)\n            const promiseLength = promiseList.length\n\n            // 如果是一个空数组，直接resolve一个空数组\n            if (promiseLength === 0) {\n                return resolve([])\n            } else {\n                // 3、同步执行数组中的Promise\n                for (let i = 0; i &lt; promiseLength; i++) {\n                    // 4、为了防止某一个参数不是Promise，直接全转换一下\n                    MyPromise.resolve(promiseList[i]).then(\n                        (value) =&gt; {\n                            // 5、一旦有结果了，直接返回\n                            return resolve(value)\n                        },\n                        (reason) =&gt; {\n                            // 5、\n                            return reject(reason)\n                        }\n                    )\n                }\n            }\n        })\n    }\n\n    /**\n     * @description 判断value是否可迭代\n     * @param {*} value \n     * @returns {Boolean} true：可迭代；false：不可迭代\n     */\n    static isIterable(value) {\n        // 如果是空或undefined 直接返回false\n        if (value === null || value === undefined) {\n            return false\n        } else {\n            // 对象里如果没有Symbol.iterator，默认是不可迭代的\n            // 可迭代的对象都会默认实现Symbol.iterator迭代器\n            return !(value[Symbol.iterator] === undefined)\n        }\n    }\n\n\n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n    get status() {/** ... */}\n    set status(newStatus) {/** ... */}\n    then(onFulfilled, onRejected) {/** ... */}\n    resolvePromise(promise2, x, resolve, reject) {/** ... */}\n    isFunction(param) {/** ... */}\n}\n</code></pre>\n<h3>第十四步：<code>Promise.all()</code></h3>\n<p><code>promise</code>的<code>all</code>方法与<code>race</code>方法的不同点是<code>all</code>方法只有所有结果都<code>resolve</code>时才会返回结果，一旦有一个<code>reject</code>就会走失败的回调</p>\n<pre><code class=\"language-js\">// 声明状态常量\n/** ... */\n\nclass MyPromise {\n    /** ... */\n    constructor(fn) {/** ... */}\n    static resolve(value) {/** ... */}\n    static reject(reason) {/** ... */}\n   \n    static race(iterableList) {/** ... */}\n    \n    static all(iterableList) {\n        return new MyPromise((resolve, reject) =&gt; {\n            // 1、判断参数是否是可迭代的\n            if (!MyPromise.isIterable(iterableList)) {\n                return reject(new TypeError(`${iterableList} is not iterable (cannot read property Symbol(Symbol.iterator))`))\n            }\n            // 2、转换为数组\n            const promiseList = Array.from(iterableList)\n            const promiseLength = promiseList.length\n            /**\n             * 取一个计数器，每次执行resolve回调时就+1\n             * 并声明一个返回值的数组，每次resolve时就将返回值存进去，\n             * 只有当计数器的长度和promise个数相等时，即所有promise都成功执行了，\n             * 然后就将存成功结果的数组resolve出去\n             */\n            let resolvedCount = 0\n            let resolvedValues = new Array(promiseLength)\n            // 如果是空数组，直接返回空数组\n            if (promiseLength === 0) {\n                return resolve([])\n            } else {\n                // 3、同步执行\n                for (let i = 0; i &lt; promiseLength; i++) {\n                    // 4、全部转换为promise对象\n                    MyPromise.resolve(promiseList[i]).then(\n                        (value) =&gt; {\n                            // 成功时就+1\n                            resolvedCount++\n                            // 5、存入对应的value到结果数组中\n                            resolvedValues[i] = value\n                            if (resolvedCount === promiseLength) {\n                                return resolve(resolvedValues)\n                            }\n                        },\n                        (reason) =&gt; {\n                            // 6、一旦有失败的，就将失败结果reject出去\n                            return reject(reason)\n                        },\n                    )\n\n                }\n            }\n        })\n    }\n    \n    static isIterable(value) {/** ... */}\n\n\n    resolve(value) {/** ... */}\n    reject(reason) {/** ... */}\n    get status() {/** ... */}\n    set status(newStatus) {/** ... */}\n    then(onFulfilled, onRejected) {/** ... */}\n    resolvePromise(promise2, x, resolve, reject) {/** ... */}\n    isFunction(param) {/** ... */}\n}\n</code></pre>\n<h2>总结</h2>\n<p>以上就自己实现了一个自己的promise，可以试着敲一敲，代入一些用例试一试，总共实现了promise的以下内容</p>\n<ol>\n<li><code>new Promise()</code>时都做了哪些事</li>\n<li><code>then</code>方法内部的执行机制</li>\n<li>promise链式执行的原理</li>\n<li><code>.catch</code>方法执行原理</li>\n<li>手写<code>promise.race()</code></li>\n<li>手写<code>promise.all()</code></li>\n</ol>\n<p>源代码地址：https://gitee.com/hrbust_cheny/note_code/blob/master/ES6/promise/test9.js</p>\n', '2021-10-14 15:25:43', '2021-12-09 21:54:29');
INSERT INTO `t_blog` VALUES ('f2b03be0-5250-11ec-96d5-7933aca11ca0', 'js的字符串类型string', '本篇文章对js中的字符串的相关知识点做一个系统的梳理。', '-1', 2, 'https://zh.javascript.info/string#nei-bu-unicode', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 10, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>本篇文章对js中的字符串的相关知识点做一个系统的梳理。</p>\n<h2>字符串的三种声明方式</h2>\n<pre><code class=\"language-js\">let str1 = &quot;abc&quot; // 双引号\nlet str2 = \'abc\' // 单引号\nlet str3 = `abc` // 反引号 es6\n</code></pre>\n<h2>特殊字符</h2>\n<p>我们可以通过使用“换行符（newline character）”，以支持使用单引号和双引号来创建跨行字符串。换行符写作 <code>\\n</code>，用来表示换行：</p>\n<pre><code class=\"language-js\">let guestList = &quot;Guests:\\n * John\\n * Pete\\n * Mary&quot;;\n\nconsole.log(guestList); // 一个多行的客人列表\n// Guests:\n//  * John\n//  * Pete\n//  * Mary\n</code></pre>\n<p>例如，这两行描述的是一样的，只是书写方式不同：</p>\n<pre><code class=\"language-js\">let str1 = &quot;Hello\\nWorld&quot;; // 使用“换行符”创建的两行字符串\n\n// 使用反引号和普通的换行创建的两行字符串\nlet str2 = `Hello\nWorld`;\n\nconsole.log(str1 === str2); // true\nconsole.log(str1);\n// Hello\n// World\n</code></pre>\n<p>还有其他不常见的“特殊”字符。</p>\n<p>这是完整列表：</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\\n</code></td>\n<td>换行</td>\n</tr>\n<tr>\n<td><code>\\r</code></td>\n<td>回车：不单独使用。Windows 文本文件使用两个字符 <code>\\r\\n</code> 的组合来表示换行。</td>\n</tr>\n<tr>\n<td><code>\\\',\\&quot;</code></td>\n<td>引号</td>\n</tr>\n<tr>\n<td><code>\\\\</code></td>\n<td>反斜杠</td>\n</tr>\n<tr>\n<td><code>\\t</code></td>\n<td>制表符</td>\n</tr>\n<tr>\n<td><code>\\b, \\f, \\v</code></td>\n<td>退格，换页，垂直标签 —— <strong>为了兼容性，现在已经不使用了</strong>。</td>\n</tr>\n<tr>\n<td><code>\\xXX</code></td>\n<td>具有给定十六进制 Unicode <code>XX</code> 的 Unicode 字符，例如：<code>\'\\x7A\'</code> 和 <code>\'z\'</code> 相同。</td>\n</tr>\n<tr>\n<td><code>\\uXXXX</code></td>\n<td>以 UTF-16 编码的十六进制代码 <code>XXXX</code> 的 unicode 字符，例如 <code>\\u00A9</code> —— 是版权符号 <code>©</code> 的 unicode。它必须正好是 4 个十六进制数字。</td>\n</tr>\n<tr>\n<td><code>\\u{X…XXXXXX}</code>（1 到 6 个十六进制字符）</td>\n<td>具有给定 UTF-32 编码的 unicode 符号。一些罕见的字符用两个 unicode 符号编码，占用 4 个字节。这样我们就可以插入长代码了。</td>\n</tr>\n</tbody>\n</table>\n<p>unicode 示例：</p>\n<pre><code class=\"language-js\">console.log(&quot;\\u00A9&quot;); // ©\nconsole.log(&quot;\\u{20331}&quot;); // 𠌱，罕见的中国象形文字（长 unicode）\nconsole.log(&quot;\\u{1F60D}&quot;); // 😍，笑脸符号（另一个长 unicode）\n</code></pre>\n<p>所有的特殊字符都以反斜杠字符 <code>\\</code> 开始。它也被称为“转义字符”。</p>\n<p>如果我们想要在字符串中插入一个引号，我们也会使用它。</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">console.log( \'I\\\'m the Walrus!\' ); // I\'m the Walrus!\n</code></pre>\n<p>正如你所看到的，我们必须在内部引号前加上反斜杠 <code>\\\'</code>，否则它将表示字符串结束。</p>\n<p>当然，只有与外部闭合引号相同的引号才需要转义。因此，作为一个更优雅的解决方案，我们可以改用双引号或者反引号：</p>\n<pre><code class=\"language-js\">console.log( `I\'m the Walrus!` ); // I\'m the Walrus!\n</code></pre>\n<p>注意反斜杠 <code>\\</code> 在 JavaScript 中用于正确读取字符串，然后消失。内存中的字符串没有 <code>\\</code>。</p>\n<p>但是如果我们需要在字符串中显示一个实际的反斜杠 <code>\\</code> 应该怎么做？</p>\n<p>我们可以这样做，只需要将其书写两次 <code>\\\\</code>：</p>\n<pre><code class=\"language-js\">console.log( `The backslash: \\\\` ); // The backslash: \\\n</code></pre>\n<h2>字符串长度</h2>\n<p><code>length</code> 属性表示字符串长度：</p>\n<pre><code class=\"language-js\">console.log( `My\\n`.length ); // 3\n</code></pre>\n<p>注意 <code>\\n</code> 是一个单独的“特殊”字符，所以长度确实是 <code>3</code>。</p>\n<blockquote>\n<p><strong><code>length</code> 是一个属性</strong></p>\n<p>掌握其他编程语言的人，有时会错误地调用 <code>str.length()</code> 而不是 <code>str.length</code>。这是行不通的。</p>\n<p>请注意 <code>str.length</code> 是一个数字属性，而不是函数。后面不需要添加括号。</p>\n</blockquote>\n<h2>访问字符</h2>\n<p>要获取在 <code>pos</code> 位置的一个字符，可以使用方括号 <code>[pos]</code> 或者调用 <a href=\"https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/String/charAt\">str.charAt(pos)</a> 方法。第一个字符从零位置开始：</p>\n<pre><code class=\"language-js\">let str = `Hello`;\n\n// 第一个字符\nconsole.log( str[0] ); // H\nconsole.log( str.charAt(0) ); // H\n\n// 最后一个字符\nconsole.log( str[str.length - 1] ); // o\n</code></pre>\n<p>方括号是获取字符的一种现代化方法，而 <code>charAt</code> 是历史原因才存在的。</p>\n<p>它们之间的唯一区别是，如果没有找到字符，<code>[]</code> 返回 <code>undefined</code>，而 <code>charAt</code> 返回一个空字符串：</p>\n<pre><code class=\"language-js\">let str = `Hello`;\n\nconsole.log( str[1000] ); // undefined\nconsole.log( str.charAt(1000) ); // \'\'（空字符串）\n</code></pre>\n<p>我们也可以使用 <code>for..of</code> 遍历字符：</p>\n<pre><code class=\"language-js\">for (let char of &quot;Hello&quot;) {\n  console.log(char); // H,e,l,l,o（char 变为 &quot;H&quot;，然后是 &quot;e&quot;，然后是 &quot;l&quot; 等）\n}\n</code></pre>\n<h2>字符串是不可改变的</h2>\n<p>在 JavaScript 中，字符串不可更改。改变字符是不可能的。</p>\n<p>我们证明一下为什么不可能：</p>\n<pre><code class=\"language-js\">let str = \'Hi\';\n\nstr[0] = \'h\'; \nconsole.log(str[0]); // H 并没有改变，仍旧是原先的H\n</code></pre>\n<p>通常的解决方法是创建一个新的字符串，并将其分配给 <code>str</code> 而不是以前的字符串。</p>\n<p>例如：</p>\n<pre><code class=\"language-js\">let str = \'Hi\';\n\nstr = \'h\' + str[1];  // 替换字符串\n\nconsole.log( str ); // hi\n</code></pre>\n<h2>比较字符串</h2>\n<p>字符串按字母顺序逐字比较。不过，有一些奇怪的地方。</p>\n<ol>\n<li>\n<p>小写字母总是大于大写字母：</p>\n<pre><code class=\"language-js\">console.log( \'a\' &gt; \'Z\' ); // true\n</code></pre>\n</li>\n<li>\n<p>带变音符号的字母存在“乱序”的情况：</p>\n<pre><code class=\"language-js\">console.log( \'Österreich\' &gt; \'Zealand\' ); // true\n</code></pre>\n<p>如果我们对这些国家名进行排序，可能会导致奇怪的结果。通常，人们会期望 <code>Zealand</code> 在名单中的 <code>Österreich</code> 之后出现。</p>\n</li>\n</ol>\n<p>为了明白发生了什么，我们回顾一下在 JavaScript 中字符串的内部表示。</p>\n<p>我们知道，计算机存储字符只能是0和1的二进制，所以每个字符实际上都有它唯一的数字表示，最终将数字转换为二进制存储在内存中。所有的字符串都使用 <a href=\"https://en.wikipedia.org/wiki/UTF-16\">UTF-16</a> 编码。即：每个字符都有对应的数字代码。有特殊的方法可以获取代码表示的字符，以及字符对应的代码。</p>\n<h3>str.codePointAt(pos)</h3>\n<p>返回在 <code>pos</code> 位置的字符代码 :</p>\n<pre><code class=\"language-js\">// 不同的字母有不同的代码\nconsole.log( &quot;z&quot;.codePointAt(0) ); // 122\nconsole.log( &quot;Z&quot;.codePointAt(0) ); // 90\n</code></pre>\n<h3>String.fromCodePoint(code)</h3>\n<p>通过数字 <code>code</code> 创建字符</p>\n<pre><code class=\"language-js\">console.log(String.fromCodePoint(90)); // Z\nconsole.log(String.fromCodePoint(30495)); // 真\n</code></pre>\n<p>现在我们看一下代码为 <code>65..220</code> 的字符（拉丁字母和一些额外的字符），方法是创建一个字符串：</p>\n<pre><code class=\"language-js\">let str = \'\';\n\nfor (let i = 65; i &lt;= 220; i++) {\n  str += String.fromCodePoint(i);\n}\nconsole.log( str );\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ\n</code></pre>\n<p>看到没？先是大写字符，然后是一些特殊字符，然后是小写字符，而 <code>Ö</code> 几乎是最后输出。</p>\n<p>现在很明显为什么 <code>a &gt; Z</code>。</p>\n<p>字符通过数字代码进行比较。越大的代码意味着字符越大。<code>a</code>（97）的代码大于 <code>Z</code>（90）的代码。</p>\n<ul>\n<li>所有小写字母追随在大写字母之后，因为它们的代码更大。</li>\n<li>一些像 <code>Ö</code> 的字母与主要字母表不同。这里，它的代码比任何从 <code>a</code> 到 <code>z</code> 的代码都要大。</li>\n</ul>\n<h2>总结</h2>\n<p>计算机只能存储二进制字符，只有0和1，也就是说，所有字符串最终存储的方式也是0和1，所以，每个字符实际上都遵循了一套编码规范，可以将字符串转换为数字，然后数字就能转换为二进制。js中的字符串遵循<code>UTF-16</code>的编码规范。</p>\n<pre><code class=\"language-js\">let str1 = `0123456789`\nlet str2 = `ABCDEFGHIJKLMNOPQRSTUVWXYZ`\nlet str3 = `abcdefghijklmnopqrstuvwxyz`\nlet str4 = `你好中国`\n\nlet str1Num = \'\'\nlet str2Num = \'\'\nlet str3Num = \'\'\nlet str4Num = \'\'\nfor (const char of str1) {\n    str1Num += `${char.codePointAt(0)} `\n}\nfor (const char of str2) {\n    str2Num += `${char.codePointAt(0)} `\n}\nfor (const char of str3) {\n    str3Num += `${char.codePointAt(0)} `\n}\nfor (const char of str4) {\n    str4Num += `${char.codePointAt(0)} `\n}\n// `0123456789`\nconsole.log(str1Num); // 48 49 50 51 52 53 54 55 56 57 \n// `ABCDEFGHIJKLMNOPQRSTUVWXYZ`\nconsole.log(str2Num); // 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 \n// `abcdefghijklmnopqrstuvwxyz`\nconsole.log(str3Num); // 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 \n// `你好中国`\nconsole.log(str4Num); // 20320 22909 20013 22269\n</code></pre>\n<ol>\n<li>我们可以使用<code>\'\'</code>、<code>&quot;&quot;</code>、``、来声明字符串</li>\n<li>特殊字符可以使用转义，反斜杠加特殊字符的方式，比如换行<code>\\n</code>，回车<code>\\r</code>等等。</li>\n<li>字符串是不可以改变的，比如<code>let a = \'abc\'</code>，<code>a[0]=A</code>，这是无效的。</li>\n<li>字符串在比较时，每个字符会挨个比较，有一个对照表可以将字符串转为数字，比较的实际是数字。\n<ol>\n<li><code>str.codePointAt(pos)</code>，将字符转换为数字（参照对照表中）</li>\n<li><code>String.fromCodePoint(code)</code>，将数字转换为字符串（参照对照表）</li>\n</ol>\n</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/string#nei-bu-unicode\">https://zh.javascript.info/string#nei-bu-unicode</a></p>\n', '2021-12-01 10:46:56', '2021-12-01 10:58:25');
INSERT INTO `t_blog` VALUES ('f8df21c0-408a-11ec-97a5-ef78eceb5d73', '微任务、宏任务、Event-Loop（浏览器篇）', '浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于事件循环的，所以有很多相似的地方，但是又因为浏览器需要操作DOM，并与用户交互（鼠标滑动、窗口缩放、点击）等等等，所以它与node环境中的事件循环又不太一样，但是大概思想差不多，本章我们一起来探究下浏览器中的事件循环。', '-1', 1, '', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', 3, 11, 2, 1, 2, 1, 'http://api.bnbiye.cn/upload/png/2021-11-08/4f5a42f0-408b-11ec-97a5-ef78eceb5d73.png', '<h2>前言</h2>\n<p>浏览器中 JavaScript 的执行流程和 Node.js 中的流程都是基于 <strong>事件循环</strong> 的，所以有很多相似的地方，但是又因为浏览器需要操作DOM，并与用户交互（鼠标滑动、窗口缩放、点击）等等等，所以它与node环境中的事件循环又不太一样，但是大概思想差不多，本章我们一起来探究下浏览器中的事件循环。</p>\n<blockquote>\n<p>tip：想要了解node中事件循环机制参考上一篇文章，<a href=\"http://www.bnbiye.cn/#/articleDetail/09169a10-3d10-11ec-8015-f554da021b2a\">微任务、宏任务、Event-Loop（nodejs篇）</a></p>\n</blockquote>\n<h3>思考</h3>\n<p>现在想象一个画面，我们正在浏览一个网页，不知你是否好奇过这个网页是怎么被浏览器渲染出来的？为什么滚动鼠标的滚轮，能够控制窗口上下移动？为什么通过按住<code>Ctrl+滚动鼠标滚轮</code>，能够控制浏览器窗口的放大和缩小？为什么点击网页上的某个隐藏按钮，浏览器中的某块内容会被隐藏起来？等等诸如此类的操作，每天都在发生，不知你们是否思考过这些都是因为什么？</p>\n<p>其实，这些操作实际上都可以看作为浏览器需要执行的一个个小任务，浏览器就是通过事件循环，去调度这些任务，并在恰当的时机使用对应的处理引擎执行它们，这样就达到了想要的效果。比如负责处理页面显示效果的<code>GUI引擎</code>、负责处理Script脚本和执行回调函数的<code>JavaScript引擎</code>和负责请求第三方资源，作为总控制中心的<code>主线程</code>。</p>\n<h3>一个小例子来理解浏览器加载页面的执行机制</h3>\n<p>我们先来看一个简单的例子来具体理解下上述的三个引擎，以浏览器首次加载页面为例。</p>\n<blockquote>\n<p>tip：如对浏览器首次渲染页面的具体细节不太了解，请参考之前的几篇文章</p>\n<p><a href=\"http://www.bnbiye.cn/#/articleDetail/53cf64b0-3d88-11ec-8015-f554da021b2a\">优化关键路径（引言篇）</a>、<a href=\"http://www.bnbiye.cn/#/articleDetail/3fbc4640-3d89-11ec-97a5-ef78eceb5d73\">构建DOM树和CSSDOM树</a>、<a href=\"http://www.bnbiye.cn/#/articleDetail/3c9212f0-3d8a-11ec-97a5-ef78eceb5d73\">构建渲染树</a>、<a href=\"http://www.bnbiye.cn/#/articleDetail/87a08d30-3d8a-11ec-97a5-ef78eceb5d73\">阻塞渲染的CSS</a>、<a href=\"http://www.bnbiye.cn/#/articleDetail/d12707e0-3d8a-11ec-97a5-ef78eceb5d73\">使用JavaScript添加交互</a>、<a href=\"http://www.bnbiye.cn/#/articleDetail/1d47dc80-3d8b-11ec-97a5-ef78eceb5d73\">评估关键渲染路径的几种方法</a>、<a href=\"http://www.bnbiye.cn/#/articleDetail/6f8f8d30-3d8b-11ec-97a5-ef78eceb5d73\">分析关键渲染路径性能</a>、<a href=\"http://www.bnbiye.cn/#/articleDetail/b384b510-3d8b-11ec-97a5-ef78eceb5d73\">优化关键渲染路径</a>、<a href=\"http://www.bnbiye.cn/#/articleDetail/0a797310-3d8c-11ec-97a5-ef78eceb5d73\">优化首屏加载的规则和建议</a></p>\n</blockquote>\n<pre><code class=\"language-html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;title&gt;Document&lt;/title&gt;\n    &lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot;&gt;\n    &lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n    &lt;span&gt;hello world&lt;/span&gt;\n    &lt;img style=&quot;vertical-align: middle;&quot;\n        src=&quot;https://portrait.gitee.com/uploads/avatars/user/517/1553068_hrbust_cheny_1617868573.png!avatar200&quot; alt=&quot;&quot;&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111052257965.png\" alt=\"浏览器首屏渲染\" /></p>\n<p>代码分析如下：</p>\n<ol>\n<li>\n<p>首先主线程发起请求，去获取HTML文本资源。</p>\n</li>\n<li>\n<p>获取到HTML资源后，交给GUI引擎解析。</p>\n</li>\n<li>\n<p>解析过程中，遇到了<code>&lt;link href=&quot;xxx.css&gt;</code>标签，先暂停解析，将控制权交由主线程。因为CSS文件会影响页面样式，所以GUI引擎在生成CSSDOM树之前，如果遇到未加载的CSS文件时，会暂停解析（也就是我们常说的CSS文件会阻塞页面加载）</p>\n</li>\n<li>\n<p>主线程发起请求，获取CSS文本资源。</p>\n</li>\n<li>\n<p>获取完毕后，GUI引擎继续解析，遇到了<code>&lt;script src=&quot;xxx.js&quot;&gt;</code>，先暂停解析，将控制权交由主线程。因为浏览器中的JS文件中有可能会操作DOM或者改变CSS样式，所以GUI引擎在生成DOM树和CSSDOM树之前，如果遇到未加载的JS文件时，也会暂停解析（也就是我们常说的JS文件会阻塞页面加载）。</p>\n</li>\n<li>\n<p>主线程发起请求，获取JS文本资源。</p>\n</li>\n<li>\n<p>控制权交由JavaScript引擎，执行加载完成的JS文件。</p>\n</li>\n<li>\n<p>GUI引擎继续解析，遇到了<code>&lt;img src=&quot;http://xxx.png&quot;&gt;</code>标签，因为此刻的DOM树和CSSDOM树均未生成，浏览器会先抑制图片的onLoad事件，将该任务先放到任务队列中先不执行。即先不请求资源，等DOM 和 CSSOM 均准备完成后，再去请求（即图片资源并不会阻止DOM树和CSSDOM树的生成）。</p>\n<blockquote>\n<p>tip：虽然图片不会阻止DOM树和CSSDOM树的生成，但是会阻碍页面onLoad回调的触发时机。</p>\n<p>因为在触发页面的onLoad回调函数之前，需先触发domComplete回调，而domComplete回调触发即代表页面的所有资源都已请求完成，包括图片资源，所以图片资源假如没有请求完成时，会影响到onLoad回调触发的时机，并且很有可能在onLoad的回调中，也有处理DOM的操作，所以整体上看也会影响到页面的渲染，最好也做个优化，比如图片懒加载。</p>\n</blockquote>\n</li>\n<li>\n<p>HTML文件解析完毕，GUI引擎生成DOM树。</p>\n</li>\n<li>\n<p>GUI引擎生成CSSDOM树。</p>\n<blockquote>\n<p>tip：如果没有阻塞解析器的 JavaScript，则<code>DOMContentLoaded</code> 将在<code>domInteractive</code> 后立即触发。 即：生成DOM树后立即生成CSSDOM树</p>\n</blockquote>\n</li>\n<li>\n<p>GUI引擎根据DOM树和CSSDOM树生成渲染树。</p>\n</li>\n<li>\n<p>GUI引擎根据渲染树，开始布局（Layout），即计算元素的几何位置。</p>\n</li>\n<li>\n<p>GUI引擎开始绘制（Paint），将元素绘制到浏览器。</p>\n</li>\n<li>\n<p>在触发<code>domComplete</code>回调之前，发现任务队列有未加载的图片，JavaScript引擎执行加载图片回调。</p>\n</li>\n<li>\n<p>主线程发起请求，加载图片资源（所有资源都请求完毕，触发domComplete回调）</p>\n</li>\n<li>\n<p>浏览器加载的最后一步，JavaScript引擎触发页面的onLoad回调（以便触发额外的应用逻辑）。</p>\n</li>\n</ol>\n<h2>宏任务Macrotask</h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1eab2a9953804252a49ee71fe95569ea~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"image-20211103102111067\" /></p>\n<p>宏任务解释解释参考这篇，<a href=\"http://www.bnbiye.cn/#/articleDetail/09169a10-3d10-11ec-8015-f554da021b2a\">微任务、宏任务、Event-Loop（nodejs篇）</a></p>\n<h2>微任务Microtask</h2>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0471f70deca4e9c98c5badcbf5b55ab~tplv-k3u1fbpfcp-zoom-1.image\" alt=\"微任务\" /></p>\n<p>微任务解释参考这篇文章，<a href=\"http://www.bnbiye.cn/#/articleDetail/09169a10-3d10-11ec-8015-f554da021b2a\">微任务、宏任务、Event-Loop（nodejs篇）</a></p>\n<p><strong>每个宏任务之后，引擎会立即执行微任务队列中的所有任务，然后再执行其他的宏任务，或渲染，或进行其他任何操作。</strong></p>\n<p>示例：</p>\n<pre><code class=\"language-html\">&lt;script&gt;\n    setTimeout(() =&gt; alert(&quot;timeout&quot;));\n\n    Promise.resolve()\n      .then(() =&gt; alert(&quot;promise&quot;));\n\n    alert(&quot;code&quot;);\n&lt;/script&gt;\n</code></pre>\n<ol>\n<li><code>code</code> 首先显示，因为它是常规的同步调用。</li>\n<li><code>promise</code> 第二个出现，因为 <code>then</code> 会通过微任务队列，并在当前代码之后执行。</li>\n<li><code>timeout</code> 最后显示，因为它是一个宏任务。</li>\n</ol>\n<h3>queueMicrotask(func)</h3>\n<p>还有一个特殊的函数 <code>queueMicrotask(func)</code>，它对 <code>func</code> 进行排队，以在微任务队列中执行。</p>\n<h2>事件循环</h2>\n<p>根据上面的例子，对于浏览器对页面的处理流程，我们脑海中应该已经有了一个清晰的轮廓。假设在页面加载之后，我们还有一些其它操作，如点击按钮，滚动窗口等等这些交互，浏览器都会交由对应引擎负责处理。JavaScript引擎首当其冲，会执行各种任务的回调函数。而<strong>事件循环</strong>实际就是在 <strong>JavaScript 引擎等待任务，执行任务和进入休眠状态等待更多任务这几个状态之间转换的无限循环</strong>。（概念来自：<a href=\"https://zh.javascript.info/event-loop#shi-jian-xun-huan\">事件循环：微任务和宏任务</a>）</p>\n<blockquote>\n<p>tip：JavaScript引擎负责执行各种任务，而GUI引擎负责改变页面布局和样式，它俩各司其职。当有一些JS操作改变DOM或样式时，会交由GUI引擎处理。</p>\n</blockquote>\n<h3>需要注意的两个细节</h3>\n<p>有两个细节需要注意下：</p>\n<ol>\n<li>当Javascript引擎在执行任务时，永远不会进行渲染（render）。即，GUI引擎只有当JavaScript引擎执行完当前任务后，才可以处理页面样式，比如重排或者重绘，一些动画效果等等。</li>\n<li>如果一项任务执行花费的时间过长，浏览器将无法执行其它任务，例如处理用户事件。因此，在一定时间后，浏览器会抛出一个如“页面未响应”之类的警报，建议终止这个任务。这种情况常发生在有大量复杂的计算或导致死循环的程序错误时。</li>\n</ol>\n<h3>事件循环的一般算法</h3>\n<ol>\n<li>当有任务时：\n<ul>\n<li>从最先进入的任务开始执行。</li>\n</ul>\n</li>\n<li>休眠直到出现任务，然后转到第 1 步。</li>\n</ol>\n<p>当我们浏览一个网页时就是上述这种形式。JavaScript 引擎大多数时候不执行任何操作，它仅在脚本/处理程序/事件激活时执行。</p>\n<p>任务示例：</p>\n<ul>\n<li>当外部脚本 <code>&lt;script src=&quot;...&quot;&gt;</code> 加载完成时，任务就是执行它。</li>\n<li>当用户移动鼠标时，任务就是派生出 <code>mousemove</code> 事件和执行处理程序。</li>\n<li>当安排的（scheduled）<code>setTimeout</code> 时间到达时，任务就是执行其回调。</li>\n<li>……诸如此类。</li>\n</ul>\n<p>设置任务 —— 引擎处理它们 —— 然后等待更多任务（即休眠，几乎不消耗 CPU 资源）。</p>\n<p>一个任务到来时，引擎可能正处于繁忙状态，那么这个任务就会被排入队列。</p>\n<p>多个任务组成了一个队列，即所谓的“宏任务队列”（v8 术语）。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111061148285.png\" alt=\"image-20211106114841137\" /></p>\n<p>例如，当引擎正在忙于执行一段 <code>script</code> 时，用户可能会移动鼠标而产生 <code>mousemove</code> 事件，<code>setTimeout</code> 或许也刚好到期，以及其他任务，这些任务组成了一个队列，如上图所示。</p>\n<p>队列中的任务基于“先进先出”的原则执行。当浏览器引擎执行完 <code>script</code> 后，它会处理 <code>mousemove</code> 事件，然后处理 <code>setTimeout</code> 处理程序，依此类推。</p>\n<h4>例子1：拆分CPU过载任务</h4>\n<p>假设我们有一个 CPU 过载任务。</p>\n<p>例如，语法高亮（用来给本页面中的示例代码着色）是相当耗费 CPU 资源的任务。为了高亮显示代码，它执行分析，创建很多着了色的元素，然后将它们添加到文档中 —— 对于文本量大的文档来说，需要耗费很长时间。</p>\n<p>当引擎忙于语法高亮时，它就无法处理其他 DOM 相关的工作，例如处理用户事件等。它甚至可能会导致浏览器“中断（hiccup）”甚至“挂起（hang）”一段时间，这是不可接受的。</p>\n<p>我们可以通过将大任务拆分成多个小任务来避免这个问题。高亮显示前 100 行，然后使用 <code>setTimeout</code>（延时参数为 0）来安排（schedule）后 100 行的高亮显示，依此类推。</p>\n<p>为了演示这种方法，简单起见，让我们写一个从 <code>1</code> 数到 <code>1 000 000 000</code> 的函数，而不写文本高亮。</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n    &lt;button&gt;click me&lt;/button&gt;\n    &lt;a href=&quot;http://bnbiye.cn&quot; target=&quot;_blank&quot;&gt;噗噗博客&lt;/a&gt;\n\n    &lt;script&gt;\n        let i = 0;\n        let start = Date.now();\n\n        function count() {\n            // 做一个繁重的任务\n            for (let j = 0; j &lt; 1e9; j++) {\n                i++;\n            }\n            alert(&quot;Done in &quot; + (Date.now() - start) + \'ms\');\n        }\n\n        const btn = document.getElementsByTagName(\'button\')[0]\n        btn.addEventListener(\'click\', function () {\n            count()\n        })\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>在上面的代码中，我们给<code>button</code>按钮增加了一个点击事件，点击后会调用<code>count()</code>方法，此处的<code>count方法</code>运行了<code>1 000 000 000</code>次的<code>i++</code>，非常耗费时间，执行完成后会弹出个<code>alert弹框</code>。假设在执行<code>count</code>的途中，我们去尝试点击页面上的<code>&lt;a&gt;</code>标签跳转网页，这时会发现引擎会“挂起”一段时间，在计数结束之前不会处理这个点击事件。只有当计数器执行完毕后，才会执行引擎在挂在时操作的一些点击事件，假如我们点击了三次，看一下浏览器是如何轮询这些事件的。我们模拟下面的操作（浏览器页面加载完毕之后的操作）</p>\n<ol>\n<li>点击button</li>\n<li>程序挂起后连续点击三次<code>a</code>标签</li>\n</ol>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111061738917.png\" alt=\"image-20211106173810872\" /></p>\n<h5>分析</h5>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111061719632.png\" alt=\"浏览器引擎被挂起 (1)\" /></p>\n<ol>\n<li>点击按钮，执行执行count方法，因为会运行很长时间，浏览器被挂起，这期间不会做任何其它事，如果在这期间有用户事件，会先放置任务队列中，等待该操作执行完毕后，去任务队列轮询事件，按照先进先出原则，依次执行。</li>\n<li><code>count</code>方法尚未执行完成，第一次点击<code>a</code>标签，将点击事件放置于任务队列中</li>\n<li><code>count</code>方法尚未执行完成，第二次点击<code>a</code>标签，将点击事件放置于任务队列中</li>\n<li><code>count</code>方法尚未执行完成，第三次点击<code>a</code>标签，将点击事件放置于任务队列中</li>\n<li><code>count</code>方法执行完毕，弹出<code>alert弹框</code>，<code>alert弹框</code>会阻塞浏览器渲染，不点击确认，浏览器会一直被挂起，点击确认按钮。</li>\n<li>JavaScript引擎任务为空，开始轮询任务队列，执行第一次的点击事件，在新窗口打开<a href=\"http://bnbiye.com\">噗噗博客</a>。</li>\n<li>JavaScript引擎任务为空，开始轮询任务队列，执行第二次的点击事件，在新窗口打开<a href=\"http://bnbiye.com\">噗噗博客</a>。</li>\n<li>JavaScript引擎任务为空，开始轮询任务队列，执行第三次的点击事件，在新窗口打开<a href=\"http://bnbiye.com\">噗噗博客</a>。</li>\n<li>所有任务执行完毕，引擎进入休眠状态。</li>\n</ol>\n<blockquote>\n<p>tip：在执行count方法时，是非常浪费时间的，电脑CPU如果不行的话，浏览器甚至可能会显示一个“脚本执行时间过长”的警告。</p>\n</blockquote>\n<h5>使用setTimeout优化 （一）</h5>\n<pre><code class=\"language-html\">&lt;body&gt;\n    &lt;button&gt;click me&lt;/button&gt;\n    &lt;a href=&quot;http://bnbiye.cn&quot; target=&quot;_blank&quot;&gt;噗噗博客&lt;/a&gt;\n    &lt;span&gt;优化1&lt;/span&gt;\n\n    &lt;script&gt;\n        let i = 0;\n        let start = Date.now();\n\n        function count() {\n            // 做一个繁重的任务\n            do {\n                i++;\n            } while (i % 1e6 !== 0);\n\n            if (i === 1e9) {\n                alert(&quot;Done in &quot; + (Date.now() - start) + \'ms\');\n            } else {\n                setTimeout(count); // 安排（schedule）新的调用\n            }\n        }\n\n        const btn = document.getElementsByTagName(\'button\')[0]\n        btn.addEventListener(\'click\', function () {\n            count()\n        })\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>如上述代码，我们把繁重的count任务，使用setTimeout拆分为多块，每次计数<code>1 000 000</code>次，这样浏览器就不会出现“悬挂”的感觉，整体给人的感觉就会非常流程，完全没有感觉，连接还是秒跳转。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111061809609.png\" alt=\"image-20211106180932562\" /></p>\n<p>代码流程如下：</p>\n<ol>\n<li>首先执行计数：<code>i=1...1000000</code>。</li>\n<li>然后执行计数：<code>i=1000001..2000000</code>。</li>\n<li>……以此类推。</li>\n</ol>\n<p>如果在引擎忙于执行第一部分时出现了一个新的副任务（例如 <code>onclick</code> 事件），则该任务会被排入队列，然后在第一部分执行结束时，并在下一部分开始执行前，会执行该副任务。周期性地在两次 <code>count</code> 执行期间返回事件循环，这为 JavaScript 引擎提供了足够的“空气”来执行其他操作，以响应其他的用户行为。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111061821037.png\" alt=\"setTimeout优化一\" /></p>\n<h5>使用setTimeout优化 （二）</h5>\n<pre><code class=\"language-html\">&lt;body&gt;\n    &lt;button&gt;click me&lt;/button&gt;\n    &lt;a href=&quot;http://bnbiye.cn&quot; target=&quot;_blank&quot;&gt;噗噗博客&lt;/a&gt;\n    &lt;span&gt;优化2&lt;/span&gt;\n\n    &lt;script&gt;\n        let i = 0;\n        let start = Date.now();\n\n        function count() {\n            // 做一个繁重的任务\n            // 将调度（scheduling）移动到开头\n            if (i &lt; 1e9 - 1e6) {\n                setTimeout(count); // 安排（schedule）新的调用\n            }\n\n            do {\n                i++;\n            } while (i % 1e6 !== 0);\n\n            if (i == 1e9) {\n                alert(&quot;Done in &quot; + (Date.now() - start) + \'ms\');\n            }\n        }\n\n        const btn = document.getElementsByTagName(\'button\')[0]\n        btn.addEventListener(\'click\', function () {\n            count()\n        })\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>改进的代码中，我们将<code>setTimeout</code>移动到了<code>count()</code> 的开头，运行它，我们注意到花费的时间减少了。</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111061809609.png\" alt=\"image-20211106180932562\" /></p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111081949382.png\" alt=\"image-20211108194935332\" /></p>\n<p>这是因为，多个嵌套的 <code>setTimeout</code> 调用在浏览器中的最小延迟为 4ms。即使我们设置了 <code>0</code>，但还是 <code>4ms</code>（或者更久一些）。所以我们安排（schedule）得越早，运行速度也就越快。</p>\n<p>所以通过任务调度（schedule），我们将一个大任务划分了多个小任务，解决了阻塞用户界面的问题，发现总耗时上也没有长很多。</p>\n<h4>例子2：进度指示</h4>\n<p>对浏览器脚本中的过载型任务进行拆分的另一个好处是，我们可以显示进度指示。</p>\n<p>正如前面所提到的，<strong>仅在当前运行的任务完成后，才会对 DOM 中的更改进行绘制，无论这个任务运行花费了多长时间</strong>。</p>\n<p>从一方面讲，这非常好，因为我们的函数可能会创建很多元素，将它们一个接一个地插入到文档中，并更改其样式 —— 访问者不会看到任何未完成的“中间态”内容。</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n    &lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;\n    &lt;button&gt;click me&lt;/button&gt;\n    &lt;script&gt;\n        function count() {\n            for (let i = 0; i &lt; 1e6; i++) {\n                i++;\n                progress.innerHTML = i;\n            }\n        }\n\n        const btn = document.getElementsByTagName(\'button\')[0]\n        const progress = document.getElementById(\'progress\')\n        btn.addEventListener(\'click\', function () {\n            count()\n        })\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p>上面的例子中，点击button后，对 <code>i</code> 的更改在该函数完成前不会显示出来，所以我们将只会看到最后的值：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111061858453.gif\" alt=\"2\" /></p>\n<p>画图分析：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111081108315.png\" alt=\"使用setTimeout优化\" /></p>\n<p>代码流程如下：</p>\n<ol>\n<li>我们点击了button后，会触发button的click回调，JavaScript引擎开始执行count方法</li>\n<li>在count方法中，有<code>1e6</code>次的<code>i++</code>操作，并且在每次<code>i++</code>之后都会有个修改<code>dom</code>的操作<code>progress.innerHTML</code>，但是由于浏览器在当前任务未完成时，是不会修改DOM的，所以先将这些操作全部先移至任务队列中，等JavaScript引擎执行完当前任务后，再去轮询任务队列的任务，所以此时会执行<code>1e6</code>次的<code>i++</code>操作，也是会消耗很长时间的，所以这段时间浏览器会是个“悬挂”的状态。</li>\n<li>当2中的任务执行完后，JavaScript引擎的当前执行任务为空，开始轮询任务队列里的任务，发现有<code>1e6</code>次的修改dom的操作，这时将控制权交由GUI引擎，由GUI引擎去执行它。</li>\n<li>GUI引擎会做一个优化，当有很多相同的操作去修改同一个dom时，只会执行一次，这里有<code>1e6</code>次的<code>progress.innerHTML=999999</code>操作，优化后只执行一次，最终的效果就如上述动图所示，浏览器卡了半天后，最后才将文字修改为999999</li>\n</ol>\n<h5>使用setTimeout优化</h5>\n<p>上述的例子，我们也可能想在任务执行期间展示一些东西，例如进度条。</p>\n<p>这时我们就可以使用<code>setTimeout</code> 将繁重的任务拆分成几部分，那么变化就会被在它们之间绘制出来。看起来效果也会更好看。</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n    &lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;\n    &lt;button&gt;click me&lt;/button&gt;\n    &lt;script&gt;\n        let i = 0;\n\n        function count() {\n            // 做繁重的任务的一部分 (*)\n            do {\n                i++;\n                progress.innerHTML = i;\n            } while (i % 1e3 !== 0);\n\n            if (i &lt; 1e5) {\n                setTimeout(count);\n            }\n        }\n\n        const btn = document.getElementsByTagName(\'button\')[0]\n        const progress = document.getElementById(\'progress\')\n        btn.addEventListener(\'click\', function () {\n            count()\n        })\n    &lt;/script&gt;\n&lt;/body&gt;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111061910826.gif\" alt=\"3\" /></p>\n<p>画图分析：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111081132926.png\" alt=\"使用timeout优化\" /></p>\n<ol>\n<li>我们点击了button后，会触发button的click回调，JavaScript引擎开始执行count方法，</li>\n<li>i每次自增到1000后都会往任务队列增加一个setTimeout，在每次自增时，还有一个innerHTML的DOM操作，也仍进任务队列。</li>\n<li>这样就给浏览器预留了一个空白的空间，每次i自增1000个数时，当前任务都执行完毕，然后，通过事件循环，开始遍历任务队列，根据先进先出原则，执行任务队列中的任务。</li>\n<li>GUI引擎在执行innerHTML=i时，会做一个优化，所有相同的操作只执行一次。</li>\n</ol>\n<p>所以最终就达成了上面动图的效果，每次i增加到1000后，浏览器就修改一次dom，整体上视觉效果更好，并且浏览器也没有了卡顿的感觉。</p>\n<h3>更详细的事件循环</h3>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111081722547.png\" alt=\"image-20211108172156416\" /></p>\n<p>更详细的事件循环图示如上图所示，（首先脚本、然后微任务、渲染等等）</p>\n<p>这里只需注意几点：</p>\n<ul>\n<li>任务队列中的异步任务都遵循先入先出原则</li>\n<li>但是每次执行完一个任务后，再次切换到任务队列时，都会优先遍历微任务队列。</li>\n</ul>\n<p>所以，微任务会在执行任何其他事件处理，或渲染，或执行任何其他宏任务之前完成。</p>\n<p>这很重要，因为它确保了微任务之间的应用程序环境基本相同（没有鼠标坐标更改，没有新的网络数据等）。</p>\n<p>如果我们<strong>想要异步执行（在当前代码之后）一个函数，但是要在更改被渲染或新事件被处理之前执行</strong>，那么我们可以使用 <code>queueMicrotask</code> 来对其进行安排（schedule）。</p>\n<h4>例子</h4>\n<p>这是一个与前面那个例子类似的，带有“计数进度条”的示例，但是它使用了 <code>queueMicrotask</code> 而不是 <code>setTimeout</code>。你可以看到它在最后才渲染。就像写的是同步代码一样：</p>\n<pre><code class=\"language-html\">&lt;body&gt;\n    &lt;div id=&quot;progress&quot;&gt;&lt;/div&gt;\n    &lt;button&gt;click me&lt;/button&gt;\n    &lt;span&gt;queueMicrotask&lt;/span&gt;\n    &lt;script&gt;\n        let i = 0;\n\n        function count() {\n            // 做繁重的任务的一部分 (*)\n            do {\n                i++;\n                progress.innerHTML = i;\n            } while (i % 1e3 !== 0);\n\n            if (i &lt; 1e6) {\n                queueMicrotask(count);\n            }\n        }\n\n        const btn = document.getElementsByTagName(\'button\')[0]\n        const progress = document.getElementById(\'progress\')\n        btn.addEventListener(\'click\', function () {\n            count()\n        })\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111081837396.gif\" alt=\"1111\" /></p>\n<p>画图分析：</p>\n<p><img src=\"http://cdn.qiniu.bnbiye.cn/img/202111081856985.png\" alt=\"微任务分析\" /></p>\n<p>上面分析只需注意下面几点：</p>\n<ol>\n<li>JavaScript引擎在当前任务未执行完成时，浏览器是不允许修改DOM的。</li>\n<li>每次从JavaScript引擎切换到任务队列开始遍历异步任务时，都是先遍历微任务队列（和nodejs一样），只有微任务队列为空时，才会去遍历宏任务队列。</li>\n<li>当JavaScript引擎在执行任务时，所有操作DOM的函数都先认定为宏任务，仍进宏任务队列。</li>\n<li>GUI引擎在执行DOM操作时，相同的操作会优化成一个，只执行一次。</li>\n</ol>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/event-loop#yong-li-3-zai-shi-jian-zhi-hou-zuo-yi-xie-shi-qing\">事件循环：微任务和宏任务</a></p>\n', '2021-11-08 19:56:56', '2021-12-09 21:54:56');
INSERT INTO `t_blog` VALUES ('feea23c0-5d5a-11ec-96d5-7933aca11ca0', 'Map和Set', 'js中的数组和对象虽然已经很强大了，但是还不足以描述所有的场景，于是就有了`Map`和`Set`', '-1', 2, 'https://zh.javascript.info/map-set', 'fe52cb50-2cbe-11ec-86ae-0da8227970f6', -1, 6, 0, 1, 2, 1, '', '<h2>前言</h2>\n<p>js中的数组和对象虽然已经很强大了，但是还不足以描述所有的场景，于是就有了<code>Map</code>和<code>Set</code>。</p>\n<h2>Map</h2>\n<p>Map 是一个带键的数据项的集合，就像一个 <code>Object</code> 一样。 但是它们最大的差别是 <code>Map</code> 允许任何类型的键（key）。</p>\n<h3>方法和属性</h3>\n<p>它的方法和属性如下：</p>\n<ul>\n<li><code>new Map()</code> —— 创建 map。</li>\n<li><code>map.set(key, value)</code> —— 根据键存储值。</li>\n<li><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</li>\n<li><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</li>\n<li><code>map.delete(key)</code> —— 删除指定键的值。</li>\n<li><code>map.clear()</code> —— 清空 map。</li>\n<li><code>map.size</code> —— 返回当前元素个数。</li>\n</ul>\n<h3>一个例子</h3>\n<pre><code class=\"language-js\">let map = new Map();\n\nmap.set(\'1\', \'str1\');   // 字符串键\nmap.set(1, \'num1\');     // 数字键\nmap.set(true, \'bool1\'); // 布尔值键\n\n// 还记得普通的 Object 吗? 它会将键转化为字符串\n// Map 则会保留键的类型，所以下面这两个结果不同：\nconsole.log( map.get(1)   ); // \'num1\'\nconsole.log( map.get(\'1\') ); // \'str1\'\n\nconsole.log( map.size ); // 3\n</code></pre>\n<p>如我们所见，与对象不同，键不会被转换成字符串。键可以是任何类型。</p>\n<blockquote>\n<p><strong><code>map[key]</code> 不是使用 <code>Map</code> 的正确方式</strong></p>\n<p>虽然 <code>map[key]</code> 也有效，例如我们可以设置 <code>map[key] = 2</code>，这样会将 <code>map</code> 视为 JavaScript 的 plain object，因此它暗含了所有相应的限制（没有对象键等）。</p>\n<p>所以我们应该使用 <code>map</code> 方法：<code>set</code> 和 <code>get</code> 等。</p>\n</blockquote>\n<h3>Map 还可以使用对象作为键</h3>\n<p>例如：</p>\n<pre><code class=\"language-js\">let john = { name: &quot;John&quot; };\n\n// 存储每个用户的来访次数\nlet visitsCountMap = new Map();\n\n// john 是 Map 中的键\nvisitsCountMap.set(john, 123);\n\nconsole.log( visitsCountMap.get(john) ); // 123\n</code></pre>\n<p>使用对象作为键是 <code>Map</code> 最值得注意和重要的功能之一。对于字符串键，<code>Object</code>（普通对象）也能正常使用，但对于对象键则不行。</p>\n<p>我们来尝试一下：</p>\n<pre><code class=\"language-js\">let john = { name: &quot;John&quot; };\n\nlet visitsCountObj = {}; // 尝试使用对象\n\nvisitsCountObj[john] = 123; // 尝试将 john 对象作为键\n\n// 是写成了这样!\nconsole.log( visitsCountObj[&quot;[object Object]&quot;] ); // 123\n</code></pre>\n<p>因为 <code>visitsCountObj</code> 是一个对象，它会将所有的键如 <code>john</code> 转换为字符串，所以我们得到字符串键 <code>&quot;[object Object]&quot;</code>。这显然不是我们想要的结果。</p>\n<blockquote>\n<p><strong><code>Map</code> 是怎么比较键的？</strong></p>\n<p><code>Map</code> 使用 <a href=\"https://tc39.github.io/ecma262/#sec-samevaluezero\">SameValueZero</a> 算法来比较键是否相等。它和严格等于 <code>===</code> 差不多，但区别是 <code>NaN</code> 被看成是等于 <code>NaN</code>。所以 <code>NaN</code> 也可以被用作键。</p>\n<p>这个算法不能被改变或者自定义。</p>\n</blockquote>\n<br>\n<blockquote>\n<p><strong>链式调用</strong></p>\n<p>每一次 <code>map.set</code> 调用都会返回 map 本身，所以我们可以进行“链式”调用：</p>\n<pre><code class=\"language-js\">map.set(\'1\', \'str1\')\n  .set(1, \'num1\')\n  .set(true, \'bool1\');\n</code></pre>\n</blockquote>\n<h3>Map迭代</h3>\n<p>如果要在 <code>map</code> 里使用循环，可以使用以下三个方法：</p>\n<ul>\n<li><code>map.keys()</code> —— 遍历并返回所有的键（returns an iterable for keys），</li>\n<li><code>map.values()</code> —— 遍历并返回所有的值（returns an iterable for values），</li>\n<li><code>map.entries()</code> —— 遍历并返回所有的实体（returns an iterable for entries）<code>[key, value]</code>，<code>for..of</code> 在默认情况下使用的就是这个。</li>\n</ul>\n<p>例如：</p>\n<pre><code class=\"language-js\">let recipeMap = new Map([\n    [\'cucumber\', 500],\n    [\'tomatoes\', 350],\n    [\'onion\', 50]\n]);\n\n// 遍历所有的键（vegetables）\nfor (let vegetable of recipeMap.keys()) {\n    console.log(vegetable); // cucumber, tomatoes, onion\n}\n\n// 遍历所有的值（amounts）\nfor (let amount of recipeMap.values()) {\n    console.log(amount); // 500, 350, 50\n}\n\n// 遍历所有的实体 [key, value]\nfor (let entry of recipeMap) { // 与 recipeMap.entries() 相同\n    console.log(entry); // cucumber,500 (and so on)\n}\n</code></pre>\n<blockquote>\n<p><strong>使用插入顺序</strong></p>\n<p>迭代的顺序与插入值的顺序相同。与普通的 <code>Object</code> 不同，<code>Map</code> 保留了此顺序。</p>\n</blockquote>\n<p>除此之外，<code>Map</code> 有内建的 <code>forEach</code> 方法，与 <code>Array</code> 类似：</p>\n<pre><code class=\"language-js\">// 对每个键值对 (key, value) 运行 forEach 函数\nrecipeMap.forEach( (value, key, map) =&gt; {\n  console.log(`${key}: ${value}`); // cucumber: 500 etc\n});\n</code></pre>\n<h3>Object.entries：从对象创建Map</h3>\n<p>当创建一个 <code>Map</code> 后，我们可以传入一个带有键值对的数组（或其它可迭代对象）来进行初始化，如下所示：</p>\n<pre><code class=\"language-js\">// 键值对 [key, value] 数组\nlet map = new Map([\n  [\'1\',  \'str1\'],\n  [1,    \'num1\'],\n  [true, \'bool1\']\n]);\n\nconsole.log( map.get(\'1\') ); // str1\n</code></pre>\n<p>如果我们想从一个已有的普通对象（plain object）来创建一个 <code>Map</code>，那么我们可以使用内建方法 <a href=\"https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\">Object.entries(obj)</a>，该方法返回对象的键/值对数组，该数组格式完全按照 <code>Map</code> 所需的格式。</p>\n<p>所以可以像下面这样从一个对象创建一个 Map：</p>\n<pre><code class=\"language-js\">let obj = {\n  name: &quot;John&quot;,\n  age: 30\n};\n\nlet map = new Map(Object.entries(obj));\n\nconsole.log( map.get(\'name\') ); // John\n</code></pre>\n<p>这里，<code>Object.entries</code> 返回键/值对数组：<code>[ [&quot;name&quot;,&quot;John&quot;], [&quot;age&quot;, 30] ]</code>。这就是 <code>Map</code> 所需要的格式。</p>\n<h3>Object.fromEntries：从Map创建对象</h3>\n<p>我们刚刚已经学习了如何使用 <code>Object.entries(obj)</code> 从普通对象（plain object）创建 <code>Map</code>。</p>\n<p><code>Object.fromEntries</code> 方法的作用是相反的：给定一个具有 <code>[key, value]</code> 键值对的数组，它会根据给定数组创建一个对象：</p>\n<pre><code class=\"language-js\">let prices = Object.fromEntries([\n  [\'banana\', 1],\n  [\'orange\', 2],\n  [\'meat\', 4]\n]);\n\n// 现在 prices = { banana: 1, orange: 2, meat: 4 }\n\nconsole.log(prices.orange); // 2\n</code></pre>\n<p>我们可以使用 <code>Object.fromEntries</code> 从 <code>Map</code> 得到一个普通对象（plain object）。</p>\n<p>例如，我们在 <code>Map</code> 中存储了一些数据，但是我们需要把这些数据传给需要普通对象（plain object）的第三方代码。</p>\n<p>我们来开始：</p>\n<pre><code class=\"language-js\">let map = new Map();\nmap.set(\'banana\', 1);\nmap.set(\'orange\', 2);\nmap.set(\'meat\', 4);\n\nlet obj = Object.fromEntries(map.entries()); // 创建一个普通对象（plain object）(*)\n\n// 完成了！\n// obj = { banana: 1, orange: 2, meat: 4 }\n\nconsole.log(obj.orange); // 2\n</code></pre>\n<p>调用 <code>map.entries()</code> 将返回一个可迭代的键/值对，这刚好是 <code>Object.fromEntries</code> 所需要的格式。</p>\n<p>我们可以把带 <code>(*)</code> 这一行写得更短：</p>\n<pre><code class=\"language-js\">let obj = Object.fromEntries(map); // 省掉 .entries()\n</code></pre>\n<p>上面的代码作用也是一样的，因为 <code>Object.fromEntries</code> 期望得到一个可迭代对象作为参数，而不一定是数组。并且 <code>map</code> 的标准迭代会返回跟 <code>map.entries()</code> 一样的键/值对。因此，我们可以获得一个普通对象（plain object），其键/值对与 <code>map</code> 相同。</p>\n<h2>Set</h2>\n<p><code>Set</code> 是一个特殊的类型集合 —— “值的集合”（没有键），它的每一个值只能出现一次。</p>\n<h3>主要方法</h3>\n<p>它的主要方法如下：</p>\n<ul>\n<li><code>new Set(iterable)</code> —— 创建一个 <code>set</code>，如果提供了一个 <code>iterable</code> 对象（通常是数组），将会从数组里面复制值到 <code>set</code> 中。</li>\n<li><code>set.add(value)</code> —— 添加一个值，返回 set 本身</li>\n<li><code>set.delete(value)</code> —— 删除值，如果 <code>value</code> 在这个方法调用的时候存在则返回 <code>true</code> ，否则返回 <code>false</code>。</li>\n<li><code>set.has(value)</code> —— 如果 <code>value</code> 在 set 中，返回 <code>true</code>，否则返回 <code>false</code>。</li>\n<li><code>set.clear()</code> —— 清空 set。</li>\n<li><code>set.size</code> —— 返回元素个数。</li>\n</ul>\n<p>它的主要特点是，重复使用同一个值调用 <code>set.add(value)</code> 并不会发生什么改变。这就是 <code>Set</code> 里面的每一个值只出现一次的原因。</p>\n<h3>一个例子</h3>\n<p>例如，我们有客人来访，我们想记住他们每一个人。但是已经来访过的客人再次来访，不应造成重复记录。每个访客必须只被“计数”一次。</p>\n<p><code>Set</code> 可以帮助我们解决这个问题：</p>\n<pre><code class=\"language-js\">let set = new Set();\n\nlet john = { name: &quot;John&quot; };\nlet pete = { name: &quot;Pete&quot; };\nlet mary = { name: &quot;Mary&quot; };\n\n// visits，一些访客来访好几次\nset.add(john);\nset.add(pete);\nset.add(mary);\nset.add(john);\nset.add(mary);\n\n// set 只保留不重复的值\nconsole.log( set.size ); // 3\n\nfor (let user of set) {\n  console.log(user.name); // John（然后 Pete 和 Mary）\n}\n</code></pre>\n<p><code>Set</code> 的替代方法可以是一个用户数组，用 <a href=\"https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Array/find\">arr.find</a> 在每次插入值时检查是否重复。但是这样性能会很差，因为这个方法会遍历整个数组来检查每个元素。<code>Set</code> 内部对唯一性检查进行了更好的优化。</p>\n<h3>Set 迭代（iteration）</h3>\n<p>我们可以使用 <code>for..of</code> 或 <code>forEach</code> 来遍历 Set：</p>\n<pre><code class=\"language-js\">let set = new Set([&quot;oranges&quot;, &quot;apples&quot;, &quot;bananas&quot;]);\n\nfor (let value of set){\n    console.log(value)\n};\n\n// 与 forEach 相同：\nset.forEach((value, valueAgain, set) =&gt; {\n  console.log(value);\n});\n</code></pre>\n<p>注意一件有趣的事儿。<code>forEach</code> 的回调函数有三个参数：一个 <code>value</code>，然后是 <strong>同一个值</strong> <code>valueAgain</code>，最后是目标对象。没错，同一个值在参数里出现了两次。</p>\n<p><code>forEach</code> 的回调函数有三个参数，是为了与 <code>Map</code> 兼容。当然，这看起来确实有些奇怪。但是这对在特定情况下轻松地用 <code>Set</code> 代替 <code>Map</code> 很有帮助，反之亦然。</p>\n<p><code>Map</code> 中用于迭代的方法在 <code>Set</code> 中也同样支持：</p>\n<ul>\n<li><code>set.keys()</code> —— 遍历并返回所有的值（returns an iterable object for values），</li>\n<li><code>set.values()</code> —— 与 <code>set.keys()</code> 作用相同，这是为了兼容 <code>Map</code>，</li>\n<li><code>set.entries()</code> —— 遍历并返回所有的实体（returns an iterable object for entries）<code>[value, value]</code>，它的存在也是为了兼容 <code>Map</code>。</li>\n</ul>\n<h2>总结</h2>\n<p><code>Map</code> —— 是一个带键的数据项的集合。</p>\n<p>方法和属性如下：</p>\n<ul>\n<li><code>new Map([iterable])</code> —— 创建 map，可选择带有 <code>[key,value]</code> 对的 <code>iterable</code>（例如数组）来进行初始化。</li>\n<li><code>map.set(key, value)</code> —— 根据键存储值。</li>\n<li><code>map.get(key)</code> —— 根据键来返回值，如果 <code>map</code> 中不存在对应的 <code>key</code>，则返回 <code>undefined</code>。</li>\n<li><code>map.has(key)</code> —— 如果 <code>key</code> 存在则返回 <code>true</code>，否则返回 <code>false</code>。</li>\n<li><code>map.delete(key)</code> —— 删除指定键的值。</li>\n<li><code>map.clear()</code> —— 清空 map 。</li>\n<li><code>map.size</code> —— 返回当前元素个数。</li>\n</ul>\n<p>与普通对象 <code>Object</code> 的不同点：</p>\n<ul>\n<li>任何键、对象都可以作为键。</li>\n<li>有其他的便捷方法，如 <code>size</code> 属性。</li>\n</ul>\n<p><code>Set</code> —— 是一组唯一值的集合。</p>\n<p>方法和属性：</p>\n<ul>\n<li><code>new Set([iterable])</code> —— 创建 set，可选择带有 <code>iterable</code>（例如数组）来进行初始化。</li>\n<li><code>set.add(value)</code> —— 添加一个值（如果 <code>value</code> 存在则不做任何修改），返回 set 本身。</li>\n<li><code>set.delete(value)</code> —— 删除值，如果 <code>value</code> 在这个方法调用的时候存在则返回 <code>true</code> ，否则返回 <code>false</code>。</li>\n<li><code>set.has(value)</code> —— 如果 <code>value</code> 在 set 中，返回 <code>true</code>，否则返回 <code>false</code>。</li>\n<li><code>set.clear()</code> —— 清空 set。</li>\n<li><code>set.size</code> —— 元素的个数。</li>\n</ul>\n<p>在 <code>Map</code> 和 <code>Set</code> 中迭代总是按照值插入的顺序进行的，所以我们不能说这些集合是无序的，但是我们不能对元素进行重新排序，也不能直接按其编号来获取元素。</p>\n<h2>参考</h2>\n<p><a href=\"https://zh.javascript.info/map-set\">https://zh.javascript.info/map-set</a></p>\n', '2021-12-15 11:56:34', '2021-12-15 11:56:34');

-- ----------------------------
-- Table structure for t_blog_like
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_like`;
CREATE TABLE `t_blog_like`  (
  `uid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `blog_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '文章id：对哪条文章的点赞，存放的评论id',
  `like_person_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '点赞人：点赞人的id',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '博客点赞表：存放用户对博客的点赞记录' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_like
-- ----------------------------
INSERT INTO `t_blog_like` VALUES ('09ce86b0-3631-11ec-94ec-9def32579e94', 'd6c6e1f0-347c-11ec-a1da-59f2d55bf031', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', 0, '2021-10-26 15:47:58', '2021-10-26 15:47:58');
INSERT INTO `t_blog_like` VALUES ('4caf9b30-359c-11ec-94ec-9def32579e94', '28792100-359c-11ec-94ec-9def32579e94', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', 0, '2021-10-25 22:03:15', '2021-10-25 22:03:15');
INSERT INTO `t_blog_like` VALUES ('a5c7ed10-2cf7-11ec-ba0f-810bb435395b', '98230e60-2cc0-11ec-86ae-0da8227970f6', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', 0, '2021-10-14 22:04:29', '2021-10-14 22:04:29');
INSERT INTO `t_blog_like` VALUES ('c78f42e0-37f6-11ec-8015-f554da021b2a', 'd6c6e1f0-347c-11ec-a1da-59f2d55bf031', '4a28c0b0-37f6-11ec-8015-f554da021b2a', 0, '2021-10-28 21:55:59', '2021-10-28 21:55:59');

-- ----------------------------
-- Table structure for t_blog_sort
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_sort`;
CREATE TABLE `t_blog_sort`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT ' 博客分类的唯一id，主键',
  `sort_name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT ' 分类名字',
  `intro` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT ' 类别的介绍信息',
  `clicks` int(11) NULL DEFAULT 0 COMMENT ' 点击数',
  `order_num` int(11) NULL DEFAULT 0 COMMENT ' 排序',
  `create_time` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT ' 创建时间',
  `update_time` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT ' 更新时间',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '博客分类表，存放博客的分类信息\r\n  比如：前端类、后台类、js类等等...' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_sort
-- ----------------------------
INSERT INTO `t_blog_sort` VALUES ('25d5ff80-2cbf-11ec-86ae-0da8227970f6', 'pupublog', '本网站实现细节、相关技术、如何部署', 0, 0, '2021-10-14 15:20:02', '2021-10-14 15:22:10');
INSERT INTO `t_blog_sort` VALUES ('33559e70-5cc3-11ec-96d5-7933aca11ca0', '数据结构与算法', '刷题汇总', 0, 4, '2021-12-14 17:49:59', '2021-12-14 17:49:59');
INSERT INTO `t_blog_sort` VALUES ('ed61f0f0-2cbe-11ec-86ae-0da8227970f6', '工具', '工作中会用的一些技术，提高开发效率', 0, 0, '2021-10-14 15:18:27', '2021-10-14 15:18:27');
INSERT INTO `t_blog_sort` VALUES ('fe52cb50-2cbe-11ec-86ae-0da8227970f6', '前端面试', '前端高频面试考点', 0, 0, '2021-10-14 15:18:56', '2021-10-14 15:18:56');

-- ----------------------------
-- Table structure for t_blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tag`;
CREATE TABLE `t_blog_tag`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '唯一id，主键',
  `tag_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标签名',
  `clicks` int(11) NULL DEFAULT 0 COMMENT '点击数',
  `order_num` int(11) NULL DEFAULT NULL COMMENT '排序，0，1，2，3，4，5...',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '博客标签表\r\n        存放博客的标签，比如每篇博客涉及到的知识点' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_tag
-- ----------------------------
INSERT INTO `t_blog_tag` VALUES ('37ef2d40-2cbf-11ec-86ae-0da8227970f6', 'pupublog', 0, 0, '2021-10-14 15:20:33', '2021-10-30 20:42:13');
INSERT INTO `t_blog_tag` VALUES ('3b767f40-2cbf-11ec-86ae-0da8227970f6', 'js', 0, 0, '2021-10-14 15:20:38', '2021-10-14 15:20:38');
INSERT INTO `t_blog_tag` VALUES ('41a34ec0-2cbf-11ec-86ae-0da8227970f6', 'git', 0, 0, '2021-10-14 15:20:49', '2021-10-14 15:20:49');
INSERT INTO `t_blog_tag` VALUES ('453cf040-2cbf-11ec-86ae-0da8227970f6', 'html', 0, 0, '2021-10-14 15:20:55', '2021-10-14 15:20:55');
INSERT INTO `t_blog_tag` VALUES ('47009940-2cbf-11ec-86ae-0da8227970f6', 'css', 0, 0, '2021-10-14 15:20:58', '2021-10-14 15:20:58');
INSERT INTO `t_blog_tag` VALUES ('4d183310-2cbf-11ec-86ae-0da8227970f6', 'koa2', 0, 0, '2021-10-14 15:21:08', '2021-10-14 15:21:08');
INSERT INTO `t_blog_tag` VALUES ('51f55110-2cbf-11ec-86ae-0da8227970f6', 'nodejs', 0, 0, '2021-10-14 15:21:16', '2021-10-14 15:21:16');
INSERT INTO `t_blog_tag` VALUES ('5e4bdbc0-54e0-11ec-96d5-7933aca11ca0', '正则表达式', 0, 0, '2021-12-04 16:58:37', '2021-12-04 16:58:37');
INSERT INTO `t_blog_tag` VALUES ('641f1720-5cc3-11ec-96d5-7933aca11ca0', '链表', 0, 0, '2021-12-14 17:51:20', '2021-12-14 17:51:20');
INSERT INTO `t_blog_tag` VALUES ('8cb9bb60-5e5b-11ec-b395-6d1b1a7579ec', '树', 0, 0, '2021-12-16 18:33:03', '2021-12-16 18:34:18');
INSERT INTO `t_blog_tag` VALUES ('e0526a30-2d94-11ec-ba0f-810bb435395b', 'vue2', 0, 0, '2021-10-15 16:49:58', '2021-10-15 16:49:58');
INSERT INTO `t_blog_tag` VALUES ('f2170bb0-3a3f-11ec-8015-f554da021b2a', '浏览器相关', 0, 8, '2021-10-31 19:44:46', '2021-10-31 19:45:06');
INSERT INTO `t_blog_tag` VALUES ('f7240800-5e49-11ec-b395-6d1b1a7579ec', '数据结构与算法', 0, 0, '2021-12-16 16:27:11', '2021-12-16 16:27:11');

-- ----------------------------
-- Table structure for t_blog_test
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_test`;
CREATE TABLE `t_blog_test`  (
  `uid` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客的唯一id，由服务端生成uuid传入',
  `blog_title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '博客的标题',
  `blog_summary` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '博客的概述',
  `blog_author_id` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '博客作者的id',
  `is_original` int(11) NOT NULL DEFAULT 1 COMMENT '是否是原创：1 原创；2转载；3 翻译；',
  `blog_sort_id` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '博客分类的id',
  `recommend_level` int(11) NULL DEFAULT -1 COMMENT '推荐等级：1 一级推荐；2 二级推荐；3 三级推荐；4 四级推荐；-1 不推荐',
  `clicks` int(11) NULL DEFAULT 0 COMMENT '博客点击量',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `is_open_comment` int(11) NULL DEFAULT 1 COMMENT '是否开启评论：1 开启；2 关闭',
  `blog_status` int(11) NULL DEFAULT 2 COMMENT '博客的状态：1 发布；2 下架；3 草稿；',
  `cover_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客封面的url',
  `blog_content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '博客内容，存的是html',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客创建时间',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '博客修改时间',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '博客详情表：\r\n    存储博客的相关信息，如标题、作者、推荐等级、内容、摘要等' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_blog_test
-- ----------------------------

-- ----------------------------
-- Table structure for t_comments
-- ----------------------------
DROP TABLE IF EXISTS `t_comments`;
CREATE TABLE `t_comments`  (
  `uid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `comment_content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '评论内容：',
  `comment_source` int(11) NOT NULL DEFAULT 1 COMMENT '评论来源：-1，关于我；1，留言板；2，专题；3，文章',
  `source_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '来源的id：存放对应来源的id，专题有专题uid，文章有文章uid，留言板uid给个默认值1，关于我uid默认值-1',
  `comment_status` int(11) NULL DEFAULT 1 COMMENT '评论状态：1，待审核；2，通过；3，违规评论',
  `comment_person_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '评论人：评论人的id',
  `commented_person_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '被评论人：被评论人的id，可以为空，第一条评论没有被评论人',
  `to_comment_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '回复的哪条评论：存放评论的id，可以为空，为空说明这条评论没有回复任何人，是第一条评论',
  `root_comment_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT '' COMMENT '根评论：存放根评论的id，这条评论链是从哪条评论发散出来的，即评论的源头，可以为空，为空说明这条评论就是根',
  `comment_layer` int(11) NOT NULL DEFAULT 1 COMMENT '评论层级：1，2，3，4，5；最多5层，避免无休止的评论，为1时表示为根评论，由前台传过来',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论表：' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comments
-- ----------------------------
INSERT INTO `t_comments` VALUES ('08abdd60-2cd5-11ec-ba0f-810bb435395b', '🤙🤙🤙', 2, '8b739720-2cd4-11ec-ba0f-810bb435395b', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '', '', '', 1, 0, '2021-10-14 17:56:42', '2021-10-14 17:56:42');
INSERT INTO `t_comments` VALUES ('14ed79d0-2cd0-11ec-ba0f-810bb435395b', '😆😆😆', 1, '1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '', '', '', 1, 0, '2021-10-14 17:21:15', '2021-10-14 17:21:15');
INSERT INTO `t_comments` VALUES ('1c5dc490-34cd-11ec-a1da-59f2d55bf031', '😎😎😎', 3, '8bafda00-346d-11ec-a1da-59f2d55bf031', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '', '', '', 1, 0, '2021-10-24 21:20:09', '2021-10-24 21:20:09');
INSERT INTO `t_comments` VALUES ('24cb0f70-2cd0-11ec-ba0f-810bb435395b', '🤙🤙🤙', -1, '-1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '3616df40-2cc9-11ec-86ae-0da8227970f6', 'fa581d10-2cc9-11ec-86ae-0da8227970f6', '4f264700-2cc9-11ec-86ae-0da8227970f6', 4, 0, '2021-10-14 17:21:42', '2021-10-14 17:21:42');
INSERT INTO `t_comments` VALUES ('3ae73590-2cd5-11ec-ba0f-810bb435395b', '👄👄👄', 1, '1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '3616df40-2cc9-11ec-86ae-0da8227970f6', '63dfe930-2cc9-11ec-86ae-0da8227970f6', '63dfe930-2cc9-11ec-86ae-0da8227970f6', 2, 0, '2021-10-14 17:58:06', '2021-10-14 17:58:06');
INSERT INTO `t_comments` VALUES ('3da70600-3853-11ec-8015-f554da021b2a', '锣鼓喧天！鞭炮齐鸣！红旗招展！热烈欢迎蘑菇大佬👏👏👏', 1, '1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '4a28c0b0-37f6-11ec-8015-f554da021b2a', '6e6afab0-37f6-11ec-8015-f554da021b2a', '6e6afab0-37f6-11ec-8015-f554da021b2a', 2, 0, '2021-10-29 08:57:50', '2021-10-29 08:57:50');
INSERT INTO `t_comments` VALUES ('4b5c98b0-3a5a-11ec-8015-f554da021b2a', '😙😙😙', 1, '1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', 'a846df00-3a59-11ec-8015-f554da021b2a', 'fa3a5530-3a59-11ec-8015-f554da021b2a', 'fa3a5530-3a59-11ec-8015-f554da021b2a', 2, 0, '2021-10-31 22:53:22', '2021-10-31 22:53:22');
INSERT INTO `t_comments` VALUES ('4f264700-2cc9-11ec-86ae-0da8227970f6', '沙发', -1, '-1', 2, '3616df40-2cc9-11ec-86ae-0da8227970f6', '', '', '', 1, 0, '2021-10-14 16:32:46', '2021-10-14 16:32:46');
INSERT INTO `t_comments` VALUES ('51658220-359c-11ec-94ec-9def32579e94', '🤙🤙🤙', 3, '28792100-359c-11ec-94ec-9def32579e94', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '', '', '', 1, 0, '2021-10-25 22:03:23', '2021-10-25 22:03:23');
INSERT INTO `t_comments` VALUES ('5844d030-37f6-11ec-8015-f554da021b2a', '😄支持~', 1, '1', 2, '4a28c0b0-37f6-11ec-8015-f554da021b2a', '58e57310-37a0-11ec-8f84-4b4f35f59103', 'eded2630-37d0-11ec-8015-f554da021b2a', '6e4ee800-37c6-11ec-8015-f554da021b2a', 3, 0, '2021-10-28 21:52:52', '2021-10-28 21:52:52');
INSERT INTO `t_comments` VALUES ('5d05b040-37cd-11ec-8015-f554da021b2a', '🙄', -1, '-1', 2, '5848c470-37cd-11ec-8015-f554da021b2a', '', '', '', 1, 0, '2021-10-28 16:59:31', '2021-10-28 16:59:31');
INSERT INTO `t_comments` VALUES ('63dfe930-2cc9-11ec-86ae-0da8227970f6', '沙发', 1, '1', 2, '3616df40-2cc9-11ec-86ae-0da8227970f6', '', '', '', 1, 0, '2021-10-14 16:33:21', '2021-10-14 16:33:21');
INSERT INTO `t_comments` VALUES ('6435bef0-37cd-11ec-8015-f554da021b2a', '1', -1, '-1', 2, '5848c470-37cd-11ec-8015-f554da021b2a', '5848c470-37cd-11ec-8015-f554da021b2a', '5d05b040-37cd-11ec-8015-f554da021b2a', '5d05b040-37cd-11ec-8015-f554da021b2a', 2, 0, '2021-10-28 16:59:43', '2021-10-28 16:59:43');
INSERT INTO `t_comments` VALUES ('65a8a950-37a0-11ec-8f84-4b4f35f59103', '测试qq登录', 1, '1', 2, '58e57310-37a0-11ec-8f84-4b4f35f59103', '', '', '', 1, 0, '2021-10-28 11:37:38', '2021-10-28 11:37:38');
INSERT INTO `t_comments` VALUES ('6e4ee800-37c6-11ec-8015-f554da021b2a', '测试微博登录', 1, '1', 2, '590b7c60-37c6-11ec-8015-f554da021b2a', '', '', '', 1, 0, '2021-10-28 16:09:53', '2021-10-28 16:09:53');
INSERT INTO `t_comments` VALUES ('6e6afab0-37f6-11ec-8015-f554da021b2a', '😉我来啦~', 1, '1', 2, '4a28c0b0-37f6-11ec-8015-f554da021b2a', '', '', '', 1, 0, '2021-10-28 21:53:29', '2021-10-28 21:53:29');
INSERT INTO `t_comments` VALUES ('739f4f60-4f6e-11ec-96d5-7933aca11ca0', '🏀🏈⚾🎁🎉', 2, 'e85efe80-30bb-11ec-bd70-1746ca2eb62a', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '', '', '', 1, 0, '2021-11-27 18:40:34', '2021-11-27 18:40:34');
INSERT INTO `t_comments` VALUES ('81dcdaa0-37f6-11ec-8015-f554da021b2a', '可以到几级评论呢~', 1, '1', 2, '4a28c0b0-37f6-11ec-8015-f554da021b2a', '4a28c0b0-37f6-11ec-8015-f554da021b2a', '5844d030-37f6-11ec-8015-f554da021b2a', '6e4ee800-37c6-11ec-8015-f554da021b2a', 4, 0, '2021-10-28 21:54:02', '2021-10-28 21:54:02');
INSERT INTO `t_comments` VALUES ('882a0360-37f6-11ec-8015-f554da021b2a', '五级评论', 1, '1', 2, '4a28c0b0-37f6-11ec-8015-f554da021b2a', '4a28c0b0-37f6-11ec-8015-f554da021b2a', '81dcdaa0-37f6-11ec-8015-f554da021b2a', '6e4ee800-37c6-11ec-8015-f554da021b2a', 5, 0, '2021-10-28 21:54:12', '2021-10-28 21:54:12');
INSERT INTO `t_comments` VALUES ('a5efb270-2ccd-11ec-86ae-0da8227970f6', '哈哈哈', -1, '-1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', 'd8d25910-2ccb-11ec-86ae-0da8227970f6', 'dde05370-2cbd-11ec-86ae-0da8227970f6', 3, 0, '2021-10-14 17:03:50', '2021-10-14 17:03:50');
INSERT INTO `t_comments` VALUES ('b87ebc70-3852-11ec-8015-f554da021b2a', '哇！蘑菇大佬！！！！！！！！！😙😙😙', 1, '1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '4a28c0b0-37f6-11ec-8015-f554da021b2a', '6e6afab0-37f6-11ec-8015-f554da021b2a', '6e6afab0-37f6-11ec-8015-f554da021b2a', 2, 0, '2021-10-29 08:54:07', '2021-10-29 08:54:07');
INSERT INTO `t_comments` VALUES ('ba048730-3854-11ec-8015-f554da021b2a', '还得继续加油呀💪', -1, '-1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', 'ca1796a0-3852-11ec-8015-f554da021b2a', 'd5798f30-3852-11ec-8015-f554da021b2a', 'd5798f30-3852-11ec-8015-f554da021b2a', 2, 0, '2021-10-29 09:08:29', '2021-10-29 09:30:33');
INSERT INTO `t_comments` VALUES ('c0016720-37d2-11ec-8015-f554da021b2a', '😁😁😁😁', -1, '-1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '5848c470-37cd-11ec-8015-f554da021b2a', '6435bef0-37cd-11ec-8015-f554da021b2a', '5d05b040-37cd-11ec-8015-f554da021b2a', 3, 0, '2021-10-28 17:38:04', '2021-10-28 17:38:04');
INSERT INTO `t_comments` VALUES ('d5798f30-3852-11ec-8015-f554da021b2a', '厉害了', -1, '-1', 2, 'ca1796a0-3852-11ec-8015-f554da021b2a', '', '', '', 1, 0, '2021-10-29 08:54:56', '2021-10-29 08:54:56');
INSERT INTO `t_comments` VALUES ('d8d25910-2ccb-11ec-86ae-0da8227970f6', '2222', -1, '-1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', 'dde05370-2cbd-11ec-86ae-0da8227970f6', 'dde05370-2cbd-11ec-86ae-0da8227970f6', 2, 0, '2021-10-14 16:50:56', '2021-10-14 16:50:56');
INSERT INTO `t_comments` VALUES ('dc80b920-3852-11ec-8015-f554da021b2a', '最多到五级😁😁😁', 1, '1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '4a28c0b0-37f6-11ec-8015-f554da021b2a', '81dcdaa0-37f6-11ec-8015-f554da021b2a', '6e4ee800-37c6-11ec-8015-f554da021b2a', 5, 0, '2021-10-29 08:55:07', '2021-10-29 08:55:07');
INSERT INTO `t_comments` VALUES ('dde05370-2cbd-11ec-86ae-0da8227970f6', '❤️', -1, '-1', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '', '', '', 1, 0, '2021-10-14 15:10:52', '2021-10-14 15:10:52');
INSERT INTO `t_comments` VALUES ('eded2630-37d0-11ec-8015-f554da021b2a', '👍👍👍', 1, '1', 2, '58e57310-37a0-11ec-8f84-4b4f35f59103', '590b7c60-37c6-11ec-8015-f554da021b2a', '6e4ee800-37c6-11ec-8015-f554da021b2a', '6e4ee800-37c6-11ec-8015-f554da021b2a', 2, 0, '2021-10-28 17:25:02', '2021-10-28 17:25:02');
INSERT INTO `t_comments` VALUES ('eff54500-2cc9-11ec-86ae-0da8227970f6', '博主真帅', -1, '-1', 2, '3616df40-2cc9-11ec-86ae-0da8227970f6', '3616df40-2cc9-11ec-86ae-0da8227970f6', '4f264700-2cc9-11ec-86ae-0da8227970f6', '4f264700-2cc9-11ec-86ae-0da8227970f6', 2, 0, '2021-10-14 16:37:16', '2021-10-14 16:37:16');
INSERT INTO `t_comments` VALUES ('f9823bf0-34cb-11ec-a1da-59f2d55bf031', '😋😋', 3, 'd6c6e1f0-347c-11ec-a1da-59f2d55bf031', 2, 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '', '', '', 1, 0, '2021-10-24 21:12:01', '2021-10-24 21:12:01');
INSERT INTO `t_comments` VALUES ('fa3a5530-3a59-11ec-8015-f554da021b2a', '小陈我来啦~❤️', 1, '1', 2, 'a846df00-3a59-11ec-8015-f554da021b2a', '', '', '', 1, 0, '2021-10-31 22:51:06', '2021-10-31 22:51:06');
INSERT INTO `t_comments` VALUES ('fa581d10-2cc9-11ec-86ae-0da8227970f6', '就比我差一点点', -1, '-1', 2, '3616df40-2cc9-11ec-86ae-0da8227970f6', '3616df40-2cc9-11ec-86ae-0da8227970f6', 'eff54500-2cc9-11ec-86ae-0da8227970f6', '4f264700-2cc9-11ec-86ae-0da8227970f6', 3, 0, '2021-10-14 16:37:34', '2021-10-14 16:37:34');

-- ----------------------------
-- Table structure for t_comments_inform
-- ----------------------------
DROP TABLE IF EXISTS `t_comments_inform`;
CREATE TABLE `t_comments_inform`  (
  `uid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `inform_type` int(11) NOT NULL DEFAULT 3 COMMENT '举报类型：1，内容包含钓鱼欺诈信息；2，内容包含色情信息；3，推广广告；',
  `inform_reason` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '举报原因：认真填写举报原因，尽可能描述详细',
  `inform_person_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '举报人：举报人的id',
  `inform_comment_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '被举报评论：被举报的评论的id',
  `comment_source` int(11) NOT NULL DEFAULT 1 COMMENT '举报的来源：-1，关于我；1，留言板；2，专题；3，文章',
  `source_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '举报来源的id：存放对应来源的id，专题有专题uid，文章有文章uid，留言板uid给个默认值-1',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论举报表：存放用户对某条评论的举报信息' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comments_inform
-- ----------------------------

-- ----------------------------
-- Table structure for t_comments_reaction
-- ----------------------------
DROP TABLE IF EXISTS `t_comments_reaction`;
CREATE TABLE `t_comments_reaction`  (
  `uid` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `comment_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '评论id：对哪条评论的态度，存放的评论id',
  `reaction_person_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '发表态度人：发表态度人的id',
  `reaction_content` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '态度：1 ?，2 ?，3 ?，4 ?，5 ?，6 ❤️，7 ?，8 ?，',
  `comment_source` int(11) NOT NULL DEFAULT 1 COMMENT '评论来源：-1，关于我；1，留言板；2，专题；3，文章',
  `source_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL DEFAULT '' COMMENT '来源的id：存放对应来源的id，专题有专题uid，文章有文章uid，留言板uid给个默认值-1',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE,
  INDEX `fk_comment_reaction`(`comment_id`) USING BTREE,
  CONSTRAINT `fk_comment_reaction` FOREIGN KEY (`comment_id`) REFERENCES `t_comments` (`uid`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci COMMENT = '评论态度表：存放用户对某条评论的态度' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_comments_reaction
-- ----------------------------
INSERT INTO `t_comments_reaction` VALUES ('14efb150-37d4-11ec-8015-f554da021b2a', '5d05b040-37cd-11ec-8015-f554da021b2a', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '4', -1, '-1', 0, '2021-10-28 17:47:36', '2021-10-28 17:47:36');
INSERT INTO `t_comments_reaction` VALUES ('2dc42ff0-30a2-11ec-8b44-5d02eb12e531', '63dfe930-2cc9-11ec-86ae-0da8227970f6', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '1', 1, '1', 0, '2021-10-19 14:02:45', '2021-10-19 14:02:45');
INSERT INTO `t_comments_reaction` VALUES ('3d8cfb80-3a5a-11ec-8015-f554da021b2a', 'fa3a5530-3a59-11ec-8015-f554da021b2a', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '7', 1, '1', 0, '2021-10-31 22:52:59', '2021-10-31 22:52:59');
INSERT INTO `t_comments_reaction` VALUES ('45e17330-2cf7-11ec-ba0f-810bb435395b', '4f264700-2cc9-11ec-86ae-0da8227970f6', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '1', -1, '-1', 0, '2021-10-14 22:01:48', '2021-10-14 22:01:48');
INSERT INTO `t_comments_reaction` VALUES ('612dfd30-37cd-11ec-8015-f554da021b2a', '5d05b040-37cd-11ec-8015-f554da021b2a', '5848c470-37cd-11ec-8015-f554da021b2a', '1', -1, '-1', 0, '2021-10-28 16:59:37', '2021-10-28 16:59:37');
INSERT INTO `t_comments_reaction` VALUES ('6ed90480-3853-11ec-8015-f554da021b2a', '6e6afab0-37f6-11ec-8015-f554da021b2a', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '4', 1, '1', 0, '2021-10-29 08:59:13', '2021-10-29 08:59:13');
INSERT INTO `t_comments_reaction` VALUES ('71303af0-3853-11ec-8015-f554da021b2a', '6e6afab0-37f6-11ec-8015-f554da021b2a', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '8', 1, '1', 0, '2021-10-29 08:59:17', '2021-10-29 08:59:17');
INSERT INTO `t_comments_reaction` VALUES ('75649010-37f6-11ec-8015-f554da021b2a', '6e6afab0-37f6-11ec-8015-f554da021b2a', '4a28c0b0-37f6-11ec-8015-f554da021b2a', '4', 1, '1', 0, '2021-10-28 21:53:41', '2021-10-28 21:53:41');
INSERT INTO `t_comments_reaction` VALUES ('780f53b0-4f6e-11ec-96d5-7933aca11ca0', '739f4f60-4f6e-11ec-96d5-7933aca11ca0', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '1', 2, 'e85efe80-30bb-11ec-bd70-1746ca2eb62a', 0, '2021-11-27 18:40:42', '2021-11-27 18:40:42');
INSERT INTO `t_comments_reaction` VALUES ('c0701d90-37c9-11ec-8015-f554da021b2a', '6e4ee800-37c6-11ec-8015-f554da021b2a', '590b7c60-37c6-11ec-8015-f554da021b2a', '1', 1, '1', 0, '2021-10-28 16:33:39', '2021-10-28 16:33:39');
INSERT INTO `t_comments_reaction` VALUES ('c1db7e50-37d2-11ec-8015-f554da021b2a', '5d05b040-37cd-11ec-8015-f554da021b2a', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '1', -1, '-1', 0, '2021-10-28 17:38:07', '2021-10-28 17:38:07');
INSERT INTO `t_comments_reaction` VALUES ('dbff7d20-2ccb-11ec-86ae-0da8227970f6', 'd8d25910-2ccb-11ec-86ae-0da8227970f6', 'b8e1a740-2cbd-11ec-86ae-0da8227970f6', '8', -1, '-1', 0, '2021-10-14 16:51:02', '2021-10-14 16:51:02');
INSERT INTO `t_comments_reaction` VALUES ('e70cff00-2cc9-11ec-86ae-0da8227970f6', '4f264700-2cc9-11ec-86ae-0da8227970f6', '3616df40-2cc9-11ec-86ae-0da8227970f6', '1', -1, '-1', 0, '2021-10-14 16:37:01', '2021-10-14 16:37:01');

-- ----------------------------
-- Table structure for t_file
-- ----------------------------
DROP TABLE IF EXISTS `t_file`;
CREATE TABLE `t_file`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '唯一id',
  `file_original_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件原始名字',
  `file_current_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件上传到服务器，在服务器的名字',
  `file_suffix` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件的类型，存放文件的后缀',
  `file_sort_id` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件的分类，属于哪个分类下的文件，这个分类的id',
  `file_sort_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件的分类，属于哪个分类下的文件，这个分类的名字',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '文件表：\r\n     存放上传的文件基本信息、文件名、文件id、文件上传时间等' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_file
-- ----------------------------
INSERT INTO `t_file` VALUES ('03424520-397e-11ec-8015-f554da021b2a', '添加标题.png', '03424520-397e-11ec-8015-f554da021b2a.png', 'png', '-1', '默认', '2021-10-30 20:36:32', '2021-10-30 20:36:32');
INSERT INTO `t_file` VALUES ('11284990-2cd2-11ec-ba0f-810bb435395b', '4.jpeg', '11284990-2cd2-11ec-ba0f-810bb435395b.jpeg', 'jpeg', '-1', '默认', '2021-10-14 17:35:28', '2021-10-14 17:35:28');
INSERT INTO `t_file` VALUES ('1de2e3f0-3e4f-11ec-97a5-ef78eceb5d73', '浏览器首屏渲染流程.png', '1de2e3f0-3e4f-11ec-97a5-ef78eceb5d73.png', 'png', '-1', '默认', '2021-11-05 23:43:26', '2021-11-05 23:43:26');
INSERT INTO `t_file` VALUES ('2eaae7b0-2d87-11ec-ba0f-810bb435395b', '4.png', '2eaae7b0-2d87-11ec-ba0f-810bb435395b.png', 'png', '-1', '默认', '2021-10-15 15:11:56', '2021-10-15 15:11:56');
INSERT INTO `t_file` VALUES ('32fce900-37d5-11ec-8015-f554da021b2a', '4.jpeg', '32fce900-37d5-11ec-8015-f554da021b2a.jpeg', 'jpeg', '-1', '默认', '2021-10-28 17:55:36', '2021-10-28 17:55:36');
INSERT INTO `t_file` VALUES ('394c4d80-420e-11ec-96d5-7933aca11ca0', '202111091631229.png', '394c4d80-420e-11ec-96d5-7933aca11ca0.png', 'png', '-1', '默认', '2021-11-10 18:08:59', '2021-11-10 18:08:59');
INSERT INTO `t_file` VALUES ('4f5a42f0-408b-11ec-97a5-ef78eceb5d73', '浏览器事件循环.png', '4f5a42f0-408b-11ec-97a5-ef78eceb5d73.png', 'png', '-1', '默认', '2021-11-08 19:59:21', '2021-11-08 19:59:21');
INSERT INTO `t_file` VALUES ('8648e570-2cc0-11ec-86ae-0da8227970f6', '2.png', '8648e570-2cc0-11ec-86ae-0da8227970f6.png', 'png', '-1', '默认', '2021-10-14 15:29:53', '2021-10-14 15:29:53');
INSERT INTO `t_file` VALUES ('8bc957a0-347c-11ec-a1da-59f2d55bf031', '微信截图_20211024114235.png', '8bc957a0-347c-11ec-a1da-59f2d55bf031.png', 'png', '-1', '默认', '2021-10-24 11:43:26', '2021-10-24 11:43:26');
INSERT INTO `t_file` VALUES ('90c26490-3599-11ec-a1da-59f2d55bf031', '9.jpg', '90c26490-3599-11ec-a1da-59f2d55bf031.jpg', 'jpg', '-1', '默认', '2021-10-25 21:43:41', '2021-10-25 21:43:41');
INSERT INTO `t_file` VALUES ('96ca9b80-2d8a-11ec-ba0f-810bb435395b', '5.png', '96ca9b80-2d8a-11ec-ba0f-810bb435395b.png', 'png', '-1', '默认', '2021-10-15 15:36:20', '2021-10-15 15:36:20');
INSERT INTO `t_file` VALUES ('9fcfc050-3214-11ec-bd70-1746ca2eb62a', 'aa.png', '9fcfc050-3214-11ec-bd70-1746ca2eb62a.png', 'png', '-1', '默认', '2021-10-21 10:14:30', '2021-10-21 10:14:30');
INSERT INTO `t_file` VALUES ('a7c1ac50-346d-11ec-a1da-59f2d55bf031', '微信截图_20211024095633.png', 'a7c1ac50-346d-11ec-a1da-59f2d55bf031.png', 'png', '-1', '默认', '2021-10-24 09:56:51', '2021-10-24 09:56:51');
INSERT INTO `t_file` VALUES ('a9fb3290-3894-11ec-8015-f554da021b2a', '3.jpg', 'a9fb3290-3894-11ec-8015-f554da021b2a.jpg', 'jpg', '-1', '默认', '2021-10-29 16:46:09', '2021-10-29 16:46:09');
INSERT INTO `t_file` VALUES ('c18e5170-30bb-11ec-bd70-1746ca2eb62a', 'aa.png', 'c18e5170-30bb-11ec-bd70-1746ca2eb62a.png', 'png', '-1', '默认', '2021-10-19 17:05:50', '2021-10-19 17:05:50');
INSERT INTO `t_file` VALUES ('c89c0600-2cd4-11ec-ba0f-810bb435395b', '3.png', 'c89c0600-2cd4-11ec-ba0f-810bb435395b.png', 'png', '-1', '默认', '2021-10-14 17:54:55', '2021-10-14 17:54:55');
INSERT INTO `t_file` VALUES ('c95ac180-347c-11ec-a1da-59f2d55bf031', '微信截图_20211024114235.png', 'c95ac180-347c-11ec-a1da-59f2d55bf031.png', 'png', '-1', '默认', '2021-10-24 11:45:10', '2021-10-24 11:45:10');
INSERT INTO `t_file` VALUES ('cbba7100-3d0f-11ec-8015-f554da021b2a', '202111031622689.png', 'cbba7100-3d0f-11ec-8015-f554da021b2a.png', 'png', '-1', '默认', '2021-11-04 09:37:39', '2021-11-04 09:37:39');
INSERT INTO `t_file` VALUES ('d68e52f0-2cbf-11ec-86ae-0da8227970f6', '1.png', 'd68e52f0-2cbf-11ec-86ae-0da8227970f6.png', 'png', '-1', '默认', '2021-10-14 15:24:59', '2021-10-14 15:24:59');
INSERT INTO `t_file` VALUES ('dba243f0-2cb5-11ec-8de6-87c3175356c3', '1.jpg', 'dba243f0-2cb5-11ec-8de6-87c3175356c3.jpg', 'jpg', '-1', '默认', '2021-10-14 14:13:32', '2021-10-14 14:13:32');
INSERT INTO `t_file` VALUES ('e80fc4c0-2d94-11ec-ba0f-810bb435395b', '1.png', 'e80fc4c0-2d94-11ec-ba0f-810bb435395b.png', 'png', '-1', '默认', '2021-10-15 16:50:11', '2021-10-15 16:50:11');

-- ----------------------------
-- Table structure for t_file_sort
-- ----------------------------
DROP TABLE IF EXISTS `t_file_sort`;
CREATE TABLE `t_file_sort`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '唯一id，主键',
  `cover_img` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类的封面图',
  `sort_name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类的标题',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '分类排序',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '文件分类表：\r\n    存放文件属于哪个分类列表下，\r\n    博客系统主要上传图片资源，\r\n    所以存放图片的所属分类' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_file_sort
-- ----------------------------
INSERT INTO `t_file_sort` VALUES ('-1', '', '默认', -1, '2021-10-14 14:13:32', '2021-10-14 14:13:32');

-- ----------------------------
-- Table structure for t_role
-- ----------------------------
DROP TABLE IF EXISTS `t_role`;
CREATE TABLE `t_role`  (
  `uid` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '唯一UUID',
  `role_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '角色名',
  `create_time` timestamp(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0) COMMENT '创建时间',
  `update_time` datetime(0) NULL DEFAULT NULL COMMENT '更新时间',
  `summarize` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '角色概述',
  `status` tinyint(2) NOT NULL DEFAULT 1 COMMENT '角色状态：1正常；2删除；',
  `user_uids` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '该角色下面所有的用户id，例如[\'1\',\'2\',\'3\']',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色表，不同角色的权限不同，只有一个超级管理员，拥有所有权限' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_role
-- ----------------------------

-- ----------------------------
-- Table structure for t_special
-- ----------------------------
DROP TABLE IF EXISTS `t_special`;
CREATE TABLE `t_special`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '专题的唯一id',
  `special_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '专题名：',
  `special_summary` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '专题的概述：',
  `cover_url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '专题封面的url：',
  `special_sort_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '专题所属分类：存放的是分类的id',
  `clicks` int(11) NULL DEFAULT 0 COMMENT '专题的点击量：',
  `is_private` int(11) NULL DEFAULT 2 COMMENT '是否为私密文章：1 是；2 否',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '专题表：存放专题信息；比如：封面、名字、介绍、专题点击量' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_special
-- ----------------------------
INSERT INTO `t_special` VALUES ('8b739720-2cd4-11ec-ba0f-810bb435395b', '现代 JavaScript 教程', '看过最好的js教程了，学习笔记归档此处，源地址：https://zh.javascript.info/', 'http://82.156.76.49:20517/upload/png/2021-10-14/c89c0600-2cd4-11ec-ba0f-810bb435395b.png', '3fe40600-2cd4-11ec-ba0f-810bb435395b', 0, 2, 2, '2021-10-14 17:53:12', '2021-12-07 19:08:34');
INSERT INTO `t_special` VALUES ('99655820-569e-11ec-96d5-7933aca11ca0', '数据结构与算法', '数据结构与算法相关知识，包括各个知识点的概念和分析，涉及到的题目主要来自牛客网和LeetCode', 'http://cdn.qiniu.bnbiye.cn/img/202112062221584.png', '3fe40600-2cd4-11ec-ba0f-810bb435395b', 0, 2, 3, '2021-12-06 22:12:52', '2021-12-06 22:12:52');
INSERT INTO `t_special` VALUES ('e85efe80-30bb-11ec-bd70-1746ca2eb62a', '前端面试题', '所有的都在这了，冲冲冲', 'http://82.156.76.49:20517/upload/png/2021-10-19/c18e5170-30bb-11ec-bd70-1746ca2eb62a.png', '3fe40600-2cd4-11ec-ba0f-810bb435395b', 0, 2, 1, '2021-10-19 17:06:55', '2021-12-02 18:05:06');
INSERT INTO `t_special` VALUES ('ebafff10-63d0-11ec-b464-8374d1e1760c', '私密专题测试', '11', 'http://cdn.qiniu.bnbiye.cn/img/202112231727007.png', 'acab8490-63cd-11ec-87dc-47e8b3d28259', 0, 1, 1, '2021-12-23 17:15:50', '2021-12-23 17:16:27');

-- ----------------------------
-- Table structure for t_special_part
-- ----------------------------
DROP TABLE IF EXISTS `t_special_part`;
CREATE TABLE `t_special_part`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `part_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '第几部分：第一部分、第二部分、第三部分等等',
  `part_title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '当前部分的大标题：',
  `part_summary` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '当前部分的概述：简要说明该部分的主旨内容',
  `special_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '属于哪个专题：存放的是专题的uid',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '专题内容中的第几部分：第一部分、第二部分、第三部分等等' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_special_part
-- ----------------------------
INSERT INTO `t_special_part` VALUES ('17ab7420-30bc-11ec-bd70-1746ca2eb62a', '第一部分', 'HTML、CSS、浏览器', '', 'e85efe80-30bb-11ec-bd70-1746ca2eb62a', 1, '2021-10-19 17:08:15', '2021-10-19 17:24:01');
INSERT INTO `t_special_part` VALUES ('32bc9f50-30bc-11ec-bd70-1746ca2eb62a', '第二部分', 'JS', '', 'e85efe80-30bb-11ec-bd70-1746ca2eb62a', 2, '2021-10-19 17:09:00', '2021-10-19 17:24:16');
INSERT INTO `t_special_part` VALUES ('52be8850-569f-11ec-96d5-7933aca11ca0', '第二部分', '算法题汇总', '', '99655820-569e-11ec-96d5-7933aca11ca0', 2, '2021-12-06 22:18:02', '2021-12-15 11:20:13');
INSERT INTO `t_special_part` VALUES ('6b09f690-30bd-11ec-bd70-1746ca2eb62a', '第五部分', '前端工程化', '', 'e85efe80-30bb-11ec-bd70-1746ca2eb62a', 5, '2021-10-19 17:17:44', '2021-11-09 17:09:28');
INSERT INTO `t_special_part` VALUES ('7fd565c0-54dd-11ec-96d5-7933aca11ca0', '第三部分', '其他文章', '', '8b739720-2cd4-11ec-ba0f-810bb435395b', 1, '2021-12-04 16:38:05', '2021-12-04 16:38:05');
INSERT INTO `t_special_part` VALUES ('8aa77150-5d57-11ec-96d5-7933aca11ca0', '第一部分', 'JavaScript编程语言', '', '8b739720-2cd4-11ec-ba0f-810bb435395b', 1, '2021-12-15 11:31:51', '2021-12-15 11:31:51');
INSERT INTO `t_special_part` VALUES ('b22fc4f0-30bd-11ec-bd70-1746ca2eb62a', '第六部分', '算法', '', 'e85efe80-30bb-11ec-bd70-1746ca2eb62a', 6, '2021-10-19 17:19:43', '2021-10-19 17:19:43');
INSERT INTO `t_special_part` VALUES ('b4795c40-30bc-11ec-bd70-1746ca2eb62a', '第三部分', 'vue', '', 'e85efe80-30bb-11ec-bd70-1746ca2eb62a', 3, '2021-10-19 17:12:38', '2021-10-19 17:24:19');
INSERT INTO `t_special_part` VALUES ('de8d7480-30bc-11ec-bd70-1746ca2eb62a', '第四部分', '计算机网络、网络安全', '', 'e85efe80-30bb-11ec-bd70-1746ca2eb62a', 4, '2021-10-19 17:13:48', '2021-10-19 17:24:23');
INSERT INTO `t_special_part` VALUES ('fd3d7e90-569e-11ec-96d5-7933aca11ca0', '第一部分', '数据结构与算法', '', '99655820-569e-11ec-96d5-7933aca11ca0', 1, '2021-12-06 22:15:39', '2021-12-15 11:20:20');

-- ----------------------------
-- Table structure for t_special_part_section
-- ----------------------------
DROP TABLE IF EXISTS `t_special_part_section`;
CREATE TABLE `t_special_part_section`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `section_title` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '当前章节标题：',
  `special_part_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '属于哪个专题部分：存放的是专题部分的uid',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '专题某部分下的章节：存放章节标题' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_special_part_section
-- ----------------------------
INSERT INTO `t_special_part_section` VALUES ('02a86580-30bf-11ec-bd70-1746ca2eb62a', '网络', 'de8d7480-30bc-11ec-bd70-1746ca2eb62a', 1, '2021-10-19 17:29:08', '2021-10-19 17:29:08');
INSERT INTO `t_special_part_section` VALUES ('04bf3a90-5c90-11ec-96d5-7933aca11ca0', '链表', '52be8850-569f-11ec-96d5-7933aca11ca0', 1, '2021-12-14 11:43:36', '2021-12-14 11:43:36');
INSERT INTO `t_special_part_section` VALUES ('0afb7060-30bf-11ec-bd70-1746ca2eb62a', '安全相关', 'de8d7480-30bc-11ec-bd70-1746ca2eb62a', 2, '2021-10-19 17:29:22', '2021-10-19 17:29:22');
INSERT INTO `t_special_part_section` VALUES ('19578b90-30be-11ec-bd70-1746ca2eb62a', 'es5', '32bc9f50-30bc-11ec-bd70-1746ca2eb62a', 1, '2021-10-19 17:22:36', '2021-10-19 17:22:36');
INSERT INTO `t_special_part_section` VALUES ('1dc93d90-30be-11ec-bd70-1746ca2eb62a', 'es6', '32bc9f50-30bc-11ec-bd70-1746ca2eb62a', 2, '2021-10-19 17:22:44', '2021-10-19 17:22:44');
INSERT INTO `t_special_part_section` VALUES ('3029ad80-30be-11ec-bd70-1746ca2eb62a', 'vue基础', 'b4795c40-30bc-11ec-bd70-1746ca2eb62a', 1, '2021-10-19 17:23:15', '2021-10-19 17:28:30');
INSERT INTO `t_special_part_section` VALUES ('3b193530-30be-11ec-bd70-1746ca2eb62a', 'vue进阶', 'b4795c40-30bc-11ec-bd70-1746ca2eb62a', 2, '2021-10-19 17:23:33', '2021-10-19 17:28:24');
INSERT INTO `t_special_part_section` VALUES ('4b2fb200-410d-11ec-94eb-3706a2e7018e', '浏览器', '17ab7420-30bc-11ec-bd70-1746ca2eb62a', 4, '2021-11-09 11:29:49', '2021-11-09 11:30:08');
INSERT INTO `t_special_part_section` VALUES ('736aa090-30be-11ec-bd70-1746ca2eb62a', 'webpack', '6b09f690-30bd-11ec-bd70-1746ca2eb62a', 1, '2021-10-19 17:25:07', '2021-11-09 16:27:23');
INSERT INTO `t_special_part_section` VALUES ('7befdf00-30be-11ec-bd70-1746ca2eb62a', 'vite', '6b09f690-30bd-11ec-bd70-1746ca2eb62a', 2, '2021-10-19 17:25:22', '2021-11-09 16:27:33');
INSERT INTO `t_special_part_section` VALUES ('8b5f9a50-569f-11ec-96d5-7933aca11ca0', '前置技能', 'fd3d7e90-569e-11ec-96d5-7933aca11ca0', 1, '2021-12-06 22:19:37', '2021-12-06 22:19:37');
INSERT INTO `t_special_part_section` VALUES ('8d4ad500-54dd-11ec-96d5-7933aca11ca0', '正则表达式', '7fd565c0-54dd-11ec-96d5-7933aca11ca0', 1, '2021-12-04 16:38:27', '2021-12-04 16:38:27');
INSERT INTO `t_special_part_section` VALUES ('9f14a130-5d57-11ec-96d5-7933aca11ca0', '数据类型', '8aa77150-5d57-11ec-96d5-7933aca11ca0', 5, '2021-12-15 11:32:25', '2021-12-15 11:32:25');
INSERT INTO `t_special_part_section` VALUES ('a3747910-589a-11ec-96d5-7933aca11ca0', '正则表达式', '32bc9f50-30bc-11ec-bd70-1746ca2eb62a', 3, '2021-12-09 10:49:33', '2021-12-09 10:49:33');
INSERT INTO `t_special_part_section` VALUES ('b38efc50-5e5b-11ec-b395-6d1b1a7579ec', '树', '52be8850-569f-11ec-96d5-7933aca11ca0', 2, '2021-12-16 18:34:08', '2021-12-16 18:34:08');
INSERT INTO `t_special_part_section` VALUES ('eedd1060-30bd-11ec-bd70-1746ca2eb62a', 'html', '17ab7420-30bc-11ec-bd70-1746ca2eb62a', 1, '2021-10-19 17:21:25', '2021-10-19 17:21:25');
INSERT INTO `t_special_part_section` VALUES ('f58ccb80-30bd-11ec-bd70-1746ca2eb62a', 'css', '17ab7420-30bc-11ec-bd70-1746ca2eb62a', 2, '2021-10-19 17:21:36', '2021-10-19 17:21:36');
INSERT INTO `t_special_part_section` VALUES ('fadccf90-30bd-11ec-bd70-1746ca2eb62a', '浏览器优化首屏加载（关键渲染路径CRP评估）', '17ab7420-30bc-11ec-bd70-1746ca2eb62a', 3, '2021-10-19 17:21:45', '2021-11-06 09:40:37');
INSERT INTO `t_special_part_section` VALUES ('ff1e8630-41fb-11ec-96d5-7933aca11ca0', 'ts', '32bc9f50-30bc-11ec-bd70-1746ca2eb62a', 4, '2021-11-10 15:58:31', '2021-12-09 10:49:07');

-- ----------------------------
-- Table structure for t_special_sort
-- ----------------------------
DROP TABLE IF EXISTS `t_special_sort`;
CREATE TABLE `t_special_sort`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '专题分类名的唯一uid',
  `special_sort_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '专题分类名：',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '专题类别表：存放专题的类别信息，比如前端、后端、AI、生活等等' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_special_sort
-- ----------------------------
INSERT INTO `t_special_sort` VALUES ('3fe40600-2cd4-11ec-ba0f-810bb435395b', '前端', 1, '2021-10-14 17:51:05', '2021-12-23 16:52:38');
INSERT INTO `t_special_sort` VALUES ('acab8490-63cd-11ec-87dc-47e8b3d28259', '业余生活', 2, '2021-12-23 16:52:35', '2021-12-23 16:53:15');

-- ----------------------------
-- Table structure for t_system_about_me
-- ----------------------------
DROP TABLE IF EXISTS `t_system_about_me`;
CREATE TABLE `t_system_about_me`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `admin_user_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '管理员id：属于哪个管理员的介绍',
  `intro_detail` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '自我介绍详情：存的是html文本',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '关于我：存放管理员的自我介绍，html文本' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_system_about_me
-- ----------------------------
INSERT INTO `t_system_about_me` VALUES ('c59dab30-2cb5-11ec-8de6-87c3175356c3', '-1', '<p>我就是小陈呀❤️</p>\n', 0, '2021-10-14 14:12:55', '2021-10-14 16:54:45');

-- ----------------------------
-- Table structure for t_system_contact_way
-- ----------------------------
DROP TABLE IF EXISTS `t_system_contact_way`;
CREATE TABLE `t_system_contact_way`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `contact_way` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '联系方式：QQ群、QQ号、邮箱等，输入的是名字',
  `way_num` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '联系方式编号：597985642@qq.com、输入的是对应联系方式的内容',
  `way_icon_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '联系方式图标名：svg图标的名字',
  `icon_color` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '图标颜色：',
  `link_address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '链接地址：掘金地址、哔哩哔哩主页地址等等',
  `is_show` int(11) NULL DEFAULT 1 COMMENT '是否展示在前台：1，展示；2，不展示',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '联系方式：前台关注我们展示的内容，存储拥有者的各类联系方式' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_system_contact_way
-- ----------------------------
INSERT INTO `t_system_contact_way` VALUES ('08af9a50-095c-11ec-b39d-47756d1ec421', '哔哩哔哩', '最最最喜欢真真的小陈', 'bilibili', '#fb7299', 'https://space.bilibili.com/24652369', 1, 7, '2021-08-30 14:32:22', '2021-10-14 14:12:19');
INSERT INTO `t_system_contact_way` VALUES ('ba2e4070-095b-11ec-b39d-47756d1ec421', 'QQ群', '780018795', 'qq-group', '#EB6841', '', 2, 1, '2021-08-30 14:30:11', '2021-10-28 17:21:10');
INSERT INTO `t_system_contact_way` VALUES ('c7487050-095b-11ec-b39d-47756d1ec421', 'QQ号', '597985642', 'qq', '#2ab39a', '', 2, 2, '2021-08-30 14:30:33', '2021-10-14 14:11:47');
INSERT INTO `t_system_contact_way` VALUES ('cd130470-2cae-11ec-b925-6b4010e76431', '掘金', '我就是小陈呀', 'juejin', '#1E80FF', 'https://juejin.cn/user/1802854801352398', 1, 6, '2021-10-14 13:23:01', '2021-10-14 14:12:13');
INSERT INTO `t_system_contact_way` VALUES ('d809fd50-095b-11ec-b39d-47756d1ec421', '邮箱', 'bnbiye@163.com', 'email', '#12aae8', '', 1, 3, '2021-08-30 14:31:01', '2021-10-14 13:13:36');
INSERT INTO `t_system_contact_way` VALUES ('e75fc550-095b-11ec-b39d-47756d1ec421', 'Github', 'hrbust_cheny', 'github', '#000000', 'https://github.com/13836005450', 2, 4, '2021-08-30 14:31:27', '2021-10-14 14:11:58');
INSERT INTO `t_system_contact_way` VALUES ('fa111460-095b-11ec-b39d-47756d1ec421', 'Gitee', '噗哧先生', 'gitee', '#E93B3C', 'https://gitee.com/hrbust_cheny', 1, 5, '2021-08-30 14:31:58', '2021-10-14 13:19:56');

-- ----------------------------
-- Table structure for t_system_friend_link
-- ----------------------------
DROP TABLE IF EXISTS `t_system_friend_link`;
CREATE TABLE `t_system_friend_link`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `link_name` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '友链名：友链名字',
  `link_intro` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '友链简介：',
  `link_address` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '友链地址：',
  `link_email` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '站长邮箱：',
  `is_publish` int(11) NULL DEFAULT 1 COMMENT '发布状态：1，发布；2，下架',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '友情链接' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_system_friend_link
-- ----------------------------

-- ----------------------------
-- Table structure for t_web_user
-- ----------------------------
DROP TABLE IF EXISTS `t_web_user`;
CREATE TABLE `t_web_user`  (
  `uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '主键：唯一uuid，由服务端生成',
  `user_tel` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '手机号：用户的手机号',
  `user_profile` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '头像：用户头像地址',
  `user_wechat` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '微信号：用户的微信',
  `user_microblog` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '新郎微博：用户的微博',
  `user_gitee` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT 'Gitee：用户的gitee账号',
  `user_github` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT 'GitHub：用户的GitHub账号',
  `user_qq` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT 'QQ：用户的qq账号',
  `user_email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '邮箱：',
  `user_password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '登录密码：用户的登录密码',
  `nick_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '昵称：用户昵称',
  `user_position` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '职位：用户职位',
  `user_company` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '公司：用户公司',
  `user_website` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '个人主页：用户个人主页',
  `user_intro` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '个人简介：用户个人简介',
  `gender` int(11) NULL DEFAULT 1 COMMENT '性别：1，男；2，女',
  `user_identity` int(11) NULL DEFAULT 1 COMMENT '用户身份：用来标识用户身份，在评论的时候展示，默认是1，普通用户；-1，小陈；-2，小噗哧；',
  `login_ip_address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '登录IP：用户最近一次登录的ip地址',
  `last_login_time` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '' COMMENT '最后登录时间：用户最后一次登录的时间',
  `account_status` int(11) NULL DEFAULT 1 COMMENT '账号状态：1，正常；2，禁言；3，禁止修改资料；4，封停；',
  `data_audit_status` int(11) NULL DEFAULT 1 COMMENT '资料审核状态：1，审核通过；2，审核中；3，驳回；',
  `account_source` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '' COMMENT '账号来源：Gitee、Github、Microblog、QQ',
  `order_num` int(11) NULL DEFAULT 0 COMMENT '排序：0，1，2，3，4.....，数越大越靠后',
  `create_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间：由服务端生成',
  `update_time` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '修改时间：由服务端生成',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '前台用户：存放登录后的用户们的个人信息' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of t_web_user
-- ----------------------------
INSERT INTO `t_web_user` VALUES ('0953f9c0-3ab6-11ec-8015-f554da021b2a', '', 'http://thirdqq.qlogo.cn/g?b=oidb&k=hricD6EqazCnajPAdWc7Jjw&s=100&t=1604067805', '', '', '', '', 'A90E9A12CE41D4B03254C77E9967E5ED', '', '', '一起看星星', '', '', '', '', 2, 1, '', '', 1, 1, 'QQ', 0, '2021-11-01 09:50:05', '2021-11-01 09:50:05');
INSERT INTO `t_web_user` VALUES ('3616df40-2cc9-11ec-86ae-0da8227970f6', '', 'https://gitee.com/assets/no_portrait.png', '', '', 'insist-insist', '', '', '', '', '坚持', '', '', '', '', 1, 1, '', '', 1, 1, 'Gitee', 0, '2021-10-14 16:32:04', '2021-10-14 16:32:04');
INSERT INTO `t_web_user` VALUES ('4a28c0b0-37f6-11ec-8015-f554da021b2a', '', 'https://portrait.gitee.com/uploads/avatars/user/282/848486_moxi159753_1578933786.png', '', '', 'moxi159753', '', '', 'moxi0624@163.com', '', '陌溪', '', '', '', '', 1, 1, '', '', 1, 1, 'Gitee', 0, '2021-10-28 21:52:28', '2021-10-28 21:52:28');
INSERT INTO `t_web_user` VALUES ('5848c470-37cd-11ec-8015-f554da021b2a', '', 'http://thirdqq.qlogo.cn/g?b=oidb&k=sF7llGxjB1MHSZ3VMTlp9Q&s=100&t=1584320509', '', '', '', '', 'EFEB6DE861B2954F57AD732572DD1CA7', '', '', 'Null', '', '', '', '', 1, 1, '', '', 1, 1, 'QQ', 0, '2021-10-28 16:59:23', '2021-10-28 16:59:23');
INSERT INTO `t_web_user` VALUES ('58e57310-37a0-11ec-8f84-4b4f35f59103', '', 'http://thirdqq.qlogo.cn/g?b=oidb&k=IJobSf3DxAxiad2WCcu8g3Q&s=100&t=1606973240', '', '', '', '', '2FAD4E4983918F90B4716FDDE01BF923', '', '', '゛一抹阳光。', '', '', '', '', 1, 1, '', '', 1, 1, 'QQ', 0, '2021-10-28 11:37:16', '2021-10-28 11:37:16');
INSERT INTO `t_web_user` VALUES ('590b7c60-37c6-11ec-8015-f554da021b2a', '', 'https://tvax4.sinaimg.cn/crop.0.0.664.664.180/e15691afly8g3ak6rnpmjj20ig0iggmj.jpg?KID=imgbed,tva&Expires=1635419357&ssig=SB6tJvOev5', '', '3780546991', '', '', '', '', '', '最最最喜欢真真的小陈', '', '', '', '', 1, 1, '', '', 1, 1, 'Microblog', 0, '2021-10-28 16:09:17', '2021-10-28 16:09:17');
INSERT INTO `t_web_user` VALUES ('7fe8ddc0-3ab2-11ec-8015-f554da021b2a', '', 'http://thirdqq.qlogo.cn/g?b=oidb&k=M9geMFsiatEGWQugOUvsJTw&s=100&t=1633532861', '', '', '', '', '20FBE675A4ADC66AAF80CF834975E751', '', '', '一个丶小号', '', '', '', '', 2, 1, '', '', 1, 1, 'QQ', 0, '2021-11-01 09:24:46', '2021-11-01 09:24:46');
INSERT INTO `t_web_user` VALUES ('a846df00-3a59-11ec-8015-f554da021b2a', '', 'http://thirdqq.qlogo.cn/g?b=oidb&k=fA3u4Fo0zSTQuxzKiafFK5A&s=100&t=1554837106', '', '', '', '', '61F7D992B66E5BA7A5AEB5564424BBCF', '', '', '噗哧(｡•̀ᴗ-)✧', '', '', '', '', 2, -2, '', '', 1, 1, 'QQ', 0, '2021-10-31 22:48:49', '2021-10-31 22:51:39');
INSERT INTO `t_web_user` VALUES ('b8e1a740-2cbd-11ec-86ae-0da8227970f6', '', 'https://portrait.gitee.com/uploads/avatars/user/517/1553068_hrbust_cheny_1617868573.png', '', '', 'hrbust_cheny', '', '', '597985642@qq.com', '', '噗哧先生', '', '', '', '', 1, -1, '', '', 1, 1, 'Gitee', 0, '2021-10-14 15:09:50', '2021-10-14 16:45:33');
INSERT INTO `t_web_user` VALUES ('ca1796a0-3852-11ec-8015-f554da021b2a', '', 'https://portrait.gitee.com/uploads/avatars/user/1759/5279965_ruolikongjian_1628251995.png', '', '', 'ruolikongjian', '', '', '', '', '若离', '', '', '', '', 1, 1, '', '', 1, 1, 'Gitee', 0, '2021-10-29 08:54:37', '2021-10-29 08:54:37');

SET FOREIGN_KEY_CHECKS = 1;